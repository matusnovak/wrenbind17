<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Files on WrenBind17</title>
    <link>https://matusnovak.github.io/wrenbind17/files/</link>
    <description>Recent content in Files on WrenBind17</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://matusnovak.github.io/wrenbind17/files/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>include</title>
      <link>https://matusnovak.github.io/wrenbind17/files/dir_d44c64559bbebec7f509842c48db8b23/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/dir_d44c64559bbebec7f509842c48db8b23/</guid>
      <description>include #  Directories #     Name     include/wrenbind17     Updated on 17 October 2023 at 12:26:25 UTC</description>
    </item>
    
    <item>
      <title>include/wrenbind17</title>
      <link>https://matusnovak.github.io/wrenbind17/files/dir_0603dac12b22d4faefe24b335e5b06be/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/dir_0603dac12b22d4faefe24b335e5b06be/</guid>
      <description>include/wrenbind17 #  Files #     Name     include/wrenbind17/allocator.hpp   include/wrenbind17/any.hpp   include/wrenbind17/caller.hpp   include/wrenbind17/exception.hpp   include/wrenbind17/foreign.hpp   include/wrenbind17/handle.hpp   include/wrenbind17/index.hpp   include/wrenbind17/map.hpp   include/wrenbind17/method.hpp   include/wrenbind17/module.hpp   include/wrenbind17/object.hpp   include/wrenbind17/pop.hpp   include/wrenbind17/push.hpp   include/wrenbind17/std.hpp   include/wrenbind17/stddeque.hpp   include/wrenbind17/stdlist.hpp   include/wrenbind17/stdmap.hpp   include/wrenbind17/stdoptional.hpp   include/wrenbind17/stdset.hpp   include/wrenbind17/stdvariant.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/allocator.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/allocator_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/allocator_8hpp/</guid>
      <description>include/wrenbind17/allocator.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;#34;index.hpp&amp;#34;#include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { void setNextError(WrenVM* vm, std::string str); #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T, typename... Args&amp;gt; struct ForeignKlassAllocator { static T* ctor(Args&amp;amp;&amp;amp;... args) { return new T(std::forward&amp;lt;Args&amp;gt;(args)...); } template &amp;lt;size_t... Is&amp;gt; static T* ctorFrom(WrenVM* vm, detail::index_list&amp;lt;Is.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/any.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/any_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/any_8hpp/</guid>
      <description>include/wrenbind17/any.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ReturnValue A return value when calling a Wren function (alias Any)    Source code #  #pragma once  #include &amp;lt;typeinfo&amp;gt;#include &amp;lt;memory&amp;gt; #include &amp;#34;handle.hpp&amp;#34;#include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { class ReturnValue { public: ReturnValue() = default; explicit ReturnValue(const WrenType type, Handle handle) : type(type), handle(std::move(handle)) { } ~ReturnValue() = default; ReturnValue(const ReturnValue&amp;amp; other) = delete; ReturnValue(ReturnValue&amp;amp;&amp;amp; other) noexcept { swap(other); } ReturnValue&amp;amp; operator=(const ReturnValue&amp;amp; other) = delete; ReturnValue&amp;amp; operator=(ReturnValue&amp;amp;&amp;amp; other) noexcept { if (this !</description>
    </item>
    
    <item>
      <title>include/wrenbind17/caller.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/caller_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/caller_8hpp/</guid>
      <description>include/wrenbind17/caller.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;#34;index.hpp&amp;#34;#include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper { static inline void push(WrenVM* vm, int index, R ret) { PushHelper&amp;lt;R&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;R&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, R&amp;amp; ret) { PushHelper&amp;lt;R*&amp;gt;::f(vm, index, &amp;amp;ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;const R&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, const R&amp;amp; ret) { PushHelper&amp;lt;R*&amp;gt;::f(vm, index, &amp;amp;const_cast&amp;lt;R&amp;amp;&amp;gt;(ret)); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;R*&amp;gt; { static inline void push(WrenVM* vm, int index, R* ret) { PushHelper&amp;lt;R*&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;const R*&amp;gt; { static inline void push(WrenVM* vm, int index, const R* ret) { PushHelper&amp;lt;const R*&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;R&amp;amp;&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, R&amp;amp;&amp;amp; ret) { PushHelper&amp;lt;R&amp;gt;::f(vm, index, std::move(ret)); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;const std::shared_ptr&amp;lt;R&amp;gt;&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, const std::shared_ptr&amp;lt;R&amp;gt;&amp;amp; ret) { PushHelper&amp;lt;const std::shared_ptr&amp;lt;R&amp;gt;&amp;amp;&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;std::shared_ptr&amp;lt;R&amp;gt;&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, std::shared_ptr&amp;lt;R&amp;gt;&amp;amp; ret) { PushHelper&amp;lt;std::shared_ptr&amp;lt;R&amp;gt;&amp;amp;&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;const std::variant&amp;lt;R&amp;gt;&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, const std::variant&amp;lt;R&amp;gt;&amp;amp; ret) { PushHelper&amp;lt;const std::variant&amp;lt;R&amp;gt;&amp;amp;&amp;gt;::f(vm, index, ret); } }; template &amp;lt;typename R&amp;gt; struct ForeginMethodReturnHelper&amp;lt;std::variant&amp;lt;R&amp;gt;&amp;amp;&amp;gt; { static inline void push(WrenVM* vm, int index, std::variant&amp;lt;R&amp;gt;&amp;amp; ret) { PushHelper&amp;lt;std::variant&amp;lt;R&amp;gt;&amp;amp;&amp;gt;::f(vm, index, ret); } }; template &amp;lt;&amp;gt; inline void ForeginMethodReturnHelper&amp;lt;const std::string&amp;amp;&amp;gt;::push(WrenVM* vm, int index, const std::string&amp;amp; ret) { PushHelper&amp;lt;const std::string&amp;amp;&amp;gt;::f(vm, index, ret); } template &amp;lt;&amp;gt; inline void ForeginMethodReturnHelper&amp;lt;std::string&amp;amp;&amp;gt;::push(WrenVM* vm, int index, std::string&amp;amp; ret) { PushHelper&amp;lt;std::string&amp;amp;&amp;gt;::f(vm, index, ret); } template &amp;lt;typename R, typename T, typename.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/exception.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/exception_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/exception_8hpp/</guid>
      <description>include/wrenbind17/exception.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Exception   class wrenbind17::NotFound   class wrenbind17::BadCast   class wrenbind17::RuntimeError   class wrenbind17::CompileError    Source code #  #pragma once  #include &amp;lt;stdexcept&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt; namespace wrenbind17 { class Exception : public std::exception { public: Exception() = default; explicit Exception(std::string msg) : msg(std::move(msg)) { } const char* what() const throw() override { return msg.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/foreign.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/foreign_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/foreign_8hpp/</guid>
      <description>include/wrenbind17/foreign.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ForeignMethod Holds information about a foreign function of a foreign class.   class wrenbind17::ForeignProp Holds information about a foreign property of a foreign class.   class wrenbind17::ForeignKlass A foreign class.   class wrenbind17::ForeignMethodImpl Type specific implementation of foreign method.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/handle.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/handle_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/handle_8hpp/</guid>
      <description>include/wrenbind17/handle.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Handle Holds a reference to some Wren type.    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;#34;exception.hpp&amp;#34; namespace wrenbind17 { std::shared_ptr&amp;lt;WrenVM&amp;gt; getSharedVm(WrenVM* vm); class Handle { public: Handle() : handle(nullptr) { } Handle(const std::shared_ptr&amp;lt;WrenVM&amp;gt; vm, WrenHandle* handle) : vm(vm), handle(handle) { } ~Handle() { reset(); } Handle(const Handle&amp;amp; other) = delete; Handle(Handle&amp;amp;&amp;amp; other) noexcept : handle(nullptr) { swap(other); } Handle&amp;amp; operator=(const Handle&amp;amp; other) = delete; Handle&amp;amp; operator=(Handle&amp;amp;&amp;amp; other) noexcept { if (this !</description>
    </item>
    
    <item>
      <title>include/wrenbind17/index.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/index_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/index_8hpp/</guid>
      <description>include/wrenbind17/index.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;memory&amp;gt; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;size_t... Is&amp;gt; struct index_list {}; // Declare primary template for index range builder  template &amp;lt;size_t MIN, size_t N, size_t... Is&amp;gt; struct range_builder; // Base step  template &amp;lt;size_t MIN, size_t... Is&amp;gt; struct range_builder&amp;lt;MIN, MIN, Is.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/map.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/map_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/map_8hpp/</guid>
      <description>include/wrenbind17/map.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Map Holds native Wren map.    Source code #  #pragma once  #include &amp;#34;method.hpp&amp;#34;#include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { class Map { public: Map() { } Map(const std::shared_ptr&amp;lt;Handle&amp;gt;&amp;amp; handle) : handle(handle) { } ~Map() { reset(); } Handle&amp;amp; getHandle() { return *handle; } const Handle&amp;amp; getHandle() const { return *handle; } operator bool() const { return handle.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/method.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/method_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/method_8hpp/</guid>
      <description>include/wrenbind17/method.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Method    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;#34;any.hpp&amp;#34;#include &amp;#34;exception.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { inline void pushArgs(WrenVM* vm, int idx) { (void)vm; (void)idx; } template &amp;lt;typename First, typename.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/module.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/module_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/module_8hpp/</guid>
      <description>include/wrenbind17/module.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ForeignModule    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;unordered_map&amp;gt; #include &amp;#34;foreign.hpp&amp;#34; namespace wrenbind17 { void addClassType(WrenVM* vm, const std::string&amp;amp; module, const std::string&amp;amp; name, size_t hash); void addClassCast(WrenVM* vm, std::shared_ptr&amp;lt;detail::ForeignPtrConvertor&amp;gt; convertor, size_t hash, size_t other); class ForeignModule { public: ForeignModule(std::string name, WrenVM* vm) : name(std::move(name)), vm(vm) { } ForeignModule(const ForeignModule&amp;amp; other) = delete; ForeignModule(ForeignModule&amp;amp;&amp;amp; other) noexcept : vm(nullptr) { swap(other); } ~ForeignModule() = default; ForeignModule&amp;amp; operator=(const ForeignModule&amp;amp; other) = delete; ForeignModule&amp;amp; operator=(ForeignModule&amp;amp;&amp;amp; other) noexcept { if (this !</description>
    </item>
    
    <item>
      <title>include/wrenbind17/object.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/object_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/object_8hpp/</guid>
      <description>include/wrenbind17/object.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;cstdlib&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;typeinfo&amp;gt;#include &amp;lt;variant&amp;gt; #include &amp;#34;exception.hpp&amp;#34;#include &amp;#34;handle.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  std::string getLastError(WrenVM* vm); inline void exceptionHandler(WrenVM* vm, const std::exception_ptr&amp;amp; eptr) { try { if (eptr) { std::rethrow_exception(eptr); } else { wrenEnsureSlots(vm, 1); wrenSetSlotString(vm, 0, &amp;#34;Unknown error&amp;#34;); wrenAbortFiber(vm, 0); } } catch (std::exception&amp;amp; e) { wrenEnsureSlots(vm, 1); wrenSetSlotString(vm, 0, e.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/pop.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/pop_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/pop_8hpp/</guid>
      <description>include/wrenbind17/pop.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;string&amp;gt;#include &amp;lt;memory&amp;gt; #include &amp;#34;object.hpp&amp;#34; namespace wrenbind17 { void getClassType(WrenVM* vm, std::string&amp;amp; module, std::string&amp;amp; name, size_t hash); detail::ForeignPtrConvertor* getClassCast(WrenVM* vm, size_t hash, size_t other); #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { // ============================================================================================================  // CHECK SLOTS FOR TYPE  // ============================================================================================================  inline const char* wrenSlotTypeToStr(const WrenType type) { switch (type) { case WREN_TYPE_BOOL: return &amp;#34;bool&amp;#34;; case WREN_TYPE_FOREIGN: return &amp;#34;instance&amp;#34;; case WREN_TYPE_LIST: return &amp;#34;list&amp;#34;; case WREN_TYPE_NULL: return &amp;#34;null&amp;#34;; case WREN_TYPE_NUM: return &amp;#34;number&amp;#34;; case WREN_TYPE_STRING: return &amp;#34;string&amp;#34;; case WREN_TYPE_UNKNOWN: default: return &amp;#34;unknown&amp;#34;; } } template &amp;lt;typename T&amp;gt; inline bool is(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type !</description>
    </item>
    
    <item>
      <title>include/wrenbind17/push.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/push_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/push_8hpp/</guid>
      <description>include/wrenbind17/push.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;#34;exception.hpp&amp;#34;#include &amp;#34;object.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  void getClassType(WrenVM* vm, std::string&amp;amp; module, std::string&amp;amp; name, size_t hash); bool isClassRegistered(WrenVM* vm, const size_t hash); detail::ForeignPtrConvertor* getClassCast(WrenVM* vm, size_t hash, size_t other); namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper; template &amp;lt;typename T&amp;gt; void pushAsConstRef(WrenVM* vm, int idx, const T&amp;amp; value) { static_assert(!</description>
    </item>
    
    <item>
      <title>include/wrenbind17/std.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/std_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/std_8hpp/</guid>
      <description>include/wrenbind17/std.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::StdVectorBindings   class wrenbind17::StdListBindings   class wrenbind17::AbstractMapBindings    Source code #  #pragma once  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;unordered_map&amp;gt;#include &amp;lt;vector&amp;gt; #include &amp;#34;module.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T, typename = void&amp;gt; struct is_equality_comparable : std::false_type {}; template &amp;lt;typename T&amp;gt; struct is_equality_comparable&amp;lt; T, typename std::enable_if&amp;lt;true, decltype(std::declval&amp;lt;T&amp;amp;&amp;gt;() == std::declval&amp;lt;T&amp;amp;&amp;gt;(), (void)0)&amp;gt;::type&amp;gt; : std::true_type {}; } // namespace detail  template &amp;lt;typename T, typename T2 = void&amp;gt; class StdVectorHelper; template &amp;lt;typename T&amp;gt; class StdVectorHelper&amp;lt;T, typename std::enable_if&amp;lt;detail::is_equality_comparable&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; { public: static bool contains(std::vector&amp;lt;T&amp;gt;&amp;amp; self, const T&amp;amp; value) { return std::find(self.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stddeque.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stddeque_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stddeque_8hpp/</guid>
      <description>include/wrenbind17/stddeque.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::deque&amp;lt;T&amp;gt;&amp;gt; { static inline void f(WrenVM* vm, int idx, std::deque&amp;lt;T&amp;gt; value) { if (isClassRegistered(vm, typeid(std::deque&amp;lt;T&amp;gt;).hash_code())) { pushAsMove&amp;lt;std::deque&amp;lt;T&amp;gt;&amp;gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdlist.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdlist_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdlist_8hpp/</guid>
      <description>include/wrenbind17/stdlist.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::list&amp;lt;T&amp;gt;&amp;gt; { static inline void f(WrenVM* vm, int idx, std::list&amp;lt;T&amp;gt; value) { if (isClassRegistered(vm, typeid(std::list&amp;lt;T&amp;gt;).hash_code())) { pushAsMove&amp;lt;std::list&amp;lt;T&amp;gt;&amp;gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdmap.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdmap_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdmap_8hpp/</guid>
      <description>include/wrenbind17/stdmap.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;map&amp;gt;#include &amp;lt;unordered_map&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::map&amp;lt;std::string, T&amp;gt;&amp;gt; { static inline void f(WrenVM* vm, int idx, std::map&amp;lt;std::string, T&amp;gt; value) { if (isClassRegistered(vm, typeid(std::map&amp;lt;std::string, T&amp;gt;).hash_code())) { pushAsMove&amp;lt;std::map&amp;lt;std::string, T&amp;gt;&amp;gt;(vm, idx, std::move(value)); } else { loopAndPushKeyPair(vm, idx, value.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdoptional.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdoptional_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdoptional_8hpp/</guid>
      <description>include/wrenbind17/stdoptional.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;optional&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt; { inline static void f(WrenVM* vm, int idx, const std::optional&amp;lt;T&amp;gt;&amp;amp; value) { if (value.has_value()) { PushHelper&amp;lt;T&amp;gt;::f(vm, idx, value.value()); } else { PushHelper&amp;lt;std::nullptr_t&amp;gt;::f(vm, idx, nullptr); } } }; template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;amp;&amp;gt; { inline static void f(WrenVM* vm, int idx, const std::optional&amp;lt;T&amp;gt;&amp;amp; value) { PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;::f(vm, idx, value); } }; template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;*&amp;gt; { inline static void f(WrenVM* vm, int idx, const std::optional&amp;lt;T&amp;gt;* value) { PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;::f(vm, idx, *value); } }; template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;const std::optional&amp;lt;T&amp;gt;&amp;amp;&amp;gt; { inline static void f(WrenVM* vm, int idx, const std::optional&amp;lt;T&amp;gt;&amp;amp; value) { PushHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;::f(vm, idx, value); } }; template &amp;lt;typename T&amp;gt; struct PopHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt; { static inline std::optional&amp;lt;T&amp;gt; f(WrenVM* vm, const int idx) { if (is&amp;lt;std::nullptr_t&amp;gt;(vm, idx)) { return std::nullopt; } else { return PopHelper&amp;lt;T&amp;gt;::f(vm, idx); } } }; template &amp;lt;typename T&amp;gt; struct PopHelper&amp;lt;const std::optional&amp;lt;T&amp;gt;&amp;amp;&amp;gt; { static inline std::optional&amp;lt;T&amp;gt; f(WrenVM* vm, const int idx) { return PopHelper&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 17 October 2023 at 12:26:25 UTC</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdset.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdset_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdset_8hpp/</guid>
      <description>include/wrenbind17/stdset.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;set&amp;gt;#include &amp;lt;unordered_set&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::set&amp;lt;T&amp;gt;&amp;gt; { static inline void f(WrenVM* vm, int idx, std::set&amp;lt;T&amp;gt; value) { if (isClassRegistered(vm, typeid(std::set&amp;lt;T&amp;gt;).hash_code())) { pushAsMove&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdvariant.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdvariant_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdvariant_8hpp/</guid>
      <description>include/wrenbind17/stdvariant.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;variant&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename VariantType&amp;gt; inline void loopAndPushVariant(WrenVM* vm, int idx, const VariantType&amp;amp; v, size_t i) { PushHelper&amp;lt;std::nullptr_t&amp;gt;::f(vm, idx, nullptr); } template &amp;lt;typename VariantType, typename T, typename... Ts&amp;gt; inline void loopAndPushVariant(WrenVM* vm, int idx, const VariantType&amp;amp; v, size_t i) { if (v.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/stdvector.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/stdvector_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/stdvector_8hpp/</guid>
      <description>include/wrenbind17/stdvector.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template &amp;lt;typename T&amp;gt; struct PushHelper&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; { static inline void f(WrenVM* vm, int idx, std::vector&amp;lt;T&amp;gt; value) { if (isClassRegistered(vm, typeid(std::vector&amp;lt;T&amp;gt;).hash_code())) { pushAsMove&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/variable.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/variable_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/variable_8hpp/</guid>
      <description>include/wrenbind17/variable.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Variable Holds some Wren variable which can be a class or class instance.    Source code #  #pragma once  #include &amp;lt;memory&amp;gt; #include &amp;#34;exception.hpp&amp;#34;#include &amp;#34;method.hpp&amp;#34;#include &amp;#34;pop.hpp&amp;#34;#include &amp;#34;push.hpp&amp;#34; namespace wrenbind17 { class Variable { public: Variable() { } Variable(const std::shared_ptr&amp;lt;Handle&amp;gt;&amp;amp; handle) : handle(handle) { } ~Variable() { reset(); } Method func(const std::string&amp;amp; signature) { if (const auto ptr = handle-&amp;gt;getVmWeak().</description>
    </item>
    
    <item>
      <title>include/wrenbind17/vm.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/vm_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/vm_8hpp/</guid>
      <description>include/wrenbind17/vm.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::VM Holds the entire Wren VM from which all of the magic happens.   class wrenbind17::VM::Data    Source code #  #pragma once  #include &amp;lt;wren.hpp&amp;gt; #include &amp;lt;iostream&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;cassert&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;fstream&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;unordered_map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;memory&amp;gt; #include &amp;#34;exception.</description>
    </item>
    
    <item>
      <title>include/wrenbind17/wrenbind17.hpp</title>
      <link>https://matusnovak.github.io/wrenbind17/files/wrenbind17_8hpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/files/wrenbind17_8hpp/</guid>
      <description>include/wrenbind17/wrenbind17.hpp #  Source code #  #pragma once  #include &amp;#34;std.hpp&amp;#34;#include &amp;#34;stddeque.hpp&amp;#34;#include &amp;#34;stdlist.hpp&amp;#34;#include &amp;#34;stdmap.hpp&amp;#34;#include &amp;#34;stdoptional.hpp&amp;#34;#include &amp;#34;stdset.hpp&amp;#34;#include &amp;#34;stdvariant.hpp&amp;#34;#include &amp;#34;stdvector.hpp&amp;#34;#include &amp;#34;vm.hpp&amp;#34; Updated on 17 October 2023 at 12:26:25 UTC</description>
    </item>
    
  </channel>
</rss>