# Tutorial

## 0. Installation

You don't need to compile this library. This library is a header only! All you have to do is to include the `#include <wrenbind17/wrenbind17.hpp>` header in your application. 

This library will also need an access to `<wren.hpp>` and you will also need to link the Wren library. To see how to build the Wren library, see [Getting Started section here](http://wren.io/getting-started.html).

Optionally, you can build wrenbind17 with Wren. To do this, simply clone this repository, and use CMake:

```bash
git clone https://github.com/matusnovak/wrenbind17.git
cd wrenbind17
mkdir build
cd build
cmake .. -DWRENBIND17_BUILD_WREN=ON
cmake --build .
```

## 1. Hello World

First, create a `wren::VM` instance, find the method you want to run, and execute the method. In the example below, we are printing out a simple "Hello World" to the console. It is recommended that you create an alias from `wrenbind17` to `wren` so you don't have to type that many characters every time. I highly encourage you to **NOT** to use `using namespace wrenbind17;`!

```cpp
#include <wrenbind17/wrenbind17.hpp>
namespace wren = wrenbind17; // Alias

int main(int argc, char *argv[]) {
    const std::string code = R"(
        class Main {
            static main() {
                System.print("Hello World!")
            }
        }
    )";

    // Create new VM
    wren::VM vm;

    // Runs the code from the std::string as a "main" module
    vm.runFromSource("main", code);

    // Find class Main in module main
    wren::Variable mainClass = vm.find("main", "Main");

    // Find function main() in class Main
    wren::Method main = mainClass.func("main()");

    // Execute the function
    main();

    return 0;
}
```

## 2. Executing code

Executing Wren code can be done in the following ways:

```cpp
// Execute from raw std::string and specify the module name manually.
// Can be any module name you want!
vm.runFromSource("main", "var i = 42");

// Same as above, specify the module name but instead
// of the source code you tell it where the file is located.
vm.runFromFile("main", "path/to/some/main.wren");

// Run specific module. This module must be an existing file "utils/libB.wren"
// in one or more look-up paths specified during creation of wren::Vm vm(...);
// Read through Modularity section(s) further down!
vm.runFromModule("utils/libB");
```

## 3. Exceptions

TODO

## 4. Binding C++ classes

### 4.1. Basics

To bind a C++ class, you will first need to create a new module. Creating a new module is done per VM basis. If you have multiple VMs in your application, they won't share the same modules. You would have to create the module for each of your VM instances.

```cpp
wren::VM vm;

// Create module called "mymodule"
auto m = vm.module("mymodule");
```

You can create as many modules as you want. Additionally, calling the method `module(...)` multiple times with the same name won't create duplicates. For example:

```cpp
wren::VM vm;

auto m0 = vm.module("mymodule");
auto m1 = vm.module("mymodule");

// m0 and m1 now point to the exact same module
```

Classes are added into the modules in the following way:

```cpp
class Foo {
public:
    Foo(const std::string& msg) {
        ...
    }

    void bar() {

    }

    int baz() const {

    }
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Foo"
auto& cls = m.klass<Foo>("Foo");

// Define constructor (you can only specify one constructor)
cls.ctor<const std::string&>();

// Add some methods
cls.func<&Foo::bar>("bar");
cls.func<&Foo::baz>("baz");
```

::: tip
Note!

The class functions (methods) are added as a template argument, not as the function argument. This is due to the how Wren is built. Because of this implementation, you will also get extra performance, because the pointers to the class functions are optimized at compile time.
:::

Now inside of your Wren script, you can do the following:

```js
import "mymodule" for Foo

var foo = Foo.new("Message")
```

Please note that you don't have to manually create file "mymodule.wren" and add all of your C++ foreign classes into it manually. Everything is automatically generated by the `wren::VM`. You can get the "raw" contents of the module that will be put into Wren by simply calling `.str()` on the module (e.g. `vm.module("mymodule").str();`).

### 4.2. Function ambiguity

In case you have multiple functions with the same name, you will have to use `static_cast` to explicitly tell the compiler which function you want. For example:

```cpp
class Foo {
    const std::string& getMsg() const;
    std::string& getMsg();
};

wren::VM vm;
auto& m = vm.module("mymodule");
auto& cls = vm.klass<Foo>("Foo");
cls.func<static_cast<const std::string& (*)(void) const>(&Foo::getMsg)>("getMsg");
```

### 4.3. Static functions

To add a static function, simply call the `funcStatic` instead of `func` as shown below:

```cpp
class Log {
    static void debug(const std::string& text);
    static void error(const std::string& text);
    static void info(const std::string& text);
};

wren::VM vm;
auto m = vm.module("mymodule");
auto& cls = m.klass<Log>("Log");
cls.funcStatic<&Log::debug>("debug");
cls.funcStatic<&Log::error>("error");
cls.funcStatic<&Log::info>("info");
```


## 5. Bind C++ class varialbles and properties

There are two ways how to add C++ class variables to Wren.

### 5.1. As variables

One way is to have a field and simply bind it to the Wren:

```cpp
struct Vec3 {
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.var<&Vec3::x>("x");
cls.var<&Vec3::y>("y");
cls.var<&Vec3::z>("z");
```

### 5.2. As properties

Another way is to have a getter and a setter and bind those to the Wren:

```cpp
class Vec3 {
public:
    float getX() const     { return x; }
    void setX(float value) { x = value; }
    float getY() const     { return y; }
    void setY(float value) { y = value; }
    float getZ() const     { return z; }
    void setZ(float value) { z = value; }
private:
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.prop<&Vec3::getX, &Vec3::setX>("x");
cls.prop<&Vec3::getY, &Vec3::setY>("y");
cls.prop<&Vec3::getZ, &Vec3::setZ>("z");
```

### 5.3. Result

Equivalent wren code for both using `.var<&field>("name")` or `.prop<&getter, &setter>("name")`:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x
    foreign x=(rhs)

    foreign y
    foreign y=(rhs)

    foreign z
    foreign z=(rhs)
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new()
v.x = 1.23
v.y = 0.0
v.z = 42.42
```

## 6. Bind C++ class read only variables

To bind read-only variables you can use `varReadonly` function. This won't define a Wren setter and therefore the variable can be only read. 

```cpp
class Vec3 {
public:
    Vec3(float x, float y, float z) {...}

    const float x;
    const float y;
    const float z;
};

wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.varReadonly<&Vec3::x>("x");
cls.varReadonly<&Vec3::y>("y");
cls.varReadonly<&Vec3::z>("z");
```

Equivalent wren code:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x

    foreign y

    foreign z
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new(1.1, 2.3, 3.3)
System.print("X value is: %(v.x)") // ok
v.x = 1.23 // error
```

For read-only properties, you can use `propReadonly` as shown below:

```cpp
// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.propReadonly<&Vec3::getX>("x");
cls.propReadonly<&Vec3::getY>("y");
cls.propReadonly<&Vec3::getZ>("z");
```

## 7. Bind C++ abstract classes

What if you want to pass an abstract class to Wren? You can't allocate it. You can only pass it around. Imagine a specific derived "Entity" class that has a common abstract/interface class?

The only thing you have to do is to NOT do add `ctor`

```cpp
wren::VM vm;
auto m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Entity>("Entity");
// cls.ctor<>(); Do not add constructor!
cls.func<&Entity::foo>("foo");
```

## 8. Call Wren function

### 8.1. Basics

In order to call Wren functions, you will need to define those functions in a Wren class. The most common way to do that is to declare the function as static:

```js
class Main {
    static main(a, b) {
        return a + b
    }
}
```

To find the function, you will first need to compile the source, and only then look for the specific class. When you get the class, you can find the any specific function inside of that class. To execute the function, call the `operator()(Args&&... args)` method on `wren::Method`. 

```cpp
wren::VM vm;

// Runs the code as a specific "somemodule" module.
vm.runFromSource("somemodule", "...code from above...");

// Find the class
wren::Variable wrenClass = vm.find("somemodule", "Main");

// Find the function with two arguments
wren::Method wrenMethod = wrenClass.func("main(_, _)");

// Call the function with two integers
wren::Any result = wrenMethod(10, 15);

// Check if the result is some specific C++ type
result.is<int>(); // true

// Cast the result to C++ type
int sum = result.as<int>(); // 15
```

::: warning
Warning!

The lifetime of the object returned by calling Wren methods is determined by the wren::Any. If you return an instance of a class from Wren to C++, and you capture that result as a pointer/reference to the class (i.e. `result.as<Foo*>()` or `result.as<Foo&>()`) then the lifetime of that pointer or reference will depend on the lifetime of wren::Any and how is the class instantiated on Wren (did you return a local variable or a global variable?). Read more in the next section 6.
:::

### 8.2. Wren functions don't need to be static

```js
class Main {
    construct new() {

    }

    main(a, b) {
        return a + b
    }
}

var Instance = Main.new()
```

And then in C++:

```cpp
// Find the class
wren::Variable wrenClass = vm.find("somemodule", "Instance");

// Find the function with two arguments
wren::Method wrenMethod = wrenClass.func("main(_, _)");
```

## 9. Lifetime of objects returned by Wren

### 9.1. Return global variables

Suppose you have created an instance of a C++ class in Wren as a global variable:

```js
import "mymodule" for Foo

// Starts with capital letter so we can access it inside
// functions and classes
var Instance = Foo.new()

class Main {
    static main() {
        return Instance
    }
}
```

Then if you access the instance via C++:

```cpp
auto main = vm.find("main", "Main").func("main()");
wren::Any result = main();
Foo cpy = result.as<Foo>();
// cpy is now a copy of Wren's Foo instance.
// The lifetime of cpy or "Instance" is not modified.
```

Then nothing much happens because you are creating a copy of Foo. But what if you access it by a pointer?

```cpp
auto main = vm.find("main", "Main").func("main()");
wren::Any result = main();
Foo* ptr = result.as<Foo*>();
// ptr points to the same instance as Wren's "Instance" var.

// Using this pointer is OK because the instance will be alive
// until the Wren VM shuts down.
ptr->someMethod();

delete ptr; // Segmentation fault, memory is managed by Wren!
```

Then you have a pointer to the same instance, but when will it get free? Only when Wren VM gets shut doen (VM gets deleted, falls out of the scope, etc). So the pointer you get is valid as long as the VM is alive. **After that, it will get deleted by Wren, so don't free it manually!**

### 9.2. Return local variables

But what about returning local variables?

```js
import "mymodule" for Foo

class Main {
    static main() {
        return Foo.new()
    }
}
```

Then if you access the instance via C++:

```cpp
auto main = vm.find("main", "Main").func("main()");
Foo* ptr = null;

{ // Inside of some scope
    wren::Any result = main();
    ptr = result.as<Foo*>();
    ptr->someMethod(); // OK
}

// At this point, the result (wren::Any)
// has been destroyed because it has fallen out of the scope

ptr->someMethod(); // Undefined bahvior
```

The Wren language is garbage collected. Therefore once the variable is out of the scope, it may or may not be destroyed. It depends on the implementation of the language. But! **The wren::Any will extend the lifetime of the object** so you can use the pointer as long as the result is alive.

### 9.3. Using std::shared_ptr

One way to avoid these bad scenarios is to use modern C++11 features! If you use this:

```cpp
auto main = vm.find("main", "Main").func("main()");


wren::Any result = main();
std::shared_ptr<Foo> ptr = result.shared<Foo>();

ptr->someMethod(); // OK
```

So now you have extended the lifetime of the Foo instance by using a shared pointer. This shared pointer points to the exact same instance as the internal implementation of this library. The instances are passed around as a shared pointer (even if you pass it as a raw pointer), so the Foo will be alive even after the Wren VM has shut down. The memory will be managed by both C++ and Wren, because all C++ class instances are shared pointers.

If it is still confusing, then you can think of it as:

```cpp
// Let's think of this as wren::Any (result of a function call)
std::shared_ptr<Foo> result;

Foo* ptr = result.get(); // Obviously dangerous
std::shared_ptr<Foo> ptr = result; // Safe
```

::: warning
Warning!

This is all OK until your Foo instance from above will use some additional Wren variables. If it is just a plain C++ class and you have only created it on the Wren side, then you have nothing to worry about. If your C++ class contains some other Wren instances, then it really depends on your own implementation of your application.
:::

### 9.4. Lifetime of objects passed to C++ functions

So how does all of the above behave on C++ functions? Suppose we have the following:

```cpp
class Foo {
    // Danger! We will get an instance of local
    // Foo variable from Wren. This pointer may be invalid 
    // once you exit this function! The pointer will be 
    // valid only during the execution of this function body.
    void setParent(Foo* other) {

    }
};
```

And then inside of Wren code:

```js
class Main {
    static main(child) {
        child.setParent(Foo.new())
    }
}
```

It will behave exactly same as returning a variable from calling Wren function! The pointer will point to the local Wren instance that may be garbage collected almost right after the call has been made. Don't pass instances like that. Either make the instance a global Wren variable or use smart pointers as shown below:

```cpp
class Foo {
    // Much better and it's safe!
    void setParent(std::shared_ptr<Foo> other) {

    }
};
```

And then inside of Wren code:

```js
class Main {
    static main(child) {
        child.setParent(Foo.new())
    }
}
```

### 9.5. TL;DR

* Getting `Foo` from Wren is OK.
* Getting `Foo*` from Wren is OK as long as the variable in Wren is global. (Or you somehow ensure that you use the dangling pointer on C++ safely, for example using it only inside of the C++ function being called).
* Getting `Foo&` from Wren is same as `Foo*`.
* Getting `std::shared_ptr<Foo>` is always safe.

## 10. Lifetime of objects passed into Wren 

In the previous section we have discussed what happens with objects that are returned from Wren, but what about the other way around?

It's very simple in this case. There are only 4 different scenarios:

* Pass class `Foo` as a value. The Wren will create a copy of it. 
* Pass class `Foo*` as a pointer. The instance will be wrapped into `std::shared_ptr<Foo>` **but won't free it**. So it will be alive inside of Wren until you free the instance on C++ side. Wren's garbage collector won't free this instance.
* Pass class `Foo&` as a reference. This is the same case as passing a pointer.
* Pass class `std::shared_ptr<Foo>` as a shared pointer. The lifetime of this object will be extended by Wren. So both C++ and Wren will manage the lifetime of this. If you lose the shared pointer on C++ side, and Wren holds the instance, then it will be freed by Wren's garbage collector only when the instance inside of Wren gets no longer used/referenced.

## 11. Bind C++ class methods via external functions

Suppose you have some C++ class you want to bind to Wren, but you can't modify this class because it is from some other library, for example from STL. You want to add some custom behavior but such C++ method does not exist. In this case, you can do the following:

```cpp
template<typename T>
bool vectorContains(std::vector<T>& self, const T& value) {
    return std::find(self.begin(), self.end(), value) != self.end();
}

auto& cls = m.klass<std::vector<int>>("VectorInt");
cls.ctor<>();
cls.funcExt<&contains<int>>("contains");
```

```js
import "mymodule" for VectorInt

var v = VectorInt.new()
v.contains(123) // returns bool
```

"Ext" simply means that this is an external function, and the first parameter **must** accept a reference to the class you are binding. Look at the `vectorContains` function from above, there is no "this" pointer because this is not a member function, instead "this" is provided as a custom first parameter. This also works with `propExt` and `propReadonlyExt`.

## 12. Modularity: internal build-in modules

Modules can be created in the following way:

```cpp
wren::VM vm;
auto m = vm.module("mymodule");

auto& cls = m.klass<Entity>("Entity");
cls.func<&Entity::foo>("foo");
...
```

But, you are also able to create your own "raw" modules.

```cpp
wren::VM vm;
auto m = vm.module("mymodule");

m.append(R"(
    class Vec3 {
        construct new (x, y, z) {
            ...
        }
    }
)");
```

Anything you add via `m.append(...)` will be loaded into Wren when you import that module. Anything you put inside of `append(...)` will always be appended at the end of the module. Meaning, if you bind some C++ classes, the raw string(s) you append to that module will always be after the C++ classes. You can append as much code as you want, until you run out of system memory.

These modules can be loaded in Wren by calling:

```js
import "mymodule" for Foo, Vec3
```

::: tip
Note!

You can use `mymodule/something` as a built in module names. Slashes are allowed.
:::

## 13. Modularity: import Wren files

Other source code files can be imported into Wren. But this depends on the lookup paths. When creating an instance of the VM, the first argument is a list of paths to use for lookup. Example below:

```cpp
std::vector<std::string> paths = {
    "some/relative/path",
    "C:/absolute/path"
};
wren::VM vm(paths);
```

::: warning
Warning!

The default value of the VM constructor is `{"./"}`. This means that by default the VM will look for files relative to your working directory! If there is a file `libs/mylib.wren` in your working directory, and in Wren you load it as `import "libs/mylib" for XYZ` then it will load it from your working directory as `"your_working_dir" + "./" + "libs/mylib.wren"`.
:::

So how does the lookup paths work? Consider the following example:

```
myprogram/
    app.exe
    data/
        main.wren
        libA.wren
        utils/
            libB.wren
```

So you have three files: `data/main.wren`, `data/libA.wren`, and `data/utils/libB.wren`. Now, inside of your main you might have something like this:

```js
// File: data/main.wren

import "libA" for XYZ
// Won't work because "libA.wren" does not exist in "./"
```

And let's assume you are running `app.exe` with working directory of `myprogram/`. The above code will fail. Why? Because the default argument for `wren::VM` paths is `{"./"}`. Meaning, it will look for `libA.wren` relatively to `./` which is relative to your working directory. 

::: warning
Relative imports do not work due to the design of Wren! Absolute imports are the only way!
:::

What you need to do is to put an absolute path to `myprogram/data` into your `wren::VM vm({"C:/whatever/apps/myprogram/data"});`. So only then the import will work. The import system works in a way that it will append the import string into your lookup paths and checks wether the file exists. If yes, it will load it. 

What about importing `utils/libB.wren`? The following will work:

```js
// File: data/libA.wren

import "utils/libB" for XYZ
// looks for "C:/whatever/apps/myprogram/data/" + "utils/libB.wren"
```

Imports from a parent folder work too, because everything is absolute path anyway.

```js
// File: data/utils/libB.wren

import "libA" for XYZ 
// looks for "C:/whatever/apps/myprogram/data/" + "libA.wren"
```

## 14. Inheritance via composition

Wren does not support inheritacne of foreign classes. But, there is a workaround. Consider the following C++ class:

```cpp
class Entity {
public:
    Entity() { ... }
    virtual ~Entity() { ... }

    virtual void update() = 0;
};
```

Now we want to have our own class in Wren:

```js
import "game" for Entity

class Enemy is Entity { // Not allowed by Wren :(
    construct new (...) {

    }

    update() {
        // Do something specific for Entity class
    }
}
```

But this does not work. You can't inherit from foreign classes. But, don't lose hope yet, there is a workaround. First, we need to create a C++ derived class of the base abstract class that overrides the update method.

```cpp
class WrenEntity: public Entity {
public:
    // Pass the Wren class to the constructor
    WrenEntity(wren::Variable derived) {
        // Find all of the methods you want to "override"
        // The number of arguments (_) or (_, _) does matter!
        updateFn = derived.func("update(_)");
    }

    virtual ~WrenEntity() {

    }

    void update() override {
        // Call the overriden Wren methods from
        // the Wren class whenever you need to.
        // Pass this class as the base class
        updateFn(this);
    }

private:
    // Store the Wren methods as class fields
    wren::Method updateFn;
};

wren::VM vm;
auto m = vm.module("game");
auto& cls = m.klass<WrenEntity>("Entity");
cls.ctor<wren::Variable>();

vm.runFromSource("main", ...);

// Call the main function (see Wren code below)
auto res = vm.find("main", "Main").func("main()");

// Get the instance with Wren's specific functions
std::shared_ptr<WrenEntity> enemy = res.shared<WrenEntity>();
```

And the following Wren code to be used with the code above:

```js
import "game" for Entity

class Enemy {
    update (self) {
        // self points to the base class!
    }
}

class Main {
    static main () {
        // Pass our custom Enemy class
        // to the base Entity class into the constructor.
        // The base class will call the necessary functions.
        return Entity.new(Enemy.new())
    }
}
```

With the example from above, if the methods are missing in the Wren's `Enemy` class, it will simply throw an exception, because `derived.find(signature)` throws `wren::NotFound` exception if not found.

## 15. Using callbacks via Fn.new

Let's say you have a GUI button widget and you want to have a specific action when a user clicks on it.

```cpp
class GuiButton {
public:
    GuiButton(std::function<bool(int)> func) : func(std::move(func)) {
    }

    virtual ~GuiButton() {
    }

    bool event(int type) {
        return func(type);
    }
private:
    std::function<bool(int)> func;
};
```

And now you would like to create this class in Wren and add some custom Wren function as the callback. What you can do is to create a Wren specific wrapper and accept a class instance (in this case, `Fn` class instance from Wren).

```cpp
class WrenGuiButton: public GuiButton {
public:
    WrenGuiButton(wren::Variable fn) 
      : GuiButton(std::bind(&WrenGuiButton::wrenEvent, this, std::placeholders::_1)) {
        callback = fn.func("call(_)");
    }

private:
    bool wrenEvent(int type) {
        return callback(type).as<bool>();
    }

    wren::Method callback;
};
```

Or using lambdas:

```cpp
class WrenGuiButton: public GuiButton {
public:
    WrenGuiButton(wren::Variable fn) 
      : GuiButton([this](int type) -> bool { return callback(type).as<bool>(); }) {
        callback = fn.func("call(_)");
    }

private:
    wren::Method callback;
};
```

And then bind the class in the following way:

```cpp
wren::VM vm;
auto& m = vm.module("test");
auto& cls = m.klass<WrenGuiButton>("GuiButton");
cls.ctor<wren::Variable>();
```

And you can use it in the following way:

```js
import "test" for GuiButton

class Main {
    static main() {
        var btn = GuiButton.new(Fn.new { |arg|
            // "this" is going to be "Main" class
            return true
        })
        return btn
    }
}
```

This works because Wren's `Fn.new{}` is actually an instance of a class, and executing the method is simple as calling `call(...)` of that instance.

## 16. Upcasting

Upcasting is when you have a derived class `Enemy` and you would like to upcast it to `Entity`. An `Enemy` class is an `Entity`, but not the other way around. Remember, upcasting is getting the base class!

But this might be a problem when for example, you create a derived class inside of Wren and you pass it into some C++ function that accepts the base class. What you have to do is to tell Wren what base classes it can be upcasted to. Consider the following example:

```cpp
class Entity {
    void update();
};

class Enemy: public Entity {
    ...
};

class EntityManager {
    void add(std::shared_ptr<Entity> entity) {
        entities.push_back(entity);
    }
};

Wren::VM vm;
auto& m = vm.module("game");

// Class Entity
auto& entityCls = m.klass<Entity>("Entity");
entityCls.func<&Entity::update>("update");

// Class Enemy
// Notice how we are adding two classes here as template parameters.
// The first template parameter is the class you are binding.
// The second and next template parameters are the classes for upcasting.
auto& enemyCls = m.klass<Enemy, Entity>("Enemy");
// Classes won't automatically inherit functions and properties
// therefore you will have to explicitly add them for each
// derived class!
enemyCls.func<&Enemy::update>("update");

// Class EntityManager
auto& mngClass =m.klass<EntityManager>("EntityManager");
mngClass.func<&EntityManager::add>("add");
```

And then inside of Wren:

```js
import "game" for EntityManager, Enemy

var manager = ...

var e = Enemy.new()
e.update()
manager.add(e) // ok
```

::: tip
Note!

Upcasting like this only works when you want accept a reference, pointer, or a shared_ptr of the base class. This won't work with plain value types.
:::

## 17. Lists

### 17.1 Pre-made STL vector and list bindings

Lists are not implemented in this library natively. However, they are added as an optional thing you can use. The `std::vector<T>` and `std::list<T>` are implemented via `wren::StdVectorBindings<T>::bind(module, name);` and as `wren::StdListBindings<T>::bind(module, name);`. For example:

```cpp
Wren::VM vm;
auto& m = vm.module("std");
wren::StdVectorBindings<int>::bind(m, "VectorInt");
```

And then inside of Wren:

```js
import "std" for VectorInt

var v = VectorInt.new()
v.add(42) // Push new value
v.insert(-1, 20) // Insert at the end
v.contains(42) // returns true
v.pop() // Remove last element and returns it
v.count // Returns the length/size
v.size() // Same as the count
v.clear() // Removes everything
v.removeAt(-2) // Removes the 2nd element from back and returns it
v[0] = 43 // Set specific index (negative indexes not supported!)
System.print("Second: %(v[1])") // Get specific index (no negative indexes!)
for (item in v) { // Supports iteration
    System.print("Item: %(item)") // Prints individual elements
}
```

::: tip
Note!

I highly recommend going through `wrenbind17/include/wrenbind17/std.hpp` to see how exactly this works.
:::

### 17.2. Custom lists

If you read through the [Iterator Protocol](http://wren.io/control-flow.html#the-iterator-protocol) section on official Wren documentation, then you need to implement at least 2 functions:

* `iterate(_)`
* `iteratorValue(_)`

Let's implement all of them for `std::vector<int>`! First we need the `iterate()` function. This function must accept already existing iterator or a null. To do this, we will use `std::variant` and an external function that will be bind to Wren via `funcExt`. 

```cpp
typedef typename std::vector<int>::iterator Iterator;
typedef typename std::vector<int> Vector;

static std::variant<bool, Iterator> iterate(
        Vector& self, // this
        std::variant<std::nullptr_t, Iterator> other
    ) {

    // Check if "other" variant is NOT nullptr
    if (other.index() == 1) {
        // Get the 2nd template, the iterator
        auto it = std::get<Iterator>(other);
        ++it;
        if (it != self.end()) {
            // Return the next position
            return {it};
        }

        // Once we reach the end, we must return false
        return {false};
    } else {
        // No iterator supplied, the variant is null,
        // then return the start of the vector
        return {self.begin()};
    }
}
```

Next, we need the `iteratorValue()` function. This one is very simple:

```cpp
static int iteratorValue(Vector& self, std::shared_ptr<Iterator> other) {
    // You could replace the shared_ptr with a simple copy value.
    // But that depends on you.
    auto& it = *other;
    return *it;
}
```

And then bind it!

```cpp
wren::VM vm;
auto& m = vm.module("std");
auto& cls = m.klass<Vector>("VectorInt");
cls.ctor<>();
cls.funcExt<&iterate>("iterate");
cls.funcExt<&iteratorValue>("iteratorValue");
```

That's all you need to implement your custom list and use it inside of a for loop!

### 17.3. Operator []

To get the operator [] working, you need two functions to set and to get the index.

```cpp
typedef typename std::vector<int>::iterator Iterator;
typedef typename std::vector<int> Vector;

static void setIndex(Vector& self, size_t index, int value) {
    self[index] = value;
}

static int getIndex(Vector& self, size_t index) {
    return self[index];
}
```

And then bind it!

```cpp
wren::VM vm;
auto& m = vm.module("std");
auto& cls = m.klass<Vector>("VectorInt");
cls.ctor<>();
cls.funcExt<&getIndex>(wren::OPERATOR_GET_INDEX);
cls.funcExt<&setIndex>(wren::OPERATOR_SET_INDEX);
```

The enum values you supply instead of function names will create special bindings for overloading operators. Wren will see the following:

```js
class VectorInt {
    ...
    foreign [index]         // Get
    foreign [index]=(other) // Set
}
```

## 18. Overload operators

TODO

## 19. Using std::variant

Using `std::variant` is nothing special. When you pass it into Wren, what happens is that this library will check what type is being held by the variant, and then it will push it into Wren. **The Wren will not get the variant instace, but the value it holds!** For example, passing `std::variant<bool, int>` will push either bool or int into Wren.

The same goes for getting values from Wren as variant. Suppose you have a C++ member function that accepts the variant of `std::variant<bool, int>` then when you call this member function in Wren as `foo.set(true)` or `foo.set(42)` it will work, but `foo.set("Hello")` won't work because the variant does not accepts the string!

## 20. Customize VM behavior

TODO
