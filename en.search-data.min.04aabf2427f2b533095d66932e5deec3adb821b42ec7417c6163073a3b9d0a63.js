'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/wrenbind17/menu/','title':"Menu",'section':"",'content':" Home Tutorial  1. Installation 2. Hello World 3. Call Wren function 4. Supported types 5. Executing from file 6. Custom types 7. Class operators 8. Modules and files 9. Customize VM 10. Fn.new and callbacks 11. STL containers   Api Documentation  Classes Namespaces Modules Files    "});index.add({'id':1,'href':'/wrenbind17/tutorial/install/','title':"1. Installation",'section':"Tutorial",'content':"1. Installation #  You don\u0026rsquo;t need to compile this library. This library is a header only library, all you have to do is to include the #include \u0026lt;wrenbind17/wrenbind17.hpp\u0026gt; header in your C++ project. However, you will need to compile and link the Wren VM, and adding an include path where the \u0026lt;wren.hpp\u0026gt; file is located. To see how to build and use the Wren library, see Getting Started section here from the official Wren documentation.\nOptionally, you can build Wren with WrenBind17 by setting a CMake flag WRENBIND17_BUILD_WREN to ON. To do this, simply clone this repository and build it in the following way:\ngit clone https://github.com/matusnovak/wrenbind17.git wrenbind17 cd wrenbind17 mkdir build cmake -B ./build -DWRENBIND17_BUILD_WREN=ON . cmake --build ./build 1.1. Usage with CMake #  You can use CMake to add WrenBind17 to your project via add_subdirectory. You will need to include WrenBind17 in your project locally (maybe a git submodule?) Include directories will be handled automatically by target_link_libraries.\ncmake_minimum_required(VERSION 3.14)project(Example)add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/libs/wrenbind17)add_executable(${PROJECT_NAME} main.cpp)target_link_libraries(${PROJECT_NAME} PUBLIC WrenBind17)set_target_properties(${PROJECT_NAME} PROPERTIES CXX_STANDARD 17 CXX_EXTENSIONS OFF) #c++17 Note\nYou will need to link Wren library too!\n 1.2. Build with Wren in CMake project #  If you wish to build Wren with WrenBind17 (as shown above with -DWRENBIND17_BUILD_WREN=ON added to the command line), you can do the following as shown below. Otherwise you will have to build Wren yourself and add it to your CMake project yourself. Setting WRENBIND17_BUILD_WREN to ON will add Wren CMake target which you can use in your own target. Include directories will be handled automatically by target_link_libraries.\ncmake_minimum_required(VERSION 3.14)project(Example)set(WRENBIND17_BUILD_WREN ON CACHE BOOL \u0026#34;\u0026#34; FORCE)add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/libs/wrenbind17) # Will add Wren target add_executable(${PROJECT_NAME} main.cpp)target_link_libraries(${PROJECT_NAME} PUBLIC WrenBind17 Wren)set_target_properties(${PROJECT_NAME} PROPERTIES CXX_STANDARD 17 CXX_EXTENSIONS OFF) #c++17 "});index.add({'id':2,'href':'/wrenbind17/tutorial/fn/','title':"10. Fn.new and callbacks",'section':"Tutorial",'content':"10. Fn.new and callbacks #  Let\u0026rsquo;s say you have a GUI button widget and you want to have a specific action when a user clicks on it.\nclass GuiButton { public: GuiButton(std::function\u0026lt;bool(int)\u0026gt; func) : func(std::move(func)) { } virtual ~GuiButton() { } bool event(int type) { return func(type); } private: std::function\u0026lt;bool(int)\u0026gt; func; }; And now you would like to create this class in Wren and add some custom Wren function as the callback. What you can do is to create a Wren specific wrapper and accept a class instance (in this case, Fn class instance from Wren).\nclass WrenGuiButton: public GuiButton { public: WrenGuiButton(wren::Variable fn) : GuiButton(std::bind(\u0026amp;WrenGuiButton::wrenEvent, this, std::placeholders::_1)) { callback = fn.func(\u0026#34;call(_)\u0026#34;); } private: bool wrenEvent(int type) { return callback(type).as\u0026lt;bool\u0026gt;(); } wren::Method callback; }; Or using lambdas:\nclass WrenGuiButton: public GuiButton { public: WrenGuiButton(wren::Variable fn) : GuiButton([this](int type) -\u0026gt; bool { return callback(type).as\u0026lt;bool\u0026gt;(); }) { callback = fn.func(\u0026#34;call(_)\u0026#34;); } private: wren::Method callback; }; Bind the class in the following way:\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;test\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;WrenGuiButton\u0026gt;(\u0026#34;GuiButton\u0026#34;); cls.ctor\u0026lt;wren::Variable\u0026gt;(); And finally the usage in Wren:\nimport \u0026#34;test\u0026#34; for GuiButton class Main { static main() { var btn = GuiButton.new(Fn.new { |arg| // \u0026#34;this\u0026#34; is going to be \u0026#34;Main\u0026#34; class  return true }) return btn } } This works because Wren\u0026rsquo;s Fn.new{} is actually an instance of a class, and executing the method is simple as calling call(...) of that instance.\n"});index.add({'id':3,'href':'/wrenbind17/tutorial/stl/','title':"11. STL Containers",'section':"Tutorial",'content':"11. STL Containers #  11.1. Optionals #  The std::optional\u0026lt;T\u0026gt; will be converted into a null or the type that it can hold. This also works when you call C++ function from Wren that accepts std::optional\u0026lt;T\u0026gt;. You can either call that function with null or with the type T.\n11.1.1. Limitations #  Passing std::optional via non-const reference is not allowed. Also passing as a pointer or a shared pointer does not work either. Only passing as a plain type (copy) or a const reference is allowed.\n11.2. Variants #  Using std::variant is nothing special. When you pass it into Wren, what happens is that this library will check what type is being held by the variant, and then it will pass it into the Wren code. The Wren will not get the variant instace, but the value it holds! For example, passing std::variant\u0026lt;bool, int\u0026gt; will push either bool or int into Wren.\nThe same goes for getting values from Wren as variant. Suppose you have a C++ member function that accepts the variant of std::variant\u0026lt;bool, int\u0026gt; then when you call this member function in Wren as foo.baz(true) or foo.baz(42) it will work, but foo.baz(\u0026quot;Hello\u0026quot;) won\u0026rsquo;t work because the variant does not accept the string!\nConsider the following example:\nclass Foo { public: Foo() { ... } void baz(const std::variant\u0026lt;bool, std::string\u0026gt;\u0026amp; value) { switch (value.index()) { case 0: { // Is bool!  const auto std::get\u0026lt;bool\u0026gt;(value); } case 1: { // Is string!  const auto std::get\u0026lt;std::string\u0026gt;(value); } default: { // This should never happen.  } } } } wren::VM vm = ...; auto\u0026amp; m = vm.module(...); auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); cls.func\u0026lt;\u0026amp;Foo::baz\u0026gt;(\u0026#34;baz\u0026#34;); // Nothing special, just like any other functions And the Wren code:\nimport \u0026#34;test\u0026#34; for Foo var foo = Foo.new() foo.baz(false) // ok foo.baz(\u0026#34;Hello World\u0026#34;) // ok foo.baz(123.456) // error 11.2.1. Limitations #  Passing std::variant via non-const reference is not allowed. The following code will not work. Also passing as a pointer or a shared pointer does not work either. Only passing as a plain type (copy) or a const reference is allowed.\nclass Foo { public: Foo() { ... } void baz(std::variant\u0026lt;bool, std::string\u0026gt;\u0026amp; value) { ... } } wren::VM vm = ...; auto\u0026amp; m = vm.module(...); auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); cls.func\u0026lt;\u0026amp;Foo::baz\u0026gt;(\u0026#34;baz\u0026#34;); // Will not work 11.3. Sequences #  WrenBind17 supports the following sequence containers: std::vector, std::list, std::deque, and std::set. By default all of them are converted into native Wren lists. This means that when you pass (or some C++ function returns) any of these containers, they are converted into Wren lists. Any modification to that list in Wren has no effect on the C++ container passed/returned. Wren lists are not the same object as the STL containers.\nHowever, you can add this container to Wren VM as a foreign class. In that case the instance of the C++ container you pass into Wren will become a foreign class, therefore modifying the \u0026ldquo;list\u0026rdquo; (a class in reality) will also modify the C++ container -\u0026gt; they are the same object.\nThis only works if you pass the container (or return from a C++ function) via a non-cost reference, pointer, or a shared pointer. Passing (or returning) via copy will create a copy of that C++ container. This check (whether to convert it to a native list or as a foreign class instance) happens at the runtime.\nConsider this following table.\n   Pass/return type Added as a foreign class Not added as a foreign class     Pass by a copy Copy of the container and pushed to Wren as a foreign class Converted to native list   Pass by a reference Pushed to Wren as a foreign class with no copy BadCast exception   Pass by a const reference Copy of the container and pushed to Wren as a foreign class Converted to native list   Pass by a (const) pointer Pushed to Wren as a foreign class with no copy BadCast exception   Pass by a shared pointer Pushed to Wren as a foreign class with no copy BadCast exception    11.3.1. Native lists #  By default all of std::vector, std::list, std::deque, and std::set are converted to Wren lists. This also works the other way around -\u0026gt; getting a list either by calling a C++ function that accepts a list or returning a list by calling a Wren function.\nFor example, you can return this native list into a std::vector of std::variant type.\nclass Main { static main() { return [null, 123, true, \u0026#34;Hello World\u0026#34;] } } wren::VM vm; vm.runFromSource(\u0026#34;main\u0026#34;, /* code from above */); auto func = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main()\u0026#34;); auto res = func(); assert(res.isList()); auto vec = res.as\u0026lt;std::vector\u0026lt;std::variant\u0026lt;std::nullptr_t, double, bool, std::string\u0026gt;\u0026gt;\u0026gt;(); assert(vec.size() == 4); assert(std::get\u0026lt;std::nullptr_t\u0026gt;(vec[0]) == nullptr); assert(std::get\u0026lt;double\u0026gt;(vec[1]) == 123.0); assert(std::get\u0026lt;bool\u0026gt;(vec[2]) == true); assert(std::get\u0026lt;std::string\u0026gt;(vec[3]) == \u0026#34;Hello World\u0026#34;); Note\nIn the above example we are getting std::vector\u0026lt;std::variant\u0026lt;...\u0026gt;\u0026gt;. If you add this type as a foreign class, the above example would run in the same way. This is because if you add this type as a foreign class, that only affects pushing that type to Wren. To not to use native lists, you will have to do something like this:\nlist = VectorOfVariant.new() list.push(null) list.push(123) list.push(true) list.push(\u0026#34;Hello World\u0026#34;) return list   11.3.2. Lists as foreign classes #  If you wish to add the container of some specific type as a foreign class, you can use the following method to do so:\nWren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;std\u0026#34;); wren::StdVectorBindings\u0026lt;int\u0026gt;::bind(m, \u0026#34;VectorInt\u0026#34;); The wren::StdVectorBindings is just a fancy wrapper that adds functions into the class. I highly recommend going through the wrenbind17/include/wrenbind17/std.hpp file to see how exactly this works.\nAnd the usage of that in Wren:\nimport \u0026#34;std\u0026#34; for VectorInt var v = VectorInt.new() v.add(42) // Push new value v.insert(-1, 20) // Insert at the end v.contains(42) // returns true v.pop() // Remove last element and returns it v.count // Returns the length/size v.size() // Same as the count v.clear() // Removes everything v.removeAt(-2) // Removes the 2nd element from back and returns it v[0] = 43 // Set specific index (negative indexes not supported!) System.print(\u0026#34;Second: %(v[1])\u0026#34;) // Get specific index (no negative indexes!) for (item in v) { // Supports iteration  System.print(\u0026#34;Item: %(item)\u0026#34;) // Prints individual elements } 11.3.3. Custom list from scratch #  If you read through the Iterator Protocol section on official Wren documentation, then you know that you need to implement at least 2 functions:\n iterate(_) iteratorValue(_)  Let\u0026rsquo;s implement all of them for std::vector\u0026lt;int\u0026gt;! First we need the iterate() function. This function must accept already existing iterator or a null. To do this, we will use std::variant and an external function that will be bind to Wren via funcExt.\ntypedef typename std::vector\u0026lt;int\u0026gt;::iterator Iterator; typedef typename std::vector\u0026lt;int\u0026gt; Vector; static std::variant\u0026lt;bool, Iterator\u0026gt; iterate( Vector\u0026amp; self, // this  std::variant\u0026lt;std::nullptr_t, Iterator\u0026gt; other ) { // Check if \u0026#34;other\u0026#34; variant is NOT nullptr  if (other.index() == 1) { // Get the 2nd template, the iterator  auto it = std::get\u0026lt;Iterator\u0026gt;(other); ++it; if (it != self.end()) { // Return the next position  return {it}; } // Once we reach the end, we must return false  return {false}; } else { // No iterator supplied, the variant is null,  // then return the start of the vector  return {self.begin()}; } } Next, we need the iteratorValue() function. This one is very simple:\nstatic int iteratorValue(Vector\u0026amp; self, std::shared_ptr\u0026lt;Iterator\u0026gt; other) { // You could replace the shared_ptr with a simple copy value.  // But that depends on you.  auto\u0026amp; it = *other; return *it; } And then bind it!\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;std\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;Vector\u0026gt;(\u0026#34;VectorInt\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.funcExt\u0026lt;\u0026amp;iterate\u0026gt;(\u0026#34;iterate\u0026#34;); cls.funcExt\u0026lt;\u0026amp;iteratorValue\u0026gt;(\u0026#34;iteratorValue\u0026#34;); That\u0026rsquo;s all you need to implement your custom list and use it inside of a for loop!\n11.3.4. Custom lists and operator [] #  To get the operator [] working, you need two functions to set and to get the index.\ntypedef typename std::vector\u0026lt;int\u0026gt;::iterator Iterator; typedef typename std::vector\u0026lt;int\u0026gt; Vector; static void setIndex(Vector\u0026amp; self, size_t index, int value) { self[index] = value; } static int getIndex(Vector\u0026amp; self, size_t index) { return self[index]; } And then bind it!\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;std\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;Vector\u0026gt;(\u0026#34;VectorInt\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.funcExt\u0026lt;\u0026amp;getIndex\u0026gt;(wren::OPERATOR_GET_INDEX); cls.funcExt\u0026lt;\u0026amp;setIndex\u0026gt;(wren::OPERATOR_SET_INDEX); The enum values you supply instead of function names will create special bindings for overloading operators. Wren will see the following:\n// Autogenerated class VectorInt { ... foreign [index] // Get  foreign [index]=(other) // Set } 11.4. Maps #  WrenBind17 supports the following key-value containers: std::map and std::unordered_map. By default all of them are converted into native Wren maps. This means that when you pass any of these containers, they are converted into Wren maps. Any modification to that map in Wren has no effect on the C++ container passed. Wren maps are not the same object as the STL containers.\nIt is not possible to convert a native Wren map into a C++ map. This is a limitation of the Wren language. However, you can use wren::Map that will hold a reference to the Wren native map. You can use this class to retrieve values, remove keys, check if key exists, or get the size of the map.  You can add the C++ map container to Wren VM as a foreign class. In that case the instance of the C++ container you pass into Wren will become a foreign class, therefore modifying the \u0026ldquo;map\u0026rdquo; (a class in reality) will also modify the C++ container -\u0026gt; they are the same object.\nThis only works if you pass the container via a non-cost reference, pointer, or a shared pointer. Passing (or returning) via copy will create a copy of that C++ container. This check (whether to convert it to a native map or as a foreign class instance) happens at the runtime.\nConsider this following table.\n   Pass/return type Added as a foreign class Not added as a foreign class     Pass by a copy Copy of the container and pushed to Wren as a foreign class Converted to native map   Pass by a reference Pushed to Wren as a foreign class with no copy BadCast exception   Pass by a const reference Copy of the container and pushed to Wren as a foreign class Converted to native map   Pass by a (const) pointer Pushed to Wren as a foreign class with no copy BadCast exception   Pass by a shared pointer Pushed to Wren as a foreign class with no copy BadCast exception    11.4.1. Native maps #  As mentioned above, it is not possible to get a native map from Wren and convert it into STL container. This is because the Wren low level API does not allow iterating over the map. Therefore, WrenBind17 provides wren::Map container that works on top of wren::Handle (it is a reference and affects the garbage collector).\nYou can use wren::Map to get values via key, remove keys, check if key exists, or get the size of the entire map. Example code below.\nclass Main { static main() { return { \u0026#34;first\u0026#34;: 42, \u0026#34;second\u0026#34;: true, \u0026#34;third\u0026#34;: \u0026#34;Hello World\u0026#34;, \u0026#34;fourth\u0026#34;: null } } static other(map) { // Do something with the map \t} } wren::VM vm; vm.runFromSource(\u0026#34;main\u0026#34;, code); auto func = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main()\u0026#34;); auto res = func(); res.is\u0026lt;wren::Map\u0026gt;(); // Returns true res.isMap(); // Returns true  auto map = res.as\u0026lt;wren::Map\u0026gt;(); map.count(); // Returns 4  map.contains(std::string(\u0026#34;first\u0026#34;)); // Returns true map.contains(std::string(\u0026#34;fifth\u0026#34;)); // Returns false  map.get\u0026lt;int\u0026gt;(std::string(\u0026#34;first\u0026#34;)); // Returns 42 map.get\u0026lt;bool\u0026gt;(std::string(\u0026#34;second\u0026#34;)); // Returns true map.get\u0026lt;std::string\u0026gt;(std::string(\u0026#34;third\u0026#34;)); // Returns \u0026#34;Hello World\u0026#34; map.get\u0026lt;std::nullptr_t\u0026gt;(std::string(\u0026#34;fourth\u0026#34;)); // Returns nullptr map.get\u0026lt;Foo\u0026gt;(std::string(\u0026#34;fourth\u0026#34;)); // Throws wren::BadCast  map.erase(std::string(\u0026#34;first\u0026#34;)); // Returns true map.erase(std::string(\u0026#34;fifth\u0026#34;)); // Returns false map.count(); // 3  map.get\u0026lt;int\u0026gt;(std::string(\u0026#34;first\u0026#34;)); // Throws wren::NotFound  auto other = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;other(_)\u0026#34;); other(map); // Pass the map to some other function 11.4.2. Maps as foreign classes #  If you wish to add the container of some specific type as a foreign class, you can use the following method to do so:\nWren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;std\u0026#34;); wren::StdUnorderedMapBindings\u0026lt;std::string, std::string\u0026gt;::bind(m, \u0026#34;MapOfStrings\u0026#34;); And the usage of that in Wren:\nimport \u0026#34;std\u0026#34; for MapOfStrings var map = MapOfStrings.new() // Set the value using [] operator map[\u0026#34;hello\u0026#34;] = \u0026#34;world\u0026#34; // Access the value var value = map[\u0026#34;hello\u0026#34;] // Exactly same as in std::map::operator[] // If the key does not exist, then it is created // using the default value. // So \u0026#34;value2\u0026#34; becomes empty string! var value2 = map[\u0026#34;nonexisting_key\u0026#34;] // Removes value by key and returns the value removed. // If the key does not exist, the returned value is null. var removed = map.remove(\u0026#34;hello\u0026#34;) // Check if the key exists if (map.containsKey(\u0026#34;hello\u0026#34;)) { System.print(\u0026#34;Key exists\u0026#34;) } // Clears the map, removing all elements. // Same as std::map::clear() map.clear() // Get the number of elements in the map. // Both the function size() and the property count do the same thing. var total = map.size() var total = map.count // Check if the map is empty if (map.empty()) { System.print(\u0026#34;There is nothing in the map!\u0026#34;) } // Iterate over the map. // The map has an iterator of std::map\u0026lt;K, T\u0026gt;::iterator which // returns std::pair\u0026lt;K, T\u0026gt; pairs. // So to access the key you have to use the key property of the pair. // And the same goes for the value. // This is exactly the same behavior as iterating over the map in C++ for (pair in map) { System.print(\u0026#34;Key: %(pair.key) value: %(pair.value)\u0026#34;) 11.4.3. Maps with variant value type #  Sometimes you need more than one type inside of the map, something like a Json. To do that, you can use the std::variant as the map mapped type. An example below.\ntypedef std::variant\u0026lt;int, bool, std::string, std::nullptr_t\u0026gt; Multitype; class FooClass { public: ... void useMap(std::unordered_map\u0026lt;std::string, Multitype\u0026gt;\u0026amp; map) { // Get the Multitype value by the key  auto\u0026amp; multitype = map[\u0026#34;string\u0026#34;] // Get std::string from the variant.  // Because std::string is the 3rd template argument  // of the std::variant Multitype, then we  // need to use std::get\u0026lt;index\u0026gt; to access the type!  auto\u0026amp; str = std::get\u0026lt;2\u0026gt;(multitype); } }; int main() { Wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;std\u0026#34;); wren::StdUnorderedMapBindings\u0026lt;std::string, Multitype\u0026gt;::bind(m, \u0026#34;MapOfMultitypes\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;FooClass\u0026gt;(\u0026#34;FooClass\u0026#34;); cls.func\u0026lt;\u0026amp;FooClass::useMap\u0026gt;(\u0026#34;useMap\u0026#34;); vm.runFromSource(...); return 0; } And the Wren code for the above map of variants:\nimport \u0026#34;std\u0026#34; for MapOfMultitypes, FooClass var map = MapOfMultitypes.new() map[\u0026#34;string\u0026#34;] = \u0026#34;world\u0026#34; map[\u0026#34;int\u0026#34;] = 123456 map[\u0026#34;null\u0026#34;] = null // Will become std::nullptr_t map[\u0026#34;boolean\u0026#34;] = true for (pair in map) { System.print(\u0026#34;Key: %(pair.key) value: %(pair.value)\u0026#34;) } // Pass the foo to some custom class var foo = FooClass.new() foo.useMap(map) 11.4.4. Custom maps #  To create a custom map you will need to implement the Iterator Protocol and the [] operator.\nLet\u0026rsquo;s start with the basics, create a wren VM and bind the map (with the key and value types defined!) to the Wren. You can\u0026rsquo;t create a generic map, Wren does not support that. If you want to have different map types with different key types or value types, you will need to do this multiple times. That\u0026rsquo;s what StdMapBindings\u0026lt;K, T\u0026gt; and StdUnorderedMapBindings\u0026lt;K, T\u0026gt; are designed for.\ntypedef std::unordered_map\u0026lt;std::string, int\u0026gt; MapOfInts; int main() { wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;MapOfInts\u0026gt;(\u0026#34;MapOfInts\u0026#34;); cls.ctor(); // Empty default constructor  // ...  return 0; } Now, the iterator and iterator value. This is based on the Wren requirements to implement a class that can be iterated. See Iterator Protocol for more information.\nstatic std::variant\u0026lt;bool, MapOfInts::iterator\u0026gt; iterate( MapOfInts\u0026amp; self, std::variant\u0026lt;std::nullptr_t, MapOfInts::iterator\u0026gt; other) { // If the variant holds \u0026#34;1\u0026#34; then the value being hold is a MapOfInts::iterator  if (other.index() == 1) { auto it = std::get\u0026lt;MapOfInts::iterator\u0026gt;(other); ++it; if (it != self.end()) { return {it}; } return {false}; } // Otherwise the variant holds \u0026#34;0\u0026#34; therfore a null  else { return {self.begin()}; } } // The \u0026#34;value_type\u0026#34; is the std::pair\u0026lt;K, T\u0026gt; of the MapOfInts static MapOfInts::value_type iteratorValue( MapOfInts\u0026amp; self, std::shared_ptr\u0026lt;MapOfInts::iterator\u0026gt; other) { // This simply returns the iterator value which is the std::pair  auto\u0026amp; it = *other; return *it; } You will also need these two functions to access the key and the value type of the pairs during iteration.\n// The \u0026#34;key_type\u0026#34; is the std::string and \u0026#34;mapped_type\u0026#34; is the int static const MapOfInts::key_type\u0026amp; pairKey(MapOfInts::value_type\u0026amp; pair) { return pair.first; } static const MapOfInts::mapped_type\u0026amp; pairValue(MapOfInts::value_type\u0026amp; pair) { return pair.second; } Furthemore accessing or setting the values by key using the operator [] can be done as the following:\nstatic void setIndex(MapOfInts\u0026amp; self, const MapOfInts::key_type\u0026amp; key, MapOfInts::mapped_type value) { self[key] = std::move(value); } static MapOfInts::mapped_type\u0026amp; getIndex(MapOfInts\u0026amp; self, const MapOfInts::key_type\u0026amp; key) { return self[key]; } You will have to then bind these functions above to the MapOfInts class.\ntypedef std::unordered_map\u0026lt;std::string, int\u0026gt; MapOfInts; int main() { wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;MapOfInts\u0026gt;(\u0026#34;MapOfInts\u0026#34;); cls.ctor(); // Empty default constructor  // These two functions must be named exactly like this, Wren requires these names.  cls.funcExt\u0026lt;\u0026amp;iterate\u0026gt;(\u0026#34;iterate\u0026#34;); cls.funcExt\u0026lt;\u0026amp;iteratorValue\u0026gt;(\u0026#34;iteratorValue\u0026#34;); // These two functions add the operator [] functionality.  cls.funcExt\u0026lt;\u0026amp;getIndex\u0026gt;(wren::ForeignMethodOperator::OPERATOR_GET_INDEX); cls.funcExt\u0026lt;\u0026amp;setIndex\u0026gt;(wren::ForeignMethodOperator::OPERATOR_SET_INDEX); // Bind the iterator of this map, without this  // you cannot pass the iterator between Wren and C++  auto\u0026amp; iter = m.klass\u0026lt;MapOfInts::iterator\u0026gt;(\u0026#34;MapOfIntsIter\u0026#34;); iter.ctor(); // Bind the pair of this map too. You need this  // so you can access the keys and values during iteration.  auto\u0026amp; pair = m.klass\u0026lt;MapOfInts::value_type\u0026gt;(\u0026#34;MapOfIntsPair\u0026#34;); pair.propReadonlyExt\u0026lt;\u0026amp;pairKey\u0026gt;(\u0026#34;key\u0026#34;); pair.propReadonlyExt\u0026lt;\u0026amp;pairValue\u0026gt;(\u0026#34;value\u0026#34;); return 0; } Sample Wren usage:\nimport \u0026#34;mymodule\u0026#34; for MapOfInts var map = MapOfInts.new() map[\u0026#34;first\u0026#34;] = 123 map[\u0026#34;second\u0026#34;] = 456 var second = map[\u0026#34;second\u0026#34;] for (pair in map) { System.print(\u0026#34;Key: %(pair.key) value: %(pair.value)\u0026#34;) } "});index.add({'id':4,'href':'/wrenbind17/tutorial/hello_world/','title':"2. Hello World",'section':"Tutorial",'content':"2. Hello World #  First, create a wren::VM instance, run the source code, find the method you want to run, and execute the method. In the example below, we are printing out a simple \u0026ldquo;Hello World\u0026rdquo; to the console. It is recommended that you create an alias from wrenbind17 to wren so you don\u0026rsquo;t have to type that many characters every time. I highly encourage you to NOT to use using namespace wrenbind17;!\nThis is the most simple hello world program. The only thing code does is to parse and run a Wren code (a simple print statement) from a simple string. This is not limited to only a single line of code, you can put in an entire contents of some Wren file.\nNote\nCalling wren::VM::runFromSource(std::string, std::string) will parse and run the code at the same time.\n #include \u0026lt;wrenbind17/wrenbind17.hpp\u0026gt;namespace wren = wrenbind17; // Alias  int main(int argc, char *argv[]) { const std::string code = \u0026#34;System.print(\\\u0026#34;Hello World!\\\u0026#34;)\u0026#34;; // Create new VM  wren::VM vm; // Runs the code from the std::string as a \u0026#34;main\u0026#34; module  vm.runFromSource(\u0026#34;main\u0026#34;, code); return 0; } "});index.add({'id':5,'href':'/wrenbind17/tutorial/call_wren/','title':"3. Call Wren function",'section':"Tutorial",'content':"3. Call Wren function #  3.1. Simple call #  To call a Wren function, you will have to first run the source code. Only then you can use wren::VM::find function to find the class defined in the Wren code. This will give you an object of wren::Variable which can be any Wren variable from the VM. In this case, it\u0026rsquo;s a class. Next, find the method you want to call via wren::Variable::func.\nYou will have to specify the exact signature of the method. In this case, the static main() has no parameters, therefore the signature is main(). If you have a method with multiple parameters, for example static main(a, b) { ... }, then the signature is the following: main(_,_). Use underscores to specify parameters (don\u0026rsquo;t use the parameter name). Whitespace is not allowed.\nWarning\nThe wren::VM::find throws an exception if the class (or a class instance) is not found in the module.\n int main(int argc, char *argv[]) { const std::string code = R\u0026#34;( class Main { static main() { System.print(\u0026#34;Hello World!\u0026#34;) } } )\u0026#34;; // Create new VM  wren::VM vm; // Runs the code from the std::string as a \u0026#34;main\u0026#34; module  // The System.print(\u0026#34;Hello World!\u0026#34;) will not be called  // because it is in a function  vm.runFromSource(\u0026#34;main\u0026#34;, code); // Find class Main in module main  wren::Variable mainClass = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;); // Find function main() in class Main  wren::Method main = mainClass.func(\u0026#34;main()\u0026#34;); // Execute the function  // Puts \u0026#34;Hello World!\u0026#34; into the stdout of your terminal.  // This calls the wren::Method::operator()(...) function.  main(); return 0; } 3.2. Call with arguments #  To call a Wren function that accepts arguments, simply look up the function using a signature that also matches the number of parameters of that function.\nSee 4. Supported types to see what types are supported when passing arguments into a Wren function.\nWarning\nIf you call a Wren function via the wren::Method::operator()(...) C++ function, and the number of arguments do not match the signature, it will throw an exception.\n int main(int argc, char *argv[]) { const std::string code = R\u0026#34;( class Main { static main(a, b) { x = a + b System.print(\u0026#34;The result is: %(x) \u0026#34;) } } )\u0026#34;; // Create new VM  wren::VM vm; // Runs the code from the std::string as a \u0026#34;main\u0026#34; module  // The System.print(\u0026#34;Hello World!\u0026#34;) will not be called  // because it is in a function  vm.runFromSource(\u0026#34;main\u0026#34;, code); // Find class Main in module main  wren::Variable mainClass = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;); // Find function main() in class Main  wren::Method main = mainClass.func(\u0026#34;main(_,_)\u0026#34;); // Execute the function  // Puts \u0026#34;The result is 25\u0026#34; into the stdout of your terminal.  // This calls the wren::Method::operator()(...) function.  main(10, 15); return 0; } 3.3. Return values #  Returning values is simply done via wren::Any which can hold any value that Wren can handle. The return value that is held by the wren::Any is not guaranteed to be a useable C++ variable. You can call the wren::Any::is\u0026lt;T\u0026gt;() function to check if the return value is some C++ type. Due to the design of Wren, the code below will cast the two integers 10 and 15 into doubles (float64) type, because that\u0026rsquo;s how Wren handles numbers (no real integers).\nThe result.is\u0026lt;int\u0026gt;() below will work because all doubles can be casted into integers, also the other way around. You will loose precision, if you return a double and get it as an integer. Only numeric types are casted between each other.\nYou can always extract the value from wren::Any as long as wren::VM is alive. Calling the .as\u0026lt;T\u0026gt;() function multiple times is allowed.\nSee 4. Supported types to see what types are supported when returning values from a Wren function.\nint main(int argc, char *argv[]) { const std::string code = R\u0026#34;( class Main { static main(a, b) { return a + b } } )\u0026#34;; // Create new VM  wren::VM vm; // Runs the code from the std::string as a \u0026#34;main\u0026#34; module  // The System.print(\u0026#34;Hello World!\u0026#34;) will not be called  // because it is in a function  vm.runFromSource(\u0026#34;main\u0026#34;, code); // Find class Main in module main  wren::Variable mainClass = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;); // Find function main() in class Main  wren::Method main = mainClass.func(\u0026#34;main(_,_)\u0026#34;); // Execute the function  // This calls the wren::Method::operator()(...) function.  wren::Any result = main(10, 15); assert(result.is\u0026lt;int\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;The result is: \u0026#34; \u0026lt;\u0026lt; result.as\u0026lt;int\u0026gt;() \u0026lt;\u0026lt; std::endl; return 0; } 3.4. Lifetime of return values #  The lifetime of the returned value is exteded by the wren::Any. You can extend the lifetime of the wren::Any beyond the lifetime of wren::VM.\nDue to the fact that the wren::Handle (used by wren::Any) is using a weak pointer to the VM, the wren::Any becomes empty once the wren::VM is destroyed. You can\u0026rsquo;t use it afterwards and any action will result in an exception of type wren::RuntimeException. This ensures that if you store wren::Any and can\u0026rsquo;t handle the lifetime (for example in a lambda capture) then you won\u0026rsquo;t get segmentation faults. It is handled for you automatically.\n3.5. Call non-static methods #  You can call non-static methods in classes. In all of the examples above, the class has a static main function, but this is not needed. You can do the following:\nclass Main { construct new() { } main(a, b) { return a + b } } var Instance = Main.new() // Find the class wren::Variable wrenClass = vm.find(\u0026#34;somemodule\u0026#34;, \u0026#34;Instance\u0026#34;); // Find the function with two arguments wren::Method wrenMethod = wrenClass.func(\u0026#34;main(_, _)\u0026#34;); Note\nThis only works if the instance variable name starts with a capital letter -\u0026gt; Instance.\n 3.6. Call with custom types #  You can call Wren function and pass custom C++ types into it. This only works if you have added (binding) your custom type into your Wren VM that you are calling the function in. See 4. Supported types to understand how that is done.\n3.6.1. Pass by a copy/reference #  This is the default behavior of passing class instances to Wren. As shown below, the class will be moved as a copy. Your class must be trivially copyable or a copy constructor defined. Passing anything into a function call will implicitly the use a reference, passing explicitly by a reference also creates a copy. Use a pointer if you do not want to create a copy. Or even better, use a shared pointer.\nFoo foo = Foo(\u0026#34;Hello World\u0026#34;); wren::Method main = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main(_)\u0026#34;); main(foo); 3.6.2. Pass by a move #  It is possible to pass it to Wren by a move as shown below. The instance will be moved into a new std::shared_ptr\u0026lt;Foo\u0026gt; handled by the Wren VM. This is possible only if your class has a move constructor.\nFoo foo = Foo(\u0026#34;Hello World\u0026#34;); wren::Method main = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main(_)\u0026#34;); main(std::move(foo)); 3.6.3. Pass by a pointer #  The instance will be moved into a new std::shared_ptr\u0026lt;Foo\u0026gt; handled by Wren but the deleter of that shared pointer is empty. Meaning, you will get the instance inside of Wren, but the lifetime of the instance is determinted solely by the C++. Make sure the instance you pass as a raw pointer lives longer than the Wren VM.\nFoo foo = Foo(\u0026#34;Hello World\u0026#34;); wren::Method main = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main(_)\u0026#34;); main(std::move(foo)); 3.6.4. Pass as a shared pointer #  This is the recommended method. You will not have any issues with the lifetime of the instance. You will also avoid accidental segmentation faults. Moving shared pointer has no different effect than passing shared pointer as a reference or a copy. It will act exactly the same. Doing this will also extend the lifetime of the Foo object held by the shared pointer.\nDeletion happens only when Wren garbace collects the instance and the same shared pointer is also no longer needed on C++ side.\nTL;DR: Nothing special, it is just a shared pointer.\nstd::shared_ptr\u0026lt;Foo\u0026gt; foo(new Foo(\u0026#34;Hello World\u0026#34;)); wren::Method main = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main(_)\u0026#34;); main(foo); 3.7. Return custom types from Wren #  Beware that returning C++ class instances from Wren contains same danger as returning instances from any other C++ function. Returning by a copy is safe, returning by a pointer or a reference is very dangerous, and finally returning by a shared pointer is the safest way to do it.\nwren::Method method = klass.func(\u0026#34;main()\u0026#34;); wren::Any result = method(); Foo result.as\u0026lt;Foo\u0026gt;(); // As a copy  Foo\u0026amp; result.as\u0026lt;Foo\u0026amp;\u0026gt;(); // As a reference Foo* result.as\u0026lt;Foo*\u0026gt;(); // As a pointer  std::shared_ptr\u0026lt;Foo\u0026gt; result.shared\u0026lt;Foo\u0026gt;(); // As a shared pointer The Wren language is garbage collected. Therefore once the variable is out of the scope, it may or may not be destroyed. It depends on the implementation of the language. But! The wren::Any will extend the lifetime of the object, so you can use the \u0026ldquo;pointer\u0026rdquo; (or a reference that .as\u0026lt;T*\u0026gt;() returns) as long as the result is alive. Once the wren::Any falls out of the scope, the pointer or a reference may be invalid because the instance may have been garbage collected.\n3.8. Catch Wren errors #  #include \u0026lt;wrenbind17/wrenbind17.hpp\u0026gt;namespace wren = wrenbind17; // Alias  int main(...) { wren::VM vm; ... try { wren::Method wrenMain = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main()\u0026#34;); wrenMain(); } catch (wren::NotFound\u0026amp; e) { // Thows only if class \u0026#34;Main\u0026#34; has not been found  std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (wren::RuntimeError\u0026amp; e) { // Throw when something went wrong when executing  // the function. For example: a variable does not  // exist, or bad method name.  std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } // If you are lazy, just do the following:  try { wren::Method wrenMain = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main()\u0026#34;); wrenMain(); } catch (wren::Exception\u0026amp; e) { // catch everything  std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } "});index.add({'id':6,'href':'/wrenbind17/tutorial/types/','title':"4. Supported types",'section':"Tutorial",'content':"4. Supported types #  4.1. List of supported types and conversion #  This is a list of supported types and how they are converted between C++ and Wren. Not everything can be mapped exactly (for example, integers are casted into doubles), so there are some compromises.\n   C++ type Wren type Return value from Any     signed char (int8_t) number (64-bit float) .as\u0026lt;int8_t\u0026gt;()   unsigned char (uint8_t) number (64-bit float) .as\u0026lt;uint8_t\u0026gt;()   signed short (int16_t) number (64-bit float) .as\u0026lt;int16_t\u0026gt;()   unsigned short (uint16_t) number (64-bit float) .as\u0026lt;uint16_t\u0026gt;()   signed int (int32_t) number (64-bit float) .as\u0026lt;int32_t\u0026gt;()   unsigned int (uint32_t) number (64-bit float) .as\u0026lt;uint32_t\u0026gt;()   signed long long (int64_t) number (64-bit float) .as\u0026lt;int64_t\u0026gt;()   unsigned long long (uint64_t) number (64-bit float) .as\u0026lt;uint64_t\u0026gt;()   float number (64-bit float) .as\u0026lt;float\u0026gt;()   double number (64-bit float) .as\u0026lt;double\u0026gt;()   char number (64-bit float) .as\u0026lt;char\u0026gt;()   char[N] string Not possible to get raw char array from Wren, use std::string   char* string Not possible to get raw char pointer from Wren, use std::string   std::string string .as\u0026lt;std::string\u0026gt;()   std::shared_ptr\u0026lt;T\u0026gt; T or null .as\u0026lt;T\u0026gt;() or .as\u0026lt;T*\u0026gt;() or .shared\u0026lt;T\u0026gt;()   T (custom types) foregin class of T .as\u0026lt;T\u0026gt;() (if copy is supported) or .as\u0026lt;T*\u0026gt;() or .as\u0026lt;T\u0026amp;\u0026gt;() or .shared\u0026lt;T\u0026gt;()    4.2. Unsupported types #     C++ type Reason     std::unique_ptr\u0026lt;T\u0026gt; How would it work if you want to get std::unique_ptr\u0026lt;T\u0026gt;\u0026amp; ? Not possible to implement.   std::queue\u0026lt;T\u0026gt; Can\u0026rsquo;t iterate over the elements without modifying the queue itself.    4.3. STL Containers #  The following std containers are supported and will be converted to a Wren type. Read the 11. STL containers section to understand more about STL containers and how to use them.\nWarning\nBy default the following STL containers below will be converted to a native type. If you add/bind any of these containers (except optional or variant) as a foregin class via vm.module(...).klass\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(\u0026quot;VectorInt\u0026quot;) then that type will no longer be treated as a native type. Only the type you have registered, for example std::vector\u0026lt;int\u0026gt; will be treated as such, other types of the same container, for example std::vector\u0026lt;float\u0026gt; will still be treated as a native list.\nWhether the STD container is converted a Wren native list/map or into a Wren foreign class is checked at runtime.\nRead the 11. STL containers section to understand how it works.\n    C++ type Wren type Return value from Any     std::variant\u0026lt;A, B, C\u0026gt; A or B or C .as\u0026lt;A or B or C\u0026gt;() or .as\u0026lt;std::variant\u0026lt;A, B, C\u0026gt;\u0026gt;()   std::optional\u0026lt;T\u0026gt; T or null .as\u0026lt;T\u0026gt;() (only if not null) or .as\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;()   std::vector\u0026lt;T\u0026gt; native list of T .as\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;()   std::list\u0026lt;T\u0026gt; native list of T .as\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt;()   std::deque\u0026lt;T\u0026gt; native list of T .as\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;()   std::set\u0026lt;T\u0026gt; native list of T .as\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;()   std::unordered_set\u0026lt;T\u0026gt; native list of T .as\u0026lt;std::unordered_set\u0026lt;T\u0026gt;\u0026gt;()   std::map\u0026lt;std::string, T\u0026gt; native map of T .as\u0026lt;std::map\u0026lt;std::string, T\u0026gt;\u0026gt;()   std::unordered_map \u0026lt;std::string, T\u0026gt; native map of T .as\u0026lt;std::unordered_map \u0026lt;std::string, T\u0026gt;\u0026gt;()    "});index.add({'id':7,'href':'/wrenbind17/tutorial/execute_code/','title':"5. Executing from file",'section':"Tutorial",'content':"5. Executing from file #  Executing Wren code can also be done in the following ways:\n// Same as above, specify the module name but instead // of the source code you tell it where the file is located. vm.runFromFile(\u0026#34;main\u0026#34;, \u0026#34;path/to/some/main.wren\u0026#34;); // Run specific module. This module must be an existing file \u0026#34;utils/libB.wren\u0026#34; // in one or more look-up paths specified during creation of wren::Vm vm(...); vm.runFromModule(\u0026#34;utils/libB\u0026#34;); Note\nThe runFromModule depends on the lookup paths you pass into the wren::VM constructor. The name of the module you want to run depends on these paths. Read the Modules tutorial first.\n "});index.add({'id':8,'href':'/wrenbind17/tutorial/custom_types/','title':"6. Custom types",'section':"Tutorial",'content':"6. Custom types #  Wren supports adding custom types. See official documentation here. This is done via foregin classes that can have member of static functions and fields. All of foreign classes added via WrenBind17 are wrapped in a custom wrapper (wren::detail::ForeignObject\u0026lt;T\u0026gt;) that takes care of handling of instance of your custom C++ type.\nIn order to use your custom types, you will have to register them as a foreign classes with foreign functions into the Wren VM. This is not done globally, therefore you will have to do this for each of your Wren VM instances. Wren VMs do not share their data between instances, nor the data about foreign classes.\n6.1. Type safety and shared_ptr #  All custom types are handled as a std::shared_ptr\u0026lt;T\u0026gt;. Even if you pass your custom type into Wren as a copy, it will be moved into a shared pointer. Passing shared pointers into Wren has no extra mechanism and simply the shared pointer is kept inside of the wrapper. This also ensures strong type safety. It is not possible to pass a C++ class instance of one type and get that variable back from Wren as a C++ class instance of an another type. Doing so will throw the wren::BadCast exception.\n6.2 Passing values into Wren #  Passing values into Wren can be done in multiple ways, but they always end up as a shared pointer. Passing values happens when you call a Wren function from C++ and you pass some arguments, or when Wren calls a C++ foreign function that returns a type.\nReturning a value from a C++ function or passing into a Wren function is done by the same mechanism, therefore there are no differences.\n Pass/return as a copy -\u0026gt; Moved into std::shared_ptr\u0026lt;T\u0026gt; Pass/return as a pointer -\u0026gt; Pointer moved into std::shared_ptr\u0026lt;T\u0026gt; with no deleter (won\u0026rsquo;t free). Pass/return as a reference -\u0026gt; Handled as a pointer and pointer moved into std::shared_ptr\u0026lt;T\u0026gt; with no deleter (won\u0026rsquo;t free). Pass/return as a const pointer -\u0026gt; Pointer moved into std::shared_ptr\u0026lt;T\u0026gt; with no deleter (won\u0026rsquo;t free). Pass/return as a const reference -\u0026gt; Handled as copy and the instance is copied (duplicated) via it\u0026rsquo;s copy constructor.  TL;DR: Everything is a shared pointer.\n6.3 Adding custom modules #  To bind a C++ class, you will first need to create a new module. Creating a new module is done per VM instance. If you have multiple VMs in your application, they won\u0026rsquo;t share the same modules. You would have to create the module for each of your VM instances. Copying modules between instances is not possible.\nnamespace wren = wrenbind17; // Alias  wren::VM vm; // Create module called \u0026#34;mymodule\u0026#34; wren::ForeignModule\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); You can create as many modules as you want. Additionally, calling the method module(...) multiple times with the same name won\u0026rsquo;t create duplicates. For example:\nwren::VM vm; wren::ForeignModule\u0026amp; m0 = vm.module(\u0026#34;mymodule\u0026#34;); wren::ForeignModule\u0026amp; m1 = vm.module(\u0026#34;mymodule\u0026#34;); // m0 and m1 now point to the exact same module Note\nModules must be used via a reference wren::ForeignModule\u0026amp; m = .... Copying modules is not allowed and causes compilation error.\n 6.3 Adding custom classes #  Once you have a custom module, you can add classes to it, any classes. Your class does not have to have any specific functions, there are no requirements. Your class does not have to have a default constructor too, you can add anything.\nLet\u0026rsquo;s assume this is your C++ class:\nclass Foo { public: Foo(const std::string\u0026amp; msg) { ... } void bar() { } int baz() const { } }; You can add it in the following way:\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor) cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods cls.func\u0026lt;\u0026amp;Foo::bar\u0026gt;(\u0026#34;bar\u0026#34;); cls.func\u0026lt;\u0026amp;Foo::baz\u0026gt;(\u0026#34;baz\u0026#34;); The class functions (methods) are added as a template argument, not as the function argument. This is due to the how Wren is built. Because of this implementation, you will also get extra performance -\u0026gt; the pointers to the class functions are optimized at compile time -\u0026gt; there are no lookup maps.\nAnd this is how you can use it:\nimport \u0026#34;mymodule\u0026#34; for Foo var foo = Foo.new(\u0026#34;Message\u0026#34;) foo.bar(); var i = foo.baz(); Please note that you don\u0026rsquo;t have to manually create file \u0026ldquo;mymodule.wren\u0026rdquo; and add all of your C++ foreign classes into it manually. Everything is automatically generated by the wren::VM. You can get the \u0026ldquo;raw\u0026rdquo; contents of the module that will be put into Wren by simply calling .str() on the module (e.g. vm.module(\u0026quot;mymodule\u0026quot;).str();). This will print the contents of that module as a Wren code with foreign classes.\n6.3.1 Handling function pointer ambiguity #  In case you have multiple functions with the same name, you will have to use static_cast to explicitly tell the compiler which function you want. For example:\nclass Foo { const std::string\u0026amp; getMsg() const; std::string\u0026amp; getMsg(); }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = vm.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); cls.func\u0026lt;static_cast\u0026lt;const std::string\u0026amp; (*)(void) const\u0026gt;(\u0026amp;Foo::getMsg)\u0026gt;(\u0026#34;getMsg\u0026#34;); 6.3.2 Static functions #  To add a static function, simply call the funcStatic instead of func as shown below:\nclass Log { static void debug(const std::string\u0026amp; text); static void error(const std::string\u0026amp; text); static void info(const std::string\u0026amp; text); }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;Log\u0026gt;(\u0026#34;Log\u0026#34;); cls.funcStatic\u0026lt;\u0026amp;Log::debug\u0026gt;(\u0026#34;debug\u0026#34;); cls.funcStatic\u0026lt;\u0026amp;Log::error\u0026gt;(\u0026#34;error\u0026#34;); cls.funcStatic\u0026lt;\u0026amp;Log::info\u0026gt;(\u0026#34;info\u0026#34;); 6.3.3 Function from base classes #  To add a function that belongs to the base class, simply use a pointer to the base class, example as shown below:\nclass Asset { public: std::string getName(); }; class AssetModel: public Asset { public: std::string getModelPath(); }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;AssetModel\u0026gt;(\u0026#34;AssetModel\u0026#34;); cls.func\u0026lt;\u0026amp;Asset::getName\u0026gt;(\u0026#34;getName\u0026#34;); cls.func\u0026lt;\u0026amp;AssetModel::getModelPath\u0026gt;(\u0026#34;getModelPath\u0026#34;); This works as long as Asset is a base class of AssetModel. This does not work with cls.funcExt\u0026lt;\u0026gt;(), in that case your external function first argument must be the derived class.\n6.3.4 Functions via external functions #  Suppose you have some C++ class that you want to add to Wren, but you can\u0026rsquo;t modify this class because it is from some other library. For example this C++ class can be from STL, or you want to add some custom behavior that does not exist in the class. In this case you can create a new function that accepts the class instance as the first parameter.\n// Custom member function with \u0026#34;self\u0026#34; as this pointer template\u0026lt;typename T\u0026gt; bool vectorContains(std::vector\u0026lt;T\u0026gt;\u0026amp; self, const T\u0026amp; value) { return std::find(self.begin(), self.end(), value) != self.end(); } // Custom static function without any \u0026#34;self\u0026#34; template\u0026lt;typename T\u0026gt; bool vectorFactory(const T\u0026amp; value) { std::vector\u0026lt;T\u0026gt; vec; vec.push_back(value); return vec; } auto\u0026amp; cls = m.klass\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(\u0026#34;VectorInt\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.funcExt\u0026lt;\u0026amp;vectorContains\u0026lt;int\u0026gt;\u0026gt;(\u0026#34;contains\u0026#34;); cls.funcStaticExt\u0026lt;\u0026amp;vectorFactory\u0026lt;int\u0026gt;\u0026gt;(\u0026#34;factory\u0026#34;); import \u0026#34;mymodule\u0026#34; for VectorInt var a = VectorInt.new() var b = VectorInt.factory(456) // Calls vectorFactory\u0026lt;T\u0026gt; a.contains(123) // returns bool \u0026ldquo;Ext\u0026rdquo; simply means that this is an external function and the first parameter must accept a reference to the class you are adding (unless it is a static function). Do not mistake this with \u0026ldquo;extern\u0026rdquo; C++ keyword. It has nothing to do with that. (Maybe there is a better word for it?)\nAdditionally, if you look at the vectorContains function from above, there is no \u0026ldquo;this\u0026rdquo; pointer because this is not a member function. Instead, the \u0026ldquo;this\u0026rdquo; is provided as a custom parameter in the first position. This also works with propExt and propReadonlyExt.\nExternal functions added as funcStaticExt will be treated as static functions and do not accept the first parameter as \u0026ldquo;this\u0026rdquo;.\n6.4 Abstract classes #  What if you want to pass an abstract class to Wren? You can\u0026rsquo;t allocate it, but you can only pass it around as a reference or a pointer? Imagine a specific derived \u0026ldquo;Entity\u0026rdquo; class that has a common abstract/interface class?\nThe only thing you have to do is to NOT to add constructor by not calling the ctor function.\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Entity\u0026gt;(\u0026#34;Entity\u0026#34;); // cls.ctor\u0026lt;\u0026gt;(); Do not add constructor! cls.func\u0026lt;\u0026amp;Entity::foo\u0026gt;(\u0026#34;foo\u0026#34;); 6.5 Adding class varialbles #  There are two ways how to add C++ class variables to Wren. One is as a simple field and the other way is as a property. Adding as a field is done by accessing the pointer to that field (which is just a relative offset to \u0026ldquo;this\u0026rdquo;). Adding as a property is done via getters and setters (the setters are optional). To Wren, there is no difference between those two and are treated equally.\n6.5.1 Class variables as fields #  struct Vec3 { float x = 0; float y = 0; float z = 0; }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.var\u0026lt;\u0026amp;Vec3::x\u0026gt;(\u0026#34;x\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::y\u0026gt;(\u0026#34;y\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::z\u0026gt;(\u0026#34;z\u0026#34;); 6.5.2 Class variables as properties #  class Vec3 { public: float getX() const { return x; } void setX(float value) { x = value; } float getY() const { return y; } void setY(float value) { y = value; } float getZ() const { return z; } void setZ(float value) { z = value; } private: float x = 0; float y = 0; float z = 0; }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.prop\u0026lt;\u0026amp;Vec3::getX, \u0026amp;Vec3::setX\u0026gt;(\u0026#34;x\u0026#34;); cls.prop\u0026lt;\u0026amp;Vec3::getY, \u0026amp;Vec3::setY\u0026gt;(\u0026#34;y\u0026#34;); cls.prop\u0026lt;\u0026amp;Vec3::getZ, \u0026amp;Vec3::setZ\u0026gt;(\u0026#34;z\u0026#34;); The result from above:\nEquivalent Wren code for both using .var\u0026lt;\u0026amp;field\u0026gt;(\u0026quot;name\u0026quot;) or .prop\u0026lt;\u0026amp;getter, \u0026amp;setter\u0026gt;(\u0026quot;name\u0026quot;):\n// Autogenerated foreign class Vec3 { construct new () {} foreign x foreign x=(rhs) foreign y foreign y=(rhs) foreign z foreign z=(rhs) } And then simply use it in Wren as:\nimport \u0026#34;mymodule\u0026#34; for Vec3 var v = Vec3.new() v.x = 1.23 v.y = 0.0 v.z = 42.42 6.5.3 Read-only class variables #  To bind read-only variables you can use varReadonly function. This won\u0026rsquo;t define a Wren setter and therefore the variable can be only read.\nclass Vec3 { public: Vec3(float x, float y, float z) {...} const float x; const float y; const float z; }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.varReadonly\u0026lt;\u0026amp;Vec3::x\u0026gt;(\u0026#34;x\u0026#34;); cls.varReadonly\u0026lt;\u0026amp;Vec3::y\u0026gt;(\u0026#34;y\u0026#34;); cls.varReadonly\u0026lt;\u0026amp;Vec3::z\u0026gt;(\u0026#34;z\u0026#34;); Equivalent Wren code:\n// Autogenerated foreign class Vec3 { construct new () {} foreign x foreign y foreign z } And then simply use it in Wren as:\nimport \u0026#34;mymodule\u0026#34; for Vec3 var v = Vec3.new(1.1, 2.3, 3.3) System.print(\u0026#34;X value is: %(v.x)\u0026#34;) // ok v.x = 1.23 // error For read-only properties, you can use propReadonly as shown below:\n// Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.propReadonly\u0026lt;\u0026amp;Vec3::getX\u0026gt;(\u0026#34;x\u0026#34;); cls.propReadonly\u0026lt;\u0026amp;Vec3::getY\u0026gt;(\u0026#34;y\u0026#34;); cls.propReadonly\u0026lt;\u0026amp;Vec3::getZ\u0026gt;(\u0026#34;z\u0026#34;); 6.5.4 Class variables via external properties #  Sometimes the property simply does not exist in the C++ class you want to use. So, you somehow need to add this into Wren without changing the original class code. One way to do it is through \u0026ldquo;external\u0026rdquo; functions. This is simply a function that is static and must accept the first parameter as a reference to the class instance.\nstatic float getVec3X(Vec3\u0026amp; self) { return self.x; } static float getVec3Y(Vec3\u0026amp; self) { ... } static float getVec3Z(Vec3\u0026amp; self) { ... } // Add class \u0026#34;Vec3\u0026#34; auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;\u0026gt;(); cls.propExtReadonly\u0026lt;\u0026amp;getVec3X\u0026gt;(\u0026#34;x\u0026#34;); cls.propExtReadonly\u0026lt;\u0026amp;getVec3Y\u0026gt;(\u0026#34;y\u0026#34;); cls.propExtReadonly\u0026lt;\u0026amp;getVec3Z\u0026gt;(\u0026#34;z\u0026#34;); 6.5.5 Class variables from base class #  You can bind class variables that belong to the base class, example below:\nstruct Message { uint64_t id = 0; }; struct MessageText : Message { std::string text; }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;MessageText\u0026gt;(); cls.ctor\u0026lt;\u0026gt;(); cls.var\u0026lt;\u0026amp;Message::id\u0026gt;(\u0026#34;id\u0026#34;); cls.var\u0026lt;\u0026amp;MessageText::id\u0026gt;(\u0026#34;text\u0026#34;); You do not need to bind the base class in order to use its fields in the derived class. This also works with properties cls.prop\u0026lt;\u0026gt;() and cls.propReadonly\u0026lt;\u0026gt;() but does not work with cls.propExt\u0026lt;\u0026gt;() and cls.propReadonlyExt\u0026lt;\u0026gt;(). You can then access both base class and derived class variables in Wren:\nimport \u0026#34;mymodule\u0026#34; for MessageText var msg = MessageText.new() msg.id = 123 msg.text = \u0026#34;Hello World\u0026#34; 6.5.6 Class static variables #  Static variables in Wren are not supported. However, you could cheat a bit with the following code:\nclass ApplicationGlobals { public: std::string APP_NAME = \u0026#34;Lorem Ipsum Donor\u0026#34;; }; int main() { ... wren::VM vm(...); auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;ApplicationGlobals\u0026gt;(\u0026#34;ApplicationGlobals\u0026#34;); cls.var\u0026lt;\u0026amp;ApplicationGlobals::APP_NAME\u0026gt;(\u0026#34;APP_NAME\u0026#34;); m.append(\u0026#34;var Globals = ApplicationGlobals.new()\\n\u0026#34;); return 0; } Wren code:\nimport \u0026#34;mymodule\u0026#34; for Globals print(\u0026#34;Name: %(Globals.APP_NAME)\u0026#34;) What does m.append do? It allows you to add arbitraty Wren code into the auto generated Wren code from your C++ classes. Anything you will put into the append function will appear at the bottom of the autogenerated code. Calling the append function multiple times is allowed, it will not override previous append call. In this case above, the ApplicationGlobals is created as an instance named Globals. So, from the user\u0026rsquo;s perspective in the Wren code, it appears as a static member variable. The name must start with a capital letter, otherwise Wren will not allow you to import that variable.\n6.6. Upcasting #  Upcasting is when you have a derived class Enemy and you would like to upcast it to Entity. An Enemy class is an Entity, but not the other way around. Remember, upcasting is getting the base class!\nThis might be a problem when, for example, you have created a derived class inside of the Wren and you are passing it into some C++ function that accepts the base class. What you have to do is to tell the Wren what base classes it can be upcasted to. Consider the following example:\nclass Entity { void update(); }; class Enemy: public Entity { ... }; class EntityManager { void add(std::shared_ptr\u0026lt;Entity\u0026gt; entity) { entities.push_back(entity); } }; Wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;game\u0026#34;); // Class Entity auto\u0026amp; entityCls = m.klass\u0026lt;Entity\u0026gt;(\u0026#34;Entity\u0026#34;); entityCls.func\u0026lt;\u0026amp;Entity::update\u0026gt;(\u0026#34;update\u0026#34;); // Class Enemy auto\u0026amp; enemyCls = m.klass\u0026lt;Enemy, Entity\u0026gt;(\u0026#34;Enemy\u0026#34;); // Classes won\u0026#39;t automatically inherit functions and properties // therefore you will have to explicitly add them for each // derived class! enemyCls.func\u0026lt;\u0026amp;Enemy::update\u0026gt;(\u0026#34;update\u0026#34;); // Class EntityManager auto\u0026amp; mngClass =m.klass\u0026lt;EntityManager\u0026gt;(\u0026#34;EntityManager\u0026#34;); mngClass.func\u0026lt;\u0026amp;EntityManager::add\u0026gt;(\u0026#34;add\u0026#34;); Notice how we are adding two classes here as template parameters (m.klass\u0026lt;Enemy, Entity\u0026gt;). The first template parameter is the class you are binding, the second (and the next after that) template parameters are the classes for upcasting. You can use multiple classes as the base classes (m.klass\u0026lt;Enemy, Entity, Object\u0026gt;), but that is only recommended if you know what you are doing. Make sure that you will also bind any inherited member functions to the derived class because this is not done automatically.\nAnd the Wren code:\nimport \u0026#34;game\u0026#34; for EntityManager, Enemy var manager = ... var e = Enemy.new() e.update() manager.add(e) // ok Note\nUpcasting such as this only works when you want to accept a reference, pointer, or a shared_ptr of the base class. This won\u0026rsquo;t work with plain value types.\n 6.7. Class methods that throw #  You can catch the exception (and the exception message) inside of your Wren code. Consider the following C++ class that throws:\nclass MyCppClass { public: ... void someMethod() { throw std::runtime_error(\u0026#34;hello\u0026#34;); } }; And this is how you catch that exception in Wren:\nvar fiber = Fiber.new { var i = MyCppClass.new() i.someMethod() // C++ throws \u0026#34;hello\u0026#34; } var error = fiber.try() System.print(\u0026#34;Caught error: \u0026#34; + error) // Prints \u0026#34;Caught error: hello\u0026#34; 6.8. Inheritance #  Wren does not support inheritacne of foreign classes, but there is a workaround. Consider the following C++ class:\nclass Entity { public: Entity() { ... } virtual ~Entity() { ... } virtual void update() = 0; }; Now we want to have our own class in Wren:\nimport \u0026#34;game\u0026#34; for Entity class Enemy is Entity { // Not allowed by Wren :(  construct new (...) { } update() { // Do something specific for Entity class  } } This does not work. You can\u0026rsquo;t inherit from a foreign class. But, don\u0026rsquo;t lose hope yet, there is a workaround. First, we need to create a C++ derived class of the base abstract class that overrides the update method. This is necessary so that we can call the proper Wren functions.\nclass WrenEntity: public Entity { public: // Pass the Wren class to the constructor  WrenEntity(wren::Variable derived) { // Find all of the methods you want to \u0026#34;override\u0026#34;  // The number of arguments (_) or (_, _) does matter!  updateFn = derived.func(\u0026#34;update(_)\u0026#34;); } virtual ~WrenEntity() { } void update() override { // Call the overriden Wren methods from  // the Wren class whenever you need to.  // Pass this class as the base class  updateFn(this); } private: // Store the Wren methods as class fields  wren::Method updateFn; }; wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;game\u0026#34;); auto\u0026amp; cls = m.klass\u0026lt;WrenEntity\u0026gt;(\u0026#34;Entity\u0026#34;); cls.ctor\u0026lt;wren::Variable\u0026gt;(); vm.runFromSource(\u0026#34;main\u0026#34;, ...); // Call the main function (see Wren code below) auto res = vm.find(\u0026#34;main\u0026#34;, \u0026#34;Main\u0026#34;).func(\u0026#34;main()\u0026#34;); // Get the instance with Wren\u0026#39;s specific functions std::shared_ptr\u0026lt;WrenEntity\u0026gt; enemy = res.shared\u0026lt;WrenEntity\u0026gt;(); And the following Wren code to be used with the code above:\nimport \u0026#34;game\u0026#34; for Entity class Enemy { update (self) { // self points to the base class!  } } class Main { static main () { // Pass our custom Enemy class  // to the base Entity class into the constructor.  // The base class will call the necessary functions.  return Entity.new(Enemy.new()) } } "});index.add({'id':9,'href':'/wrenbind17/tutorial/operators/','title':"7. Class operators",'section':"Tutorial",'content':"7. Class operators #  Operators can be added to your custom types, this is done via the wren::ForeignMethodOperator enumeration.\nThis is a list of all supported operators by WrenBind17:\n   Operator Enum Value     Add (+) OPERATOR_ADD   Subtract (-) OPERATOR_SUB   Multiply (*) OPERATOR_MUL   Divide (/) OPERATOR_DIV   Unary negative (-) OPERATOR_NEG   Modulo (%) OPERATOR_MOD   Equal to (==) OPERATOR_EQUAL   Not equal to (!=) OPERATOR_NOT_EQUAL   Greater than (\u0026gt;) OPERATOR_GT   Less than (\u0026lt;) OPERATOR_LT   Greather than or equal (\u0026gt;=) OPERATOR_GT_EQUAL   Less than or equal (\u0026lt;=) OPERATOR_LT_EQUAL   Shift left (\u0026laquo;) OPERATOR_SHIFT_LEFT   Shift right (\u0026raquo;) OPERATOR_SHIFT_RIGHT   Binary and (\u0026amp;) OPERATOR_AND   Binary xor (^) OPERATOR_XOR   Binary or (|) OPERATOR_OR   Get by index [] OPERATOR_GET_INDEX   Set by index [] OPERATOR_SET_INDEX    7.1. Basic usage #  Adding arithemtic or comparison operators can be done in the following way.\nclass Vec3 { public: Vec3(float x, float y, float z) : x(x), y(y), z(z) { } Vec3 operator - () const { // Unary negation operator  ... } Vec3 operator + (const Vec3\u0026amp; other) const { ... } Vec3 operator - (const Vec3\u0026amp; other) const { ... } Vec3 operator * (const Vec3\u0026amp; other) const { ... } Vec3 operator / (const Vec3\u0026amp; other) const { ... } bool operator == (const Vec3\u0026amp; other) const { ... } bool operator != (const Vec3\u0026amp; other) const { ... } float x; float y; float z; }; int main(...) { wren::VM vm; ... // If you don\u0026#39;t do this, the compiler will have no idea  // which operator to use when binding OPERATOR_SUB and OPERATOR_NEG.  // With this and static_cast you will explicitly tell the compiler  // which exact function to use.  typedef Vec3 (Vec3::*Vec3Sub)(const Vec3\u0026amp;) const; typedef Vec3 (Vec3::*Vec3Neg)() const; // Bind the class and some basic functions/vars  auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;float, float, float\u0026gt;(); // Constructor  cls.var\u0026lt;\u0026amp;Vec3::x\u0026gt;(\u0026#34;x\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::y\u0026gt;(\u0026#34;y\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::z\u0026gt;(\u0026#34;z\u0026#34;); // Bind the operators  cls.func\u0026lt;\u0026amp;Vec3::operator+ \u0026gt;(wren::OPERATOR_ADD); cls.func\u0026lt;static_cast\u0026lt;Vec3Sub\u0026gt;(\u0026amp;Vec3::operator-)\u0026gt;(wren::OPERATOR_SUB); cls.func\u0026lt;static_cast\u0026lt;Vec3Neg\u0026gt;(\u0026amp;Vec3::operator-)\u0026gt;(wren::OPERATOR_NEG); cls.func\u0026lt;\u0026amp;Vec3::operator* \u0026gt;(wren::OPERATOR_MUL); cls.func\u0026lt;\u0026amp;Vec3::operator/ \u0026gt;(wren::OPERATOR_DIV); cls.func\u0026lt;\u0026amp;Vec3::operator== \u0026gt;(wren::OPERATOR_EQUAL); cls.func\u0026lt;\u0026amp;Vec3::operator!= \u0026gt;(wren::OPERATOR_NOT_EQUAL); } Afterwards you can use it in the following way:\nimport \u0026#34;test\u0026#34; for Vec3 var a = Vec3.new(1.0, 2.0, 3.0) var b = Vec3.new(4.0, 5.0, 6.0) var c = a + b Note\nIf you are using Visual Studio and trying to bind operator \u0026lt; then you might get an error: error C2833: 'operator \u0026gt;' is not a recognized operator or type. This happens because the compiler is unable to understand cls.func\u0026lt;\u0026amp;Vec3::operator\u0026gt;\u0026gt;(wren::OPERATOR_GT). Simply, put ( ) around the operator like this: cls.func\u0026lt;(\u0026amp;Vec3::operator\u0026gt;)\u0026gt;(...).\n Note\nUsing *=, -=, +=, or /= is not allowed. Wren does not support these assignment operators and results in Wren compilation error.\n 7.2. Operator with multiple types #  Consider the following C++ class:\nclass Vec3 { public: Vec3 operator * (const Vec3\u0026amp; other) const { ... } Vec3 operator * (const float value) const { ... } }; You have two operators but the second one only accepts a single value. This can be useful when you want to, for example, multiply a 3D vector with a constant value. This can be a problem when binding these two operators to Wren. You can\u0026rsquo;t bind them both, but you can use std::variant\u0026lt;\u0026gt; instead.\nCreate a new function in the following way:\nVec3 operator * (const std::variant\u0026lt;Vec3, float\u0026gt;\u0026amp; var) const { if (var.index() == 0) { Vec3 other = std::get\u0026lt;Vec3\u0026gt;(var); // Multiply by other vector  } else { float other = std::get\u0026lt;float\u0026gt;(var); // Multiply by constant value  } } int main(...) { wren::VM vm; ... auto\u0026amp; cls = m.klass\u0026lt;Vec3\u0026gt;(\u0026#34;Vec3\u0026#34;); cls.ctor\u0026lt;float, float, float\u0026gt;(); cls.var\u0026lt;\u0026amp;Vec3::x\u0026gt;(\u0026#34;x\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::y\u0026gt;(\u0026#34;y\u0026#34;); cls.var\u0026lt;\u0026amp;Vec3::z\u0026gt;(\u0026#34;z\u0026#34;); // Optional typedef to explicitly select the correct  // operator with the std::variant  typedef Vec3 (Vec3::*Vec3Mul)(const std::variant\u0026lt;Vec3, float\u0026gt;\u0026amp;) const; // Bind the function  cls.func\u0026lt;static_cast\u0026lt;Vec3Mul\u0026gt;(\u0026amp;Vec3::operator*)\u0026gt;(wren::OPERATOR_MUL); } Then, insie of Wren, you can do the following:\nimport \u0026#34;test\u0026#34; for Vec3 var a = Vec3.new(1.0, 2.0, 3.0) var b = Vec3.new(4.0, 5.0, 6.0) // Multiply by the other vector var c = a + b // Or multiply by a constant value var c = a * 1.5 "});index.add({'id':10,'href':'/wrenbind17/tutorial/modules/','title':"8. Modules and files",'section':"Tutorial",'content':"8. Modules and files #  Wren support modularity (official documentation here), but does not exactly work out of the box. WrenBind17 fills this gap by adding a file load function that works using a list of look-up paths.\nIf you are familiar with Python, this is almost the same as the Python home path for loading modules.\nstd::vector\u0026lt;std::string\u0026gt; paths = { \u0026#34;some/relative/path\u0026#34;, \u0026#34;C:/absolute/path\u0026#34; }; wren::VM vm(paths); It is highly advised to use absolute paths. You can use relative paths, but they will depend on your current working directory. The default value of the VM constructor is {\u0026quot;./\u0026quot;}. This means that by default the VM will look for files relative to your working directory. If there is a file named ./libs/mylib.wren in your working directory, then you can import that file as import \u0026quot;libs/mylib\u0026quot; for XYZ.\n8.1. Detailed explanation #  Consider the following program file structure:\nmyprogram/\rapp.exe\rdata/\rmain.wren\rlibA.wren\rutils/\rlibB.wren\rYou have three files: data/main.wren, data/libA.wren, and data/utils/libB.wren. Now, inside of your main, you might have something like this:\n// File: data/main.wren  import \u0026#34;libA\u0026#34; for XYZ This won\u0026rsquo;t work by default. Because of the default argument for the wren::VM constructor is {\u0026quot;./\u0026quot;}, the libA is being looked for inside of myprogram/./\u0026lt;import name\u0026gt;.wren (assuming the current working directory is myprogram/). What you should do is to construct Wren::VM in the following way:\nstd::vector\u0026lt;std::string\u0026gt; paths = { \u0026#34;C:/programs/myprogram/data\u0026#34; }; wren::VM vm(paths); Only then the import \u0026quot;libA\u0026quot; for XYZ will work correctly.\nWarning\nRelative imports do not work due to the design of the Wren! You will have to use absolute paths. So, how do you import myprogram/data/utils/libB.wren in myprogram/data/libA.wren? You simply use import \u0026quot;utils/libB\u0026quot; for XYZ in that file.\n 8.1.1 Import ambiguity #  If you have two Wren source code files named exactly the same, but in two different lookup paths, only the first file will be loaded. The std::vector\u0026lt;std::string\u0026gt; of paths you use as the first argument of wren::VM constructor is an ordered list of paths. The files are looked for in the order you define it.\n8.1.2. Module names for custom types #  Any module name is permitted as long as it can be a valid Wren string. Slashes such as import \u0026quot;lib/utils/extras\u0026quot; for tokenize is allowed, simply create a module as auto\u0026amp; m = vm.module(\u0026quot;lib/utils/extras\u0026quot;);.\n8.2. Custom import mechanism #  You can use your own custom mechanism for handling the imports. This is done by defining your own function of the following type:\ntypedef std::function\u0026lt;std::string( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name )\u0026gt; LoadFileFn; And using it as this:\nint main(...) { wren::VM vm({\u0026#34;./\u0026#34;}); const myLoader = []( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name) -\u0026gt; std::string { // \u0026#34;paths\u0026#34; - This list comes from the  // first argument of the wren::VM constructor.  //  // \u0026#34;name\u0026#34; - The name of the import.  // Return the source code in this function or throw an exception.  // For example you can throw wren::NotFound();  return \u0026#34;\u0026#34;; }; vm.setLoadFileFunc(myLoader); } Warning\nChanging the loader function will also modify the wren::VM::runFromModule function. That function depends on the loader. The argument you pass into the runFromModule will become the name parameter in the loader.\n 8.3. Raw modules #  You can create any number of modules. For example:\nwren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); m.append(R\u0026#34;( class Vec3 { construct new (x, y, z) { _x = x _y = y _z = z } } )\u0026#34;); Then the module can be used as:\nimport \u0026#34;mymodule\u0026#34; for Vec3 "});index.add({'id':11,'href':'/wrenbind17/tutorial/customize/','title':"9. Customize VM",'section':"Tutorial",'content':"9. Customize VM #  9.1. Min heap and growth #  To control the minimal heap, heap growth, and initial heap, use the constructor to do so. Example:\n#include \u0026lt;wrenbind17/wrenbind17.hpp\u0026gt;namespace wren = wrenbind17; // Alias  int main(...) { // These values are default.  // If you leave the constructor empty, these exact  // values will be used.  // The lookup paths for loading other Wren files  std::vector\u0026lt;std::string\u0026gt; paths = {\u0026#34;./\u0026#34;}; // The initial heap that will be created on init  const size_t initHeap = 1024 * 1024; // 1MB  // The minimal heap to shrink to  const size_t minHeap = 1024 * 1024 * 10; // 10MB  // The growth size  const int heapGrowth = 50; // 50%  // Constructor  wren::VM vm(paths, initHeap, minHeap, heapGrowth); } 9.2. Print function #  The print function is defined as:\ntypedef std::function\u0026lt;void(const char*)\u0026gt; PrintFn; and can be set as:\n#include \u0026lt;wrenbind17/wrenbind17.hpp\u0026gt;namespace wren = wrenbind17; // Alias  int main(...) { wren::VM vm(...); vm.setPrintFunc([](const char* str) { std::cout \u0026lt;\u0026lt; str; }); } 9.3. File loader function #  You can use your own custom mechanism for handling the imports. This is done by defining your own function of the following type:\ntypedef std::function\u0026lt;std::string( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name )\u0026gt; LoadFileFn; And using it as this:\nint main(...) { wren::VM vm({\u0026#34;./\u0026#34;}); const myLoader = []( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name) -\u0026gt; std::string { // \u0026#34;paths\u0026#34; - This list comes from the  // first argument of the wren::VM constructor.  //  // \u0026#34;name\u0026#34; - The name of the import.  // Return the source code in this function or throw an exception.  // For example you can throw wren::NotFound();  return \u0026#34;\u0026#34;; }; vm.setLoadFileFunc(myLoader); } Warning\nChanging the loader function will also modify the wren::VM::runFromModule function. That function depends on the loader. The argument you pass into the runFromModule will become the name parameter in the loader.\n "});index.add({'id':12,'href':'/wrenbind17/classes/','title':"Classes",'section':"",'content':"Classes #   namespace std namespace wrenbind17  class AbstractMapBindings class BadCast class CompileError class Exception class ForeignKlass A foreign class. class ForeignKlassImpl class ForeignMethod Holds information about a foreign function of a foreign class. class ForeignMethodImpl Type specific implementation of foreign method. class ForeignModule class ForeignProp Holds information about a foreign property of a foreign class. class ForeignPropImpl class Handle Holds a reference to some Wren type. class Map Holds native Wren map. class Method class NotFound class ReturnValue A return value when calling a Wren function (alias Any) class RuntimeError class StdListBindings class StdVectorBindings class VM Holds the entire Wren VM from which all of the magic happens.  class Data   class Variable Holds some Wren variable which can be a class or class instance.     Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':13,'href':'/wrenbind17/files/','title':"Files",'section':"",'content':"Files #   dir include  dir include/wrenbind17  file include/wrenbind17/allocator.hpp file include/wrenbind17/any.hpp file include/wrenbind17/caller.hpp file include/wrenbind17/exception.hpp file include/wrenbind17/foreign.hpp file include/wrenbind17/handle.hpp file include/wrenbind17/index.hpp file include/wrenbind17/map.hpp file include/wrenbind17/method.hpp file include/wrenbind17/module.hpp file include/wrenbind17/object.hpp file include/wrenbind17/pop.hpp file include/wrenbind17/push.hpp file include/wrenbind17/std.hpp file include/wrenbind17/stddeque.hpp file include/wrenbind17/stdlist.hpp file include/wrenbind17/stdmap.hpp file include/wrenbind17/stdoptional.hpp file include/wrenbind17/stdset.hpp file include/wrenbind17/stdvariant.hpp file include/wrenbind17/stdvector.hpp file include/wrenbind17/variable.hpp file include/wrenbind17/vm.hpp file include/wrenbind17/wrenbind17.hpp       Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':14,'href':'/wrenbind17/files/dir_d44c64559bbebec7f509842c48db8b23/','title':"include",'section':"Files",'content':"include #  Directories #     Name     include/wrenbind17     Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':15,'href':'/wrenbind17/files/dir_0603dac12b22d4faefe24b335e5b06be/','title':"include/wrenbind17",'section':"Files",'content':"include/wrenbind17 #  Files #     Name     include/wrenbind17/allocator.hpp   include/wrenbind17/any.hpp   include/wrenbind17/caller.hpp   include/wrenbind17/exception.hpp   include/wrenbind17/foreign.hpp   include/wrenbind17/handle.hpp   include/wrenbind17/index.hpp   include/wrenbind17/map.hpp   include/wrenbind17/method.hpp   include/wrenbind17/module.hpp   include/wrenbind17/object.hpp   include/wrenbind17/pop.hpp   include/wrenbind17/push.hpp   include/wrenbind17/std.hpp   include/wrenbind17/stddeque.hpp   include/wrenbind17/stdlist.hpp   include/wrenbind17/stdmap.hpp   include/wrenbind17/stdoptional.hpp   include/wrenbind17/stdset.hpp   include/wrenbind17/stdvariant.hpp   include/wrenbind17/stdvector.hpp   include/wrenbind17/variable.hpp   include/wrenbind17/vm.hpp   include/wrenbind17/wrenbind17.hpp     Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':16,'href':'/wrenbind17/files/allocator_8hpp/','title':"include/wrenbind17/allocator.hpp",'section':"Files",'content':"include/wrenbind17/allocator.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;index.hpp\u0026#34;#include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { void setNextError(WrenVM* vm, std::string str); #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T, typename... Args\u0026gt; struct ForeignKlassAllocator { static T* ctor(Args\u0026amp;\u0026amp;... args) { return new T(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;size_t... Is\u0026gt; static T* ctorFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { return ctor(PopHelper\u0026lt;Args\u0026gt;::f(vm, Is + 1)...); } static void allocate(WrenVM* vm) { auto* memory = wrenSetSlotNewForeign(vm, 0, 0, sizeof(ForeignObject\u0026lt;T\u0026gt;)); new (memory) ForeignObject\u0026lt;T\u0026gt;(); auto* wrapper = reinterpret_cast\u0026lt;ForeignObject\u0026lt;T\u0026gt;*\u0026gt;(memory); try { wrapper-\u0026gt;ptr.reset(ctorFrom(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;())); } catch (std::exception\u0026amp; e) { wrenEnsureSlots(vm, 1); wrenSetSlotString(vm, 0, e.what()); wrenAbortFiber(vm, 0); } } static void finalize(void* memory) { auto* wrapper = reinterpret_cast\u0026lt;ForeignObject\u0026lt;T\u0026gt;*\u0026gt;(memory); wrapper-\u0026gt;~ForeignObject\u0026lt;T\u0026gt;(); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':17,'href':'/wrenbind17/files/any_8hpp/','title':"include/wrenbind17/any.hpp",'section':"Files",'content':"include/wrenbind17/any.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ReturnValue A return value when calling a Wren function (alias Any)    Source code #  #pragma once  #include \u0026lt;typeinfo\u0026gt;#include \u0026lt;memory\u0026gt; #include \u0026#34;handle.hpp\u0026#34;#include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { class ReturnValue { public: ReturnValue() = default; explicit ReturnValue(const WrenType type, Handle handle) : type(type), handle(std::move(handle)) { } ~ReturnValue() = default; ReturnValue(const ReturnValue\u0026amp; other) = delete; ReturnValue(ReturnValue\u0026amp;\u0026amp; other) noexcept { swap(other); } ReturnValue\u0026amp; operator=(const ReturnValue\u0026amp; other) = delete; ReturnValue\u0026amp; operator=(ReturnValue\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { swap(other); } return *this; } void swap(ReturnValue\u0026amp; other) noexcept { std::swap(type, other.type); std::swap(handle, other.handle); } const Handle\u0026amp; getHandle() const { return handle; } Handle\u0026amp; getHandle() { return handle; } WrenType getType() const { return type; } template \u0026lt;class T\u0026gt; bool is() const { if (type == WREN_TYPE_NULL) { return false; } if (const auto vm = handle.getVmWeak().lock()) { wrenEnsureSlots(vm.get(), 1); wrenSetSlotHandle(vm.get(), 0, handle.getHandle()); using Type = typename std::remove_reference\u0026lt;typename std::remove_pointer\u0026lt;T\u0026gt;::type\u0026gt;::type; return detail::is\u0026lt;Type\u0026gt;(vm.get(), 0); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } bool isMap() const { return type == WREN_TYPE_MAP; } bool isList() const { return type == WREN_TYPE_LIST; } template \u0026lt;class T\u0026gt; T as() { if (type == WREN_TYPE_NULL) { throw BadCast(\u0026#34;Bad cast when getting value from Wren\u0026#34;); } if (const auto vm = handle.getVmWeak().lock()) { wrenEnsureSlots(vm.get(), 1); wrenSetSlotHandle(vm.get(), 0, handle.getHandle()); return detail::PopHelper\u0026lt;T\u0026gt;::f(vm.get(), 0); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } template \u0026lt;class T\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; shared() { return as\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt;(); } private: WrenType type = WrenType::WREN_TYPE_NULL; Handle handle; }; #ifndef DOXYGEN_SHOULD_SKIP_THIS  template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;int8_t\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;char\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;short\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;int\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;long\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;long long\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;unsigned char\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;unsigned short\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;unsigned int\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;unsigned long\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;unsigned long long\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;float\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;double\u0026gt;() const { return type == WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;bool\u0026gt;() const { return type == WREN_TYPE_BOOL; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;std::nullptr_t\u0026gt;() const { return type == WREN_TYPE_NULL; } template \u0026lt;\u0026gt; inline bool ReturnValue::is\u0026lt;std::string\u0026gt;() const { return type == WREN_TYPE_STRING; } template \u0026lt;\u0026gt; inline std::nullptr_t ReturnValue::as\u0026lt;std::nullptr_t\u0026gt;() { if (!is\u0026lt;std::nullptr_t\u0026gt;()) { throw BadCast(\u0026#34;Return value is not a null\u0026#34;); } return nullptr; } #endif  using Any = ReturnValue; #ifndef DOXYGEN_SHOULD_SKIP_THIS  template \u0026lt;\u0026gt; inline Any detail::getSlot(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, 0); if (type == WREN_TYPE_NULL) { return Any(); } return Any(type, Handle(getSharedVm(vm), wrenGetSlotHandle(vm, idx))); } #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':18,'href':'/wrenbind17/files/caller_8hpp/','title':"include/wrenbind17/caller.hpp",'section':"Files",'content':"include/wrenbind17/caller.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;index.hpp\u0026#34;#include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper { static inline void push(WrenVM* vm, int index, R ret) { PushHelper\u0026lt;R\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;R\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, R\u0026amp; ret) { PushHelper\u0026lt;R*\u0026gt;::f(vm, index, \u0026amp;ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;const R\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, const R\u0026amp; ret) { PushHelper\u0026lt;R*\u0026gt;::f(vm, index, \u0026amp;const_cast\u0026lt;R\u0026amp;\u0026gt;(ret)); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;R*\u0026gt; { static inline void push(WrenVM* vm, int index, R* ret) { PushHelper\u0026lt;R*\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;const R*\u0026gt; { static inline void push(WrenVM* vm, int index, const R* ret) { PushHelper\u0026lt;const R*\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;R\u0026amp;\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, R\u0026amp;\u0026amp; ret) { PushHelper\u0026lt;R\u0026gt;::f(vm, index, std::move(ret)); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;const std::shared_ptr\u0026lt;R\u0026gt;\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, const std::shared_ptr\u0026lt;R\u0026gt;\u0026amp; ret) { PushHelper\u0026lt;const std::shared_ptr\u0026lt;R\u0026gt;\u0026amp;\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;std::shared_ptr\u0026lt;R\u0026gt;\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, std::shared_ptr\u0026lt;R\u0026gt;\u0026amp; ret) { PushHelper\u0026lt;std::shared_ptr\u0026lt;R\u0026gt;\u0026amp;\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;const std::variant\u0026lt;R\u0026gt;\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, const std::variant\u0026lt;R\u0026gt;\u0026amp; ret) { PushHelper\u0026lt;const std::variant\u0026lt;R\u0026gt;\u0026amp;\u0026gt;::f(vm, index, ret); } }; template \u0026lt;typename R\u0026gt; struct ForeginMethodReturnHelper\u0026lt;std::variant\u0026lt;R\u0026gt;\u0026amp;\u0026gt; { static inline void push(WrenVM* vm, int index, std::variant\u0026lt;R\u0026gt;\u0026amp; ret) { PushHelper\u0026lt;std::variant\u0026lt;R\u0026gt;\u0026amp;\u0026gt;::f(vm, index, ret); } }; template \u0026lt;\u0026gt; inline void ForeginMethodReturnHelper\u0026lt;const std::string\u0026amp;\u0026gt;::push(WrenVM* vm, int index, const std::string\u0026amp; ret) { PushHelper\u0026lt;const std::string\u0026amp;\u0026gt;::f(vm, index, ret); } template \u0026lt;\u0026gt; inline void ForeginMethodReturnHelper\u0026lt;std::string\u0026amp;\u0026gt;::push(WrenVM* vm, int index, std::string\u0026amp; ret) { PushHelper\u0026lt;std::string\u0026amp;\u0026gt;::f(vm, index, ret); } template \u0026lt;typename R, typename T, typename... Args\u0026gt; struct ForeignMethodCaller { template \u0026lt;R (T::*Fn)(Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); // R ret = (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...);  // PushHelper\u0026lt;R\u0026gt;::f(vm, 0, ret);  ForeginMethodReturnHelper\u0026lt;R\u0026gt;::push( vm, 0, (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...)); } template \u0026lt;R (T::*Fn)(Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } template \u0026lt;R (T::*Fn)(Args...) const, size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); // R ret = (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...);  // PushHelper\u0026lt;R\u0026gt;::f(vm, 0, ret);  ForeginMethodReturnHelper\u0026lt;R\u0026gt;::push( vm, 0, (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...)); } template \u0026lt;R (T::*Fn)(Args...) const\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename T, typename... Args\u0026gt; struct ForeignMethodCaller\u0026lt;void, T, Args...\u0026gt; { template \u0026lt;void (T::*Fn)(Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...); } template \u0026lt;void (T::*Fn)(Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } template \u0026lt;void (T::*Fn)(Args...) const, size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); (self-\u0026gt;*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...); } template \u0026lt;void (T::*Fn)(Args...) const\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename R, typename T, typename... Args\u0026gt; struct ForeignMethodExtCaller { template \u0026lt;R (*Fn)(T\u0026amp;, Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); // R ret = (*Fn)(*self, PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...);  // PushHelper\u0026lt;R\u0026gt;::f(vm, 0, ret);  ForeginMethodReturnHelper\u0026lt;R\u0026gt;::push( vm, 0, (*Fn)(*self, PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...)); } template \u0026lt;R (*Fn)(T\u0026amp;, Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename T, typename... Args\u0026gt; struct ForeignMethodExtCaller\u0026lt;void, T, Args...\u0026gt; { template \u0026lt;void (*Fn)(T\u0026amp;, Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); (*Fn)(*self, PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...); } template \u0026lt;void (*Fn)(T\u0026amp;, Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename R, typename... Args\u0026gt; struct ForeignFunctionCaller { template \u0026lt;R (*Fn)(Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { // R ret = (*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...);  // PushHelper\u0026lt;R\u0026gt;::f(vm, 0, ret);  ForeginMethodReturnHelper\u0026lt;R\u0026gt;::push( vm, 0, (*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...)); } template \u0026lt;R (*Fn)(Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename... Args\u0026gt; struct ForeignFunctionCaller\u0026lt;void, Args...\u0026gt; { template \u0026lt;void (*Fn)(Args...), size_t... Is\u0026gt; static void callFrom(WrenVM* vm, detail::index_list\u0026lt;Is...\u0026gt;) { (*Fn)(PopHelper\u0026lt;typename std::remove_const\u0026lt;Args\u0026gt;::type\u0026gt;::f(vm, Is + 1)...); } template \u0026lt;void (*Fn)(Args...)\u0026gt; static void call(WrenVM* vm) { try { callFrom\u0026lt;Fn\u0026gt;(vm, detail::index_range\u0026lt;0, sizeof...(Args)\u0026gt;()); } catch (...) { exceptionHandler(vm, std::current_exception()); } } }; template \u0026lt;typename T, typename V, V T::*Ptr\u0026gt; struct ForeignPropCaller { static void setter(WrenVM* vm) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); self-\u0026gt;*Ptr = PopHelper\u0026lt;V\u0026gt;::f(vm, 1); } static void getter(WrenVM* vm) { auto self = PopHelper\u0026lt;T*\u0026gt;::f(vm, 0); PushHelper\u0026lt;V\u0026gt;::f(vm, 0, std::forward\u0026lt;decltype(self-\u0026gt;*Ptr)\u0026gt;(self-\u0026gt;*Ptr)); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':19,'href':'/wrenbind17/files/exception_8hpp/','title':"include/wrenbind17/exception.hpp",'section':"Files",'content':"include/wrenbind17/exception.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Exception   class wrenbind17::NotFound   class wrenbind17::BadCast   class wrenbind17::RuntimeError   class wrenbind17::CompileError    Source code #  #pragma once  #include \u0026lt;stdexcept\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;string\u0026gt; namespace wrenbind17 { class Exception : public std::exception { public: Exception() = default; explicit Exception(std::string msg) : msg(std::move(msg)) { } const char* what() const throw() override { return msg.c_str(); } private: std::string msg; }; class NotFound : public Exception { public: NotFound() : Exception(\u0026#34;Not found\u0026#34;) { } }; class BadCast : public Exception { public: BadCast() : Exception(\u0026#34;Bad cast\u0026#34;) { } explicit BadCast(std::string msg) : Exception(std::move(msg)) { } }; class RuntimeError : public Exception { public: explicit RuntimeError(std::string msg) : Exception(std::move(msg)) { } }; class CompileError : public Exception { public: explicit CompileError(std::string msg) : Exception(std::move(msg)) { } }; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':20,'href':'/wrenbind17/files/foreign_8hpp/','title':"include/wrenbind17/foreign.hpp",'section':"Files",'content':"include/wrenbind17/foreign.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ForeignMethod Holds information about a foreign function of a foreign class.   class wrenbind17::ForeignProp Holds information about a foreign property of a foreign class.   class wrenbind17::ForeignKlass A foreign class.   class wrenbind17::ForeignMethodImpl Type specific implementation of foreign method.   class wrenbind17::ForeignPropImpl   class wrenbind17::ForeignKlassImpl    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;ostream\u0026gt;#include \u0026lt;unordered_map\u0026gt; #include \u0026#34;allocator.hpp\u0026#34;#include \u0026#34;caller.hpp\u0026#34; namespace wrenbind17 { enum ForeignMethodOperator { OPERATOR_GET_INDEX, OPERATOR_SET_INDEX, OPERATOR_SUB, OPERATOR_ADD, OPERATOR_MUL, OPERATOR_DIV, OPERATOR_NEG, OPERATOR_MOD, OPERATOR_EQUAL, OPERATOR_NOT_EQUAL, OPERATOR_GT, OPERATOR_LT, OPERATOR_GT_EQUAL, OPERATOR_LT_EQUAL, OPERATOR_SHIFT_LEFT, OPERATOR_SHIFT_RIGHT, OPERATOR_AND, OPERATOR_XOR, OPERATOR_OR }; class ForeignMethod { public: ForeignMethod(std::string name, WrenForeignMethodFn method, const bool isStatic) : name(std::move(name)), method(method), isStatic(isStatic) { } virtual ~ForeignMethod() = default; // If you are getting \u0026#34;referencing deleted function\u0026#34; error which is this one below,  // then you are trying to make a copy of ForeignKlass during vm.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;);  ForeignMethod(const ForeignMethod\u0026amp; other) = delete; virtual void generate(std::ostream\u0026amp; os) const = 0; const std::string\u0026amp; getName() const { return name; } WrenForeignMethodFn getMethod() const { return method; } bool getStatic() const { return isStatic; } protected: std::string name; WrenForeignMethodFn method; bool isStatic; }; class ForeignProp { public: ForeignProp(std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic) : name(std::move(name)), getter(getter), setter(setter), isStatic(isStatic) { } virtual ~ForeignProp() = default; // If you are getting \u0026#34;referencing deleted function\u0026#34; error which is this one below,  // then you are trying to make a copy of ForeignKlass during vm.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;);  ForeignProp(const ForeignProp\u0026amp; other) = delete; void generate(std::ostream\u0026amp; os) const { if (getter) os \u0026lt;\u0026lt; \u0026#34; foreign \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (setter) os \u0026lt;\u0026lt; \u0026#34; foreign \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;=(rhs)\\n\u0026#34;; } const std::string\u0026amp; getName() const { return name; } WrenForeignMethodFn getSetter() { return setter; } WrenForeignMethodFn getGetter() { return getter; } bool getStatic() const { return isStatic; } protected: std::string name; WrenForeignMethodFn getter; WrenForeignMethodFn setter; bool isStatic; }; class ForeignKlass { public: ForeignKlass(std::string name) : name(std::move(name)), allocators{nullptr, nullptr} { } virtual ~ForeignKlass() = default; // If you are getting \u0026#34;referencing deleted function\u0026#34; error which is this one below,  // then you are trying to make a copy of this class.  ForeignKlass(const ForeignKlass\u0026amp; other) = delete; virtual void generate(std::ostream\u0026amp; os) const = 0; ForeignMethod\u0026amp; findFunc(const std::string\u0026amp; name, const bool isStatic) { const auto it = methods.find(name); if (it == methods.end()) throw NotFound(); if (it-\u0026gt;second-\u0026gt;getStatic() != isStatic) throw NotFound(); return *it-\u0026gt;second; } ForeignProp\u0026amp; findProp(const std::string\u0026amp; name, const bool isStatic) { const auto it = props.find(name); if (it == props.end()) throw NotFound(); if (it-\u0026gt;second-\u0026gt;getStatic() != isStatic) throw NotFound(); return *it-\u0026gt;second; } WrenForeignMethodFn findSignature(const std::string\u0026amp; signature, const bool isStatic) { switch (signature[0]) { case \u0026#39;[\u0026#39;: case \u0026#39;-\u0026#39;: case \u0026#39;+\u0026#39;: case \u0026#39;/\u0026#39;: case \u0026#39;*\u0026#39;: case \u0026#39;=\u0026#39;: case \u0026#39;!\u0026#39;: case \u0026#39;%\u0026#39;: case \u0026#39;\u0026lt;\u0026#39;: case \u0026#39;\u0026gt;\u0026#39;: case \u0026#39;\u0026amp;\u0026#39;: case \u0026#39;^\u0026#39;: case \u0026#39;|\u0026#39;: { // Operators  return findFunc(signature, isStatic).getMethod(); } default: { if (signature.find(\u0026#39;(\u0026#39;) != std::string::npos) { // Check if setter  if (signature.find(\u0026#34;=(_)\u0026#34;) != std::string::npos) { return findProp(signature.substr(0, signature.find_first_of(\u0026#39;=\u0026#39;)), isStatic).getSetter(); } else { // Must be a method  return findFunc(signature, isStatic).getMethod(); } } else { return findProp(signature, isStatic).getGetter(); } } } } const std::string\u0026amp; getName() const { return name; } WrenForeignClassMethods\u0026amp; getAllocators() { return allocators; } protected: std::string name; std::string ctorDef; std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;ForeignMethod\u0026gt;\u0026gt; methods; std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;ForeignProp\u0026gt;\u0026gt; props; WrenForeignClassMethods allocators; }; template \u0026lt;typename... Args\u0026gt; class ForeignMethodImpl : public ForeignMethod { public: ForeignMethodImpl(std::string name, std::string signature, WrenForeignMethodFn fn, const bool isStatic) : ForeignMethod(std::move(name), fn, isStatic), signature(std::move(signature)) { } ~ForeignMethodImpl() = default; void generate(std::ostream\u0026amp; os) const override { os \u0026lt;\u0026lt; \u0026#34; foreign \u0026#34; \u0026lt;\u0026lt; (isStatic ? \u0026#34;static \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; signature \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } static std::string generateSignature(const std::string\u0026amp; name) { std::stringstream os; constexpr auto n = sizeof...(Args); os \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; for (size_t i = 0; i \u0026lt; n; i++) { if (i == 0) os \u0026lt;\u0026lt; \u0026#34;arg0\u0026#34;; else os \u0026lt;\u0026lt; \u0026#34;, arg\u0026#34; \u0026lt;\u0026lt; i; } os \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os.str(); } static std::string generateSignature(const ForeignMethodOperator name) { switch (name) { case OPERATOR_GET_INDEX: return \u0026#34;[arg]\u0026#34;; case OPERATOR_SET_INDEX: return \u0026#34;[arg]=(rhs)\u0026#34;; case OPERATOR_ADD: return \u0026#34;+(rhs)\u0026#34;; case OPERATOR_SUB: return \u0026#34;-(rhs)\u0026#34;; case OPERATOR_DIV: return \u0026#34;/(rhs)\u0026#34;; case OPERATOR_MUL: return \u0026#34;*(rhs)\u0026#34;; case OPERATOR_MOD: return \u0026#34;%(rhs)\u0026#34;; case OPERATOR_EQUAL: return \u0026#34;==(rhs)\u0026#34;; case OPERATOR_NOT_EQUAL: return \u0026#34;!=(rhs)\u0026#34;; case OPERATOR_NEG: return \u0026#34;-\u0026#34;; case OPERATOR_GT: return \u0026#34;\u0026gt;(rhs)\u0026#34;; case OPERATOR_LT: return \u0026#34;\u0026lt;(rhs)\u0026#34;; case OPERATOR_GT_EQUAL: return \u0026#34;\u0026gt;=(rhs)\u0026#34;; case OPERATOR_LT_EQUAL: return \u0026#34;\u0026lt;=(rhs)\u0026#34;; case OPERATOR_SHIFT_LEFT: return \u0026#34;\u0026lt;\u0026lt;(rhs)\u0026#34;; case OPERATOR_SHIFT_RIGHT: return \u0026#34;\u0026gt;\u0026gt;(rhs)\u0026#34;; case OPERATOR_AND: return \u0026#34;\u0026amp;(rhs)\u0026#34;; case OPERATOR_XOR: return \u0026#34;^(rhs)\u0026#34;; case OPERATOR_OR: return \u0026#34;|(rhs)\u0026#34;; default: throw Exception(\u0026#34;Operator not supported\u0026#34;); } } static std::string generateName(const ForeignMethodOperator name) { switch (name) { case OPERATOR_GET_INDEX: return \u0026#34;[_]\u0026#34;; case OPERATOR_SET_INDEX: return \u0026#34;[_]=(_)\u0026#34;; case OPERATOR_ADD: return \u0026#34;+(_)\u0026#34;; case OPERATOR_SUB: return \u0026#34;-(_)\u0026#34;; case OPERATOR_DIV: return \u0026#34;/(_)\u0026#34;; case OPERATOR_MUL: return \u0026#34;*(_)\u0026#34;; case OPERATOR_MOD: return \u0026#34;%(_)\u0026#34;; case OPERATOR_EQUAL: return \u0026#34;==(_)\u0026#34;; case OPERATOR_NOT_EQUAL: return \u0026#34;!=(_)\u0026#34;; case OPERATOR_NEG: return \u0026#34;-\u0026#34;; case OPERATOR_GT: return \u0026#34;\u0026gt;(_)\u0026#34;; case OPERATOR_LT: return \u0026#34;\u0026lt;(_)\u0026#34;; case OPERATOR_GT_EQUAL: return \u0026#34;\u0026gt;=(_)\u0026#34;; case OPERATOR_LT_EQUAL: return \u0026#34;\u0026lt;=(_)\u0026#34;; case OPERATOR_SHIFT_LEFT: return \u0026#34;\u0026lt;\u0026lt;(_)\u0026#34;; case OPERATOR_SHIFT_RIGHT: return \u0026#34;\u0026gt;\u0026gt;(_)\u0026#34;; case OPERATOR_AND: return \u0026#34;\u0026amp;(_)\u0026#34;; case OPERATOR_XOR: return \u0026#34;^(_)\u0026#34;; case OPERATOR_OR: return \u0026#34;|(_)\u0026#34;; default: throw Exception(\u0026#34;Operator not supported\u0026#34;); } } private: std::string signature; }; template \u0026lt;typename T, typename V\u0026gt; class ForeignPropImpl : public ForeignProp { public: ForeignPropImpl(std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic) : ForeignProp(std::move(name), getter, setter, isStatic) { } ~ForeignPropImpl() = default; }; #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename... Args\u0026gt; inline std::string generateNameArgs() { constexpr auto n = sizeof...(Args); std::stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; for (size_t i = 0; i \u0026lt; n; i++) { ss \u0026lt;\u0026lt; \u0026#34;_\u0026#34;; if (i != n - 1) { ss \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } } ss \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return ss.str(); } template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignFunctionDetails; template \u0026lt;typename R, typename... Args, R (*Fn)(Args...)\u0026gt; struct ForeignFunctionDetails\u0026lt;R (*)(Args...), Fn\u0026gt; { typedef ForeignMethodImpl\u0026lt;Args...\u0026gt; ForeignMethodImplType; static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(std::string name) { auto signature = ForeignMethodImplType::generateSignature(name); auto p = detail::ForeignFunctionCaller\u0026lt;R, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; name = name + detail::generateNameArgs\u0026lt;Args...\u0026gt;(); return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, true); } }; template \u0026lt;typename M\u0026gt; struct GetPointerType { template \u0026lt;typename C, typename T\u0026gt; static T getType(T C::*v); typedef decltype(getType(static_cast\u0026lt;M\u0026gt;(nullptr))) type; }; template \u0026lt;typename Var, Var var\u0026gt; struct GetVarTraits; template \u0026lt;typename C, typename T, T C::*Var\u0026gt; struct GetVarTraits\u0026lt;T C::*, Var\u0026gt; { using klass = C; }; } // namespace detail #endif  template \u0026lt;typename T\u0026gt; class ForeignKlassImpl : public ForeignKlass { public: ForeignKlassImpl(std::string name) : ForeignKlass(std::move(name)) { allocators.allocate = nullptr; allocators.finalize = \u0026amp;detail::ForeignKlassAllocator\u0026lt;T\u0026gt;::finalize; } ~ForeignKlassImpl() = default; // If you are getting \u0026#34;referencing deleted function\u0026#34; error which is this one below,  // then you are trying to make a copy of this class.  // Make sure you are not creating a copy while registering your custom C++ class as:  // auto\u0026amp; cls = vm.module(\u0026#34;mymodule\u0026#34;).klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;);  // Notice the \u0026#34;auto\u0026amp;\u0026#34;  ForeignKlassImpl(const ForeignKlassImpl\u0026lt;T\u0026gt;\u0026amp; other) = delete; void generate(std::ostream\u0026amp; os) const override { os \u0026lt;\u0026lt; \u0026#34;foreign class \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; {\\n\u0026#34;; if (!ctorDef.empty()) { os \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ctorDef; } for (const auto\u0026amp; pair : methods) { pair.second-\u0026gt;generate(os); } for (const auto\u0026amp; pair : props) { pair.second-\u0026gt;generate(os); } os \u0026lt;\u0026lt; \u0026#34;}\\n\\n\u0026#34;; } template \u0026lt;typename... Args\u0026gt; void ctor(const std::string\u0026amp; name = \u0026#34;new\u0026#34;) { allocators.allocate = \u0026amp;detail::ForeignKlassAllocator\u0026lt;T, Args...\u0026gt;::allocate; std::stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;construct \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; (\u0026#34;; constexpr auto n = sizeof...(Args); for (size_t i = 0; i \u0026lt; n; i++) { if (i == 0) ss \u0026lt;\u0026lt; \u0026#34;arg0\u0026#34;; else ss \u0026lt;\u0026lt; \u0026#34;, arg\u0026#34; \u0026lt;\u0026lt; i; } ss \u0026lt;\u0026lt; \u0026#34;) {}\\n\\n\u0026#34;; ctorDef = ss.str(); } #ifndef DOXYGEN_SHOULD_SKIP_THIS  template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignMethodDetails; template \u0026lt;typename R, typename C, typename... Args, R (C::*Fn)(Args...)\u0026gt; struct ForeignMethodDetails\u0026lt;R (C::*)(Args...), Fn\u0026gt; { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The method belong to its own class or a base class\u0026#34;); typedef ForeignMethodImpl\u0026lt;Args...\u0026gt; ForeignMethodImplType; static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(std::string name) { auto signature = ForeignMethodImplType::generateSignature(name); auto p = detail::ForeignMethodCaller\u0026lt;R, C, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; name = name + detail::generateNameArgs\u0026lt;Args...\u0026gt;(); return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(const ForeignMethodOperator op) { auto signature = ForeignMethodImplType::generateSignature(op); auto name = ForeignMethodImplType::generateName(op); auto p = detail::ForeignMethodCaller\u0026lt;R, C, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } }; template \u0026lt;typename R, typename C, typename... Args, R (C::*Fn)(Args...) const\u0026gt; struct ForeignMethodDetails\u0026lt;R (C::*)(Args...) const, Fn\u0026gt; { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The method belong to its own class or a base class\u0026#34;); typedef ForeignMethodImpl\u0026lt;Args...\u0026gt; ForeignMethodImplType; static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(std::string name) { auto signature = ForeignMethodImplType::generateSignature(name); auto p = detail::ForeignMethodCaller\u0026lt;R, C, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; name = name + detail::generateNameArgs\u0026lt;Args...\u0026gt;(); return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(const ForeignMethodOperator op) { auto signature = ForeignMethodImplType::generateSignature(op); auto name = ForeignMethodImplType::generateName(op); auto p = detail::ForeignMethodCaller\u0026lt;R, C, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } }; template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignMethodExtDetails; template \u0026lt;typename R, typename... Args, R (*Fn)(T\u0026amp;, Args...)\u0026gt; struct ForeignMethodExtDetails\u0026lt;R (*)(T\u0026amp;, Args...), Fn\u0026gt; { typedef ForeignMethodImpl\u0026lt;Args...\u0026gt; ForeignMethodImplType; static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(std::string name) { auto signature = ForeignMethodImplType::generateSignature(name); auto p = detail::ForeignMethodExtCaller\u0026lt;R, T, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; name = name + detail::generateNameArgs\u0026lt;Args...\u0026gt;(); return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } static std::unique_ptr\u0026lt;ForeignMethodImplType\u0026gt; make(const ForeignMethodOperator op) { auto signature = ForeignMethodImplType::generateSignature(op); auto name = ForeignMethodImplType::generateName(op); auto p = detail::ForeignMethodExtCaller\u0026lt;R, T, Args...\u0026gt;::template call\u0026lt;Fn\u0026gt;; return std::make_unique\u0026lt;ForeignMethodImplType\u0026gt;(std::move(name), std::move(signature), p, false); } }; template \u0026lt;typename V, typename C, V C::*Ptr\u0026gt; struct ForeignVarDetails { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The variable belong to its own class or a base class\u0026#34;); static std::unique_ptr\u0026lt;ForeignProp\u0026gt; make(std::string name, const bool readonly) { auto s = readonly ? nullptr : detail::ForeignPropCaller\u0026lt;C, V, Ptr\u0026gt;::setter; auto g = detail::ForeignPropCaller\u0026lt;C, V, Ptr\u0026gt;::getter; return std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, s, false); } }; template \u0026lt;typename V, typename C, V C::*Ptr\u0026gt; struct ForeignVarReadonlyDetails { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The variable belong to its own class or a base class\u0026#34;); static std::unique_ptr\u0026lt;ForeignProp\u0026gt; make(std::string name, const bool readonly) { auto g = detail::ForeignPropCaller\u0026lt;C, V, Ptr\u0026gt;::getter; return std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, nullptr, false); } }; template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignSetterDetails; template \u0026lt;typename V, typename C, void (C::*Fn)(V)\u0026gt; struct ForeignSetterDetails\u0026lt;void (C::*)(V), Fn\u0026gt; { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The setter must belong to its own class or a base class\u0026#34;); static WrenForeignMethodFn method() { return detail::ForeignMethodCaller\u0026lt;void, C, V\u0026gt;::template call\u0026lt;Fn\u0026gt;; } }; template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignSetterExtDetails; template \u0026lt;typename V, void (*Fn)(T\u0026amp;, V)\u0026gt; struct ForeignSetterExtDetails\u0026lt;void (*)(T\u0026amp;, V), Fn\u0026gt; { static WrenForeignMethodFn method() { return detail::ForeignMethodExtCaller\u0026lt;void, T, V\u0026gt;::template call\u0026lt;Fn\u0026gt;; } }; template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignGetterDetails; template \u0026lt;typename R, typename C, R (C::*Fn)()\u0026gt; struct ForeignGetterDetails\u0026lt;R (C::*)(), Fn\u0026gt; { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The getter must belong to its own class or a base class\u0026#34;); static WrenForeignMethodFn method() { return detail::ForeignMethodCaller\u0026lt;R, C\u0026gt;::template call\u0026lt;Fn\u0026gt;; } }; template \u0026lt;typename R, typename C, R (C::*Fn)() const\u0026gt; struct ForeignGetterDetails\u0026lt;R (C::*)() const, Fn\u0026gt; { static_assert(std::is_base_of\u0026lt;C, T\u0026gt;::value, \u0026#34;The getter must belong to its own class or a base class\u0026#34;); static WrenForeignMethodFn method() { return detail::ForeignMethodCaller\u0026lt;R, C\u0026gt;::template call\u0026lt;Fn\u0026gt;; } }; template \u0026lt;typename Signature, Signature signature\u0026gt; struct ForeignGetterExtDetails; template \u0026lt;typename R, R (*Fn)(T\u0026amp;)\u0026gt; struct ForeignGetterExtDetails\u0026lt;R (*)(T\u0026amp;), Fn\u0026gt; { static WrenForeignMethodFn method() { return detail::ForeignMethodExtCaller\u0026lt;R, T\u0026gt;::template call\u0026lt;Fn\u0026gt;; } }; #endif  template \u0026lt;auto Fn\u0026gt; void func(std::string name) { auto ptr = ForeignMethodDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(std::move(name)); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Fn\u0026gt; void func(const ForeignMethodOperator name) { auto ptr = ForeignMethodDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(name); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Fn\u0026gt; void funcExt(std::string name) { auto ptr = ForeignMethodExtDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(std::move(name)); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Fn\u0026gt; void funcExt(const ForeignMethodOperator name) { auto ptr = ForeignMethodExtDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(name); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Fn\u0026gt; void funcStatic(std::string name) { auto ptr = detail::ForeignFunctionDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(std::move(name)); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Fn\u0026gt; void funcStaticExt(std::string name) { // This is exactly the same as funcStatic because there is  // no difference for \u0026#34;static void Foo::foo(){}\u0026#34; and \u0026#34;void foo(){}\u0026#34;!  auto ptr = detail::ForeignFunctionDetails\u0026lt;decltype(Fn), Fn\u0026gt;::make(std::move(name)); methods.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Var\u0026gt; void var(std::string name) { using R = typename detail::GetPointerType\u0026lt;decltype(Var)\u0026gt;::type; using C = typename detail::GetVarTraits\u0026lt;decltype(Var), Var\u0026gt;::klass; auto ptr = ForeignVarDetails\u0026lt;R, C, Var\u0026gt;::make(std::move(name), false); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Var\u0026gt; void varReadonly(std::string name) { using R = typename detail::GetPointerType\u0026lt;decltype(Var)\u0026gt;::type; using C = typename detail::GetVarTraits\u0026lt;decltype(Var), Var\u0026gt;::klass; auto ptr = ForeignVarReadonlyDetails\u0026lt;R, C, Var\u0026gt;::make(std::move(name), true); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Getter, auto Setter\u0026gt; void prop(std::string name) { auto g = ForeignGetterDetails\u0026lt;decltype(Getter), Getter\u0026gt;::method(); auto s = ForeignSetterDetails\u0026lt;decltype(Setter), Setter\u0026gt;::method(); auto ptr = std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, s, false); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Getter\u0026gt; void propReadonly(std::string name) { auto g = ForeignGetterDetails\u0026lt;decltype(Getter), Getter\u0026gt;::method(); auto ptr = std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, nullptr, false); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Getter, auto Setter\u0026gt; void propExt(std::string name) { auto g = ForeignGetterExtDetails\u0026lt;decltype(Getter), Getter\u0026gt;::method(); auto s = ForeignSetterExtDetails\u0026lt;decltype(Setter), Setter\u0026gt;::method(); auto ptr = std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, s, false); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } template \u0026lt;auto Getter\u0026gt; void propReadonlyExt(std::string name) { auto g = ForeignGetterExtDetails\u0026lt;decltype(Getter), Getter\u0026gt;::method(); auto ptr = std::make_unique\u0026lt;ForeignProp\u0026gt;(std::move(name), g, nullptr, false); props.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); } }; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':21,'href':'/wrenbind17/files/handle_8hpp/','title':"include/wrenbind17/handle.hpp",'section':"Files",'content':"include/wrenbind17/handle.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Handle Holds a reference to some Wren type.    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;exception.hpp\u0026#34; namespace wrenbind17 { std::shared_ptr\u0026lt;WrenVM\u0026gt; getSharedVm(WrenVM* vm); class Handle { public: Handle() : handle(nullptr) { } Handle(const std::shared_ptr\u0026lt;WrenVM\u0026gt; vm, WrenHandle* handle) : vm(vm), handle(handle) { } ~Handle() { reset(); } Handle(const Handle\u0026amp; other) = delete; Handle(Handle\u0026amp;\u0026amp; other) noexcept : handle(nullptr) { swap(other); } Handle\u0026amp; operator=(const Handle\u0026amp; other) = delete; Handle\u0026amp; operator=(Handle\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { swap(other); } return *this; } void swap(Handle\u0026amp; other) noexcept { std::swap(vm, other.vm); std::swap(handle, other.handle); } WrenHandle* getHandle() const { return handle; } WrenVM* getVm() const { if (const auto ptr = vm.lock()) { return ptr.get(); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } const std::weak_ptr\u0026lt;WrenVM\u0026gt;\u0026amp; getVmWeak() const { return vm; } void reset() { if (!vm.expired() \u0026amp;\u0026amp; handle) { wrenReleaseHandle(vm.lock().get(), handle); vm.reset(); handle = nullptr; } } operator bool() const { return !vm.expired() \u0026amp;\u0026amp; handle; } private: std::weak_ptr\u0026lt;WrenVM\u0026gt; vm; WrenHandle* handle; }; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':22,'href':'/wrenbind17/files/index_8hpp/','title':"include/wrenbind17/index.hpp",'section':"Files",'content':"include/wrenbind17/index.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;memory\u0026gt; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;size_t... Is\u0026gt; struct index_list {}; // Declare primary template for index range builder  template \u0026lt;size_t MIN, size_t N, size_t... Is\u0026gt; struct range_builder; // Base step  template \u0026lt;size_t MIN, size_t... Is\u0026gt; struct range_builder\u0026lt;MIN, MIN, Is...\u0026gt; { typedef index_list\u0026lt;Is...\u0026gt; type; }; // Induction step  template \u0026lt;size_t MIN, size_t N, size_t... Is\u0026gt; struct range_builder : public range_builder\u0026lt;MIN, N - 1, N - 1, Is...\u0026gt; {}; // Meta-function that returns a [MIN, MAX) index range  template \u0026lt;size_t MIN, size_t MAX\u0026gt; using index_range = typename detail::range_builder\u0026lt;MIN, MAX\u0026gt;::type; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':23,'href':'/wrenbind17/files/map_8hpp/','title':"include/wrenbind17/map.hpp",'section':"Files",'content':"include/wrenbind17/map.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Map Holds native Wren map.    Source code #  #pragma once  #include \u0026#34;method.hpp\u0026#34;#include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { class Map { public: Map() { } Map(const std::shared_ptr\u0026lt;Handle\u0026gt;\u0026amp; handle) : handle(handle) { } ~Map() { reset(); } Handle\u0026amp; getHandle() { return *handle; } const Handle\u0026amp; getHandle() const { return *handle; } operator bool() const { return handle.operator bool(); } void reset() { handle.reset(); } template \u0026lt;typename Key\u0026gt; bool contains(const Key\u0026amp; key) const { if (const auto ptr = handle-\u0026gt;getVmWeak().lock()) { wrenEnsureSlots(ptr.get(), 2); wrenSetSlotHandle(ptr.get(), 0, handle-\u0026gt;getHandle()); detail::PushHelper\u0026lt;Key\u0026gt;::f(ptr.get(), 1, key); return wrenGetMapContainsKey(ptr.get(), 0, 1); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } template \u0026lt;typename T, typename Key\u0026gt; T get(const Key\u0026amp; key) const { if (const auto ptr = handle-\u0026gt;getVmWeak().lock()) { wrenEnsureSlots(ptr.get(), 3); wrenSetSlotHandle(ptr.get(), 0, handle-\u0026gt;getHandle()); detail::PushHelper\u0026lt;Key\u0026gt;::f(ptr.get(), 1, key); if (!wrenGetMapContainsKey(ptr.get(), 0, 1)) { throw NotFound(); } wrenGetMapValue(ptr.get(), 0, 1, 2); return detail::PopHelper\u0026lt;T\u0026gt;::f(ptr.get(), 2); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } template \u0026lt;typename Key\u0026gt; bool erase(const Key\u0026amp; key) const { if (const auto ptr = handle-\u0026gt;getVmWeak().lock()) { wrenEnsureSlots(ptr.get(), 3); wrenSetSlotHandle(ptr.get(), 0, handle-\u0026gt;getHandle()); detail::PushHelper\u0026lt;Key\u0026gt;::f(ptr.get(), 1, key); wrenRemoveMapValue(ptr.get(), 0, 1, 2); return !detail::is\u0026lt;std::nullptr_t\u0026gt;(ptr.get(), 2); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } size_t count() const { if (const auto ptr = handle-\u0026gt;getVmWeak().lock()) { wrenEnsureSlots(ptr.get(), 1); wrenSetSlotHandle(ptr.get(), 0, handle-\u0026gt;getHandle()); return wrenGetMapCount(ptr.get(), 0); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } private: std::shared_ptr\u0026lt;Handle\u0026gt; handle; }; template \u0026lt;\u0026gt; inline Map detail::getSlot\u0026lt;Map\u0026gt;(WrenVM* vm, const int idx) { validate\u0026lt;WrenType::WREN_TYPE_MAP\u0026gt;(vm, idx); return Map(std::make_shared\u0026lt;Handle\u0026gt;(getSharedVm(vm), wrenGetSlotHandle(vm, idx))); } template \u0026lt;\u0026gt; inline bool detail::is\u0026lt;Map\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WREN_TYPE_MAP; } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Map\u0026gt;::f(WrenVM* vm, int idx, const Map\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Map\u0026gt;::f(WrenVM* vm, int idx, Map\u0026amp;\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;const Map\u0026gt;::f(WrenVM* vm, int idx, const Map value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;const Map\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, const Map\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Map\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, Map\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':24,'href':'/wrenbind17/files/method_8hpp/','title':"include/wrenbind17/method.hpp",'section':"Files",'content':"include/wrenbind17/method.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Method    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;any.hpp\u0026#34;#include \u0026#34;exception.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { inline void pushArgs(WrenVM* vm, int idx) { (void)vm; (void)idx; } template \u0026lt;typename First, typename... Other\u0026gt; inline void pushArgs(WrenVM* vm, int idx, First\u0026amp;\u0026amp; first, Other\u0026amp;\u0026amp;... other) { PushHelper\u0026lt;First\u0026gt;::f(vm, idx, std::forward\u0026lt;First\u0026gt;(first)); pushArgs(vm, ++idx, std::forward\u0026lt;Other\u0026gt;(other)...); } template \u0026lt;typename... Args\u0026gt; struct CallAndReturn { static Any func(WrenVM* vm, WrenHandle* handle, WrenHandle* func, Args\u0026amp;\u0026amp;... args) { constexpr auto n = sizeof...(Args); wrenEnsureSlots(vm, n + 1); wrenSetSlotHandle(vm, 0, handle); pushArgs(vm, 1, std::forward\u0026lt;Args\u0026gt;(args)...); if (wrenCall(vm, func) != WREN_RESULT_SUCCESS) { throw RuntimeError(getLastError(vm)); } return getSlot\u0026lt;Any\u0026gt;(vm, 0); } }; } // namespace detail #endif  class Method { public: Method() = default; Method(std::shared_ptr\u0026lt;Handle\u0026gt; variable, std::shared_ptr\u0026lt;Handle\u0026gt; handle) : variable(std::move(variable)), handle(std::move(handle)) { } ~Method() { reset(); } template \u0026lt;typename... Args\u0026gt; Any operator()(Args\u0026amp;\u0026amp;... args) { if (const auto ptr = handle-\u0026gt;getVmWeak().lock().get()) { return detail::CallAndReturn\u0026lt;Args...\u0026gt;::func(ptr, variable-\u0026gt;getHandle(), handle-\u0026gt;getHandle(), std::forward\u0026lt;Args\u0026gt;(args)...); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } operator bool() const { return variable \u0026amp;\u0026amp; handle; } void reset() { handle.reset(); variable.reset(); } private: std::shared_ptr\u0026lt;Handle\u0026gt; variable; std::shared_ptr\u0026lt;Handle\u0026gt; handle; }; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':25,'href':'/wrenbind17/files/module_8hpp/','title':"include/wrenbind17/module.hpp",'section':"Files",'content':"include/wrenbind17/module.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::ForeignModule    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;unordered_map\u0026gt; #include \u0026#34;foreign.hpp\u0026#34; namespace wrenbind17 { void addClassType(WrenVM* vm, const std::string\u0026amp; module, const std::string\u0026amp; name, size_t hash); void addClassCast(WrenVM* vm, std::shared_ptr\u0026lt;detail::ForeignPtrConvertor\u0026gt; convertor, size_t hash, size_t other); class ForeignModule { public: ForeignModule(std::string name, WrenVM* vm) : name(std::move(name)), vm(vm) { } ForeignModule(const ForeignModule\u0026amp; other) = delete; ForeignModule(ForeignModule\u0026amp;\u0026amp; other) noexcept : vm(nullptr) { swap(other); } ~ForeignModule() = default; ForeignModule\u0026amp; operator=(const ForeignModule\u0026amp; other) = delete; ForeignModule\u0026amp; operator=(ForeignModule\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { swap(other); } return *this; } void swap(ForeignModule\u0026amp; other) { std::swap(klasses, other.klasses); std::swap(vm, other.vm); std::swap(name, other.name); } template \u0026lt;typename T, typename... Others\u0026gt; ForeignKlassImpl\u0026lt;T\u0026gt;\u0026amp; klass(std::string name) { insertKlassCast\u0026lt;T, Others...\u0026gt;(); auto ptr = std::make_unique\u0026lt;ForeignKlassImpl\u0026lt;T\u0026gt;\u0026gt;(std::move(name)); auto ret = ptr.get(); addClassType(vm, this-\u0026gt;name, ptr-\u0026gt;getName(), typeid(T).hash_code()); klasses.insert(std::make_pair(ptr-\u0026gt;getName(), std::move(ptr))); return *ret; } std::string str() const { std::stringstream ss; for (const auto\u0026amp; pair : klasses) { pair.second-\u0026gt;generate(ss); } for (const auto\u0026amp; r : raw) { ss \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return ss.str(); } void append(std::string text) { raw.push_back(std::move(text)); } ForeignKlass\u0026amp; findKlass(const std::string\u0026amp; name) { auto it = klasses.find(name); if (it == klasses.end()) throw NotFound(); return *it-\u0026gt;second; } const std::string\u0026amp; getName() const { return name; } private: template \u0026lt;typename T\u0026gt; void insertKlassCast() { // void  } template \u0026lt;typename T, typename Other, typename... Others\u0026gt; void insertKlassCast() { addClassCast(vm, std::make_shared\u0026lt;detail::ForeignObjectSharedPtrConvertor\u0026lt;T, Other\u0026gt;\u0026gt;(), typeid(T).hash_code(), typeid(Other).hash_code() ); insertKlassCast\u0026lt;T, Others...\u0026gt;(); } std::string name; WrenVM* vm; std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;ForeignKlass\u0026gt;\u0026gt; klasses; std::vector\u0026lt;std::string\u0026gt; raw; }; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':26,'href':'/wrenbind17/files/object_8hpp/','title':"include/wrenbind17/object.hpp",'section':"Files",'content':"include/wrenbind17/object.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;cstdlib\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;typeinfo\u0026gt;#include \u0026lt;variant\u0026gt; #include \u0026#34;exception.hpp\u0026#34;#include \u0026#34;handle.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  std::string getLastError(WrenVM* vm); inline void exceptionHandler(WrenVM* vm, const std::exception_ptr\u0026amp; eptr) { try { if (eptr) { std::rethrow_exception(eptr); } else { wrenEnsureSlots(vm, 1); wrenSetSlotString(vm, 0, \u0026#34;Unknown error\u0026#34;); wrenAbortFiber(vm, 0); } } catch (std::exception\u0026amp; e) { wrenEnsureSlots(vm, 1); wrenSetSlotString(vm, 0, e.what()); wrenAbortFiber(vm, 0); } } template \u0026lt;class T\u0026gt; struct is_shared_ptr : std::false_type {}; template \u0026lt;class T\u0026gt; struct is_shared_ptr\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; : std::true_type {}; namespace detail { class Foreign { public: Foreign() = default; virtual ~Foreign() = 0; virtual void* get() const = 0; virtual size_t hash() const = 0; }; inline Foreign::~Foreign() { } template \u0026lt;typename T\u0026gt; class ForeignObject : public Foreign { public: ForeignObject() { } ForeignObject(std::shared_ptr\u0026lt;T\u0026gt; ptr) : ptr(std::move(ptr)) { } virtual ~ForeignObject() = default; void* get() const override { return ptr.get(); } size_t hash() const override { return typeid(T).hash_code(); } const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; shared() const { return ptr; } std::shared_ptr\u0026lt;T\u0026gt; ptr; }; class ForeignPtrConvertor { public: ForeignPtrConvertor() = default; virtual ~ForeignPtrConvertor() = default; }; template \u0026lt;typename T\u0026gt; class ForeignSharedPtrConvertor : public ForeignPtrConvertor { public: ForeignSharedPtrConvertor() = default; virtual ~ForeignSharedPtrConvertor() = default; virtual std::shared_ptr\u0026lt;T\u0026gt; cast(Foreign* foreign) const = 0; }; template \u0026lt;typename From, typename To\u0026gt; class ForeignObjectSharedPtrConvertor : public ForeignSharedPtrConvertor\u0026lt;To\u0026gt; { public: ForeignObjectSharedPtrConvertor() = default; virtual ~ForeignObjectSharedPtrConvertor() = default; inline std::shared_ptr\u0026lt;To\u0026gt; cast(Foreign* foreign) const override { if (!foreign) throw Exception(\u0026#34;Cannot upcast foreign pointer is null and this should not happen\u0026#34;); auto* ptr = dynamic_cast\u0026lt;ForeignObject\u0026lt;From\u0026gt;*\u0026gt;(foreign); if (!ptr) throw BadCast(\u0026#34;Bad cast while upcasting to a base type\u0026#34;); return std::dynamic_pointer_cast\u0026lt;To\u0026gt;(ptr-\u0026gt;shared()); } }; template \u0026lt;class T\u0026gt; struct is_shared_ptr : std::false_type {}; template \u0026lt;class T\u0026gt; struct is_shared_ptr\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; : std::true_type {}; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':27,'href':'/wrenbind17/files/pop_8hpp/','title':"include/wrenbind17/pop.hpp",'section':"Files",'content':"include/wrenbind17/pop.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;string\u0026gt;#include \u0026lt;memory\u0026gt; #include \u0026#34;object.hpp\u0026#34; namespace wrenbind17 { void getClassType(WrenVM* vm, std::string\u0026amp; module, std::string\u0026amp; name, size_t hash); detail::ForeignPtrConvertor* getClassCast(WrenVM* vm, size_t hash, size_t other); #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { // ============================================================================================================  // CHECK SLOTS FOR TYPE  // ============================================================================================================  inline const char* wrenSlotTypeToStr(const WrenType type) { switch (type) { case WREN_TYPE_BOOL: return \u0026#34;bool\u0026#34;; case WREN_TYPE_FOREIGN: return \u0026#34;instance\u0026#34;; case WREN_TYPE_LIST: return \u0026#34;list\u0026#34;; case WREN_TYPE_NULL: return \u0026#34;null\u0026#34;; case WREN_TYPE_NUM: return \u0026#34;number\u0026#34;; case WREN_TYPE_STRING: return \u0026#34;string\u0026#34;; case WREN_TYPE_UNKNOWN: default: return \u0026#34;unknown\u0026#34;; } } template \u0026lt;typename T\u0026gt; inline bool is(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type != WrenType::WREN_TYPE_FOREIGN) return false; auto slot = wrenGetSlotForeign(vm, idx); const auto foreign = reinterpret_cast\u0026lt;Foreign*\u0026gt;(slot); return foreign-\u0026gt;hash() == typeid(T).hash_code(); } template \u0026lt;\u0026gt; inline bool is\u0026lt;bool\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_BOOL; } template \u0026lt;\u0026gt; inline bool is\u0026lt;std::string\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_STRING; } template \u0026lt;\u0026gt; inline bool is\u0026lt;std::nullptr_t\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NULL; } template \u0026lt;\u0026gt; inline bool is\u0026lt;float\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;double\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;int\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;int8_t\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;char\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;unsigned char\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;short\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;unsigned short\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;unsigned\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;long\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;long long\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;unsigned long\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;\u0026gt; inline bool is\u0026lt;unsigned long long\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WrenType::WREN_TYPE_NUM; } template \u0026lt;typename T\u0026gt; struct CheckSlot { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;T\u0026amp;\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;const T\u0026amp;\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;T*\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;const T*\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct CheckSlot\u0026lt;const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static bool f(WrenVM* vm, const int idx) { return is\u0026lt;T\u0026gt;(vm, idx); } }; // ============================================================================================================  // BASIC TYPES  // ============================================================================================================  template \u0026lt;WrenType Type\u0026gt; inline void validate(WrenVM* vm, int idx) { const auto t = wrenGetSlotType(vm, idx); if (t != Type) throw BadCast(\u0026#34;Bad cast when getting value from Wren got \u0026#34; + std::string(wrenSlotTypeToStr(t)) + \u0026#34; expected \u0026#34; + std::string(wrenSlotTypeToStr(Type))); } template \u0026lt;typename T\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; getSlotForeign(WrenVM* vm, void* slot) { using Type = typename std::remove_const\u0026lt;typename std::remove_pointer\u0026lt;T\u0026gt;::type\u0026gt;::type; using ForeignTypeConvertor = ForeignSharedPtrConvertor\u0026lt;Type\u0026gt;; const auto foreign = reinterpret_cast\u0026lt;Foreign*\u0026gt;(slot); if (foreign-\u0026gt;hash() != typeid(Type).hash_code()) { try { auto base = getClassCast(vm, foreign-\u0026gt;hash(), typeid(Type).hash_code()); auto derived = reinterpret_cast\u0026lt;ForeignTypeConvertor*\u0026gt;(base); if (!derived) { throw BadCast(\u0026#34;Bad cast the value cannot be upcast to the expected type\u0026#34;); } return derived-\u0026gt;cast(foreign); } catch (std::out_of_range\u0026amp; e) { (void)e; throw BadCast(\u0026#34;Bad cast the value is not the expected type\u0026#34;); } } auto ptr = reinterpret_cast\u0026lt;ForeignObject\u0026lt;Type\u0026gt;*\u0026gt;(foreign); return ptr-\u0026gt;shared(); } template \u0026lt;typename T\u0026gt; const std::shared_ptr\u0026lt;T\u0026gt; getSlotForeign(WrenVM* vm, const int idx) { validate\u0026lt;WrenType::WREN_TYPE_FOREIGN\u0026gt;(vm, idx); return getSlotForeign\u0026lt;T\u0026gt;(vm, wrenGetSlotForeign(vm, idx)); } template \u0026lt;typename T\u0026gt; T getSlot(WrenVM* vm, int idx) { static_assert(!std::is_same\u0026lt;std::string, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); validate\u0026lt;WrenType::WREN_TYPE_FOREIGN\u0026gt;(vm, idx); return *getSlotForeign\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;(vm, idx).get(); } template \u0026lt;typename T\u0026gt; struct PopHelper { static inline T f(WrenVM* vm, int idx) { return getSlot\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;T*\u0026gt; { static inline T* f(WrenVM* vm, int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_NULL) return nullptr; else if (type != WrenType::WREN_TYPE_FOREIGN) throw BadCast(\u0026#34;Bad cast when getting value from Wren\u0026#34;); return getSlotForeign\u0026lt;typename std::remove_const\u0026lt;T\u0026gt;::type\u0026gt;(vm, idx).get(); } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const T\u0026amp;\u0026gt; { static inline const T\u0026amp; f(WrenVM* vm, int idx) { static_assert(!std::is_same\u0026lt;std::string, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!std::is_same\u0026lt;std::nullptr_t, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::nullptr_t\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); return *getSlotForeign\u0026lt;T\u0026gt;(vm, idx).get(); } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; { static inline std::shared_ptr\u0026lt;T\u0026gt; f(WrenVM* vm, int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_NULL) return nullptr; else if (type != WrenType::WREN_TYPE_FOREIGN) throw BadCast(\u0026#34;Bad cast when getting value from Wren\u0026#34;); return getSlotForeign\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::shared_ptr\u0026lt;T\u0026gt; f(WrenVM* vm, int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_NULL) return nullptr; else if (type != WrenType::WREN_TYPE_FOREIGN) throw BadCast(\u0026#34;Bad cast when getting value from Wren\u0026#34;); return getSlotForeign\u0026lt;T\u0026gt;(vm, idx); } }; template \u0026lt;\u0026gt; inline Handle getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_UNKNOWN\u0026gt;(vm, idx); return Handle(getSharedVm(vm), wrenGetSlotHandle(vm, idx)); } template \u0026lt;\u0026gt; inline std::string getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_STRING\u0026gt;(vm, idx); return std::string(wrenGetSlotString(vm, idx)); } template \u0026lt;\u0026gt; inline std::nullptr_t getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NULL\u0026gt;(vm, idx); return nullptr; } template \u0026lt;\u0026gt; inline bool getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_BOOL\u0026gt;(vm, idx); return wrenGetSlotBool(vm, idx); } template \u0026lt;\u0026gt; inline int8_t getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;int8_t\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline char getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;char\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline int getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;int\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline short getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;short\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline long getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;long\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline unsigned char getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;unsigned char\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline unsigned long getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;unsigned long\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline unsigned short getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;unsigned short\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline unsigned getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;unsigned\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline long long getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;long long\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline unsigned long long getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;unsigned long long\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline float getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;float\u0026gt;(wrenGetSlotDouble(vm, idx)); } template \u0026lt;\u0026gt; inline double getSlot(WrenVM* vm, int idx) { validate\u0026lt;WrenType::WREN_TYPE_NUM\u0026gt;(vm, idx); return static_cast\u0026lt;double\u0026gt;(wrenGetSlotDouble(vm, idx)); } #define WRENBIND17_POP_HELPER(Type) \\ template \u0026lt;\u0026gt; struct PopHelper\u0026lt;const Type\u0026amp;\u0026gt; { \\ static inline Type f(WrenVM* vm, int idx) { \\ return getSlot\u0026lt;Type\u0026gt;(vm, idx); \\ } \\ };  WRENBIND17_POP_HELPER(std::string) WRENBIND17_POP_HELPER(std::nullptr_t) WRENBIND17_POP_HELPER(bool) WRENBIND17_POP_HELPER(int8_t) WRENBIND17_POP_HELPER(char) WRENBIND17_POP_HELPER(int) WRENBIND17_POP_HELPER(short) WRENBIND17_POP_HELPER(long) WRENBIND17_POP_HELPER(unsigned long) WRENBIND17_POP_HELPER(unsigned) WRENBIND17_POP_HELPER(long long) WRENBIND17_POP_HELPER(unsigned long long) WRENBIND17_POP_HELPER(unsigned short) WRENBIND17_POP_HELPER(unsigned char) WRENBIND17_POP_HELPER(float) WRENBIND17_POP_HELPER(double) } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':28,'href':'/wrenbind17/files/push_8hpp/','title':"include/wrenbind17/push.hpp",'section':"Files",'content':"include/wrenbind17/push.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;exception.hpp\u0026#34;#include \u0026#34;object.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  void getClassType(WrenVM* vm, std::string\u0026amp; module, std::string\u0026amp; name, size_t hash); bool isClassRegistered(WrenVM* vm, const size_t hash); detail::ForeignPtrConvertor* getClassCast(WrenVM* vm, size_t hash, size_t other); namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper; template \u0026lt;typename T\u0026gt; void pushAsConstRef(WrenVM* vm, int idx, const T\u0026amp; value) { static_assert(!std::is_same\u0026lt;int, typename std::remove_const\u0026lt;T\u0026gt;::type\u0026gt;(), \u0026#34;type can\u0026#39;t be int\u0026#34;); static_assert(!std::is_same\u0026lt;std::string, typename std::remove_const\u0026lt;T\u0026gt;::type\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); try { std::string module; std::string klass; getClassType(vm, module, klass, typeid(T).hash_code()); wrenEnsureSlots(vm, idx + 1); wrenGetVariable(vm, module.c_str(), klass.c_str(), idx); auto memory = wrenSetSlotNewForeign(vm, idx, idx, sizeof(ForeignObject\u0026lt;T\u0026gt;)); auto* foreign = new (memory) ForeignObject\u0026lt;T\u0026gt;(std::make_shared\u0026lt;T\u0026gt;(value)); (void)foreign; } catch (std::out_of_range\u0026amp; e) { (void)e; throw BadCast(\u0026#34;Class type not registered in Wren VM\u0026#34;); } } template \u0026lt;typename T\u0026gt; void pushAsMove(WrenVM* vm, int idx, T\u0026amp;\u0026amp; value) { static_assert(!std::is_same\u0026lt;int, T\u0026gt;(), \u0026#34;type can\u0026#39;t be int\u0026#34;); static_assert(!std::is_same\u0026lt;std::string, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); try { std::string module; std::string klass; getClassType(vm, module, klass, typeid(T).hash_code()); wrenEnsureSlots(vm, idx + 1); wrenGetVariable(vm, module.c_str(), klass.c_str(), idx); auto memory = wrenSetSlotNewForeign(vm, idx, idx, sizeof(ForeignObject\u0026lt;T\u0026gt;)); auto* foreign = new (memory) ForeignObject\u0026lt;T\u0026gt;(std::make_shared\u0026lt;T\u0026gt;(std::move(value))); (void)foreign; } catch (std::out_of_range\u0026amp; e) { (void)e; throw BadCast(\u0026#34;Class type not registered in Wren VM\u0026#34;); } } template \u0026lt;typename T\u0026gt; void pushAsPtr(WrenVM* vm, int idx, T* value) { static_assert(!std::is_same\u0026lt;int, T\u0026gt;(), \u0026#34;type can\u0026#39;t be int\u0026#34;); static_assert(!std::is_same\u0026lt;std::string, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); try { std::string module; std::string klass; getClassType(vm, module, klass, typeid(T).hash_code()); wrenEnsureSlots(vm, idx + 1); wrenGetVariable(vm, module.c_str(), klass.c_str(), idx); auto memory = wrenSetSlotNewForeign(vm, idx, idx, sizeof(ForeignObject\u0026lt;T\u0026gt;)); auto* foreign = new (memory) ForeignObject\u0026lt;T\u0026gt;(std::shared_ptr\u0026lt;T\u0026gt;(value, [](T* t) {})); (void)foreign; } catch (std::out_of_range\u0026amp; e) { (void)e; throw BadCast(\u0026#34;Class type not registered in Wren VM\u0026#34;); } } template \u0026lt;typename T\u0026gt; struct PushHelper { static inline void f(WrenVM* vm, int idx, const T\u0026amp; value) { pushAsConstRef(vm, idx, value); } static inline void f(WrenVM* vm, int idx, T\u0026amp;\u0026amp; value) { pushAsMove(vm, idx, std::move(value)); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const T\u0026gt; { static inline void f(WrenVM* vm, int idx, const T value) { PushHelper\u0026lt;T*\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;T*\u0026gt; { static inline void f(WrenVM* vm, int idx, T* value) { pushAsPtr(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const T*\u0026gt; { static inline void f(WrenVM* vm, int idx, const T* value) { PushHelper\u0026lt;T*\u0026gt;::f(vm, idx, const_cast\u0026lt;T*\u0026gt;(value)); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const T*\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const T*\u0026amp; value) { PushHelper\u0026lt;T*\u0026gt;::f(vm, idx, const_cast\u0026lt;T*\u0026gt;(value)); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;T\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, T\u0026amp; value) { PushHelper\u0026lt;T\u0026gt;::f(vm, idx, static_cast\u0026lt;const T\u0026amp;\u0026gt;(value)); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const T\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const T\u0026amp; value) { PushHelper\u0026lt;T\u0026gt;::f(vm, idx, static_cast\u0026lt;const T\u0026amp;\u0026gt;(value)); } }; // ============================================================================================================  // BASIC TYPES  // ============================================================================================================  #define WRENBIND17_PUSH_HELPER(T, FUNC) \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;T\u0026gt;::f(WrenVM* vm, int idx, const T\u0026amp; value) { \\ FUNC; \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;T\u0026gt;::f(WrenVM* vm, int idx, T\u0026amp;\u0026amp; value) { \\ FUNC; \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;const T\u0026gt;::f(WrenVM* vm, int idx, const T value) { \\ FUNC; \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;T\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, T\u0026amp; value) { \\ FUNC; \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;const T\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, const T\u0026amp; value) { \\ FUNC; \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;T*\u0026gt;::f(WrenVM* vm, int idx, T* value) { \\ PushHelper\u0026lt;T\u0026gt;::f(vm, idx, *value); \\ } \\ template \u0026lt;\u0026gt; inline void PushHelper\u0026lt;const T*\u0026gt;::f(WrenVM* vm, int idx, const T* value) { \\ PushHelper\u0026lt;T\u0026gt;::f(vm, idx, *value); \\ }  WRENBIND17_PUSH_HELPER(char, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(int8_t, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(short, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(int, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(long, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(long long, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(uint8_t, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(unsigned short, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(unsigned int, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(unsigned long, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(unsigned long long, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(float, wrenSetSlotDouble(vm, idx, static_cast\u0026lt;double\u0026gt;(value))); WRENBIND17_PUSH_HELPER(double, wrenSetSlotDouble(vm, idx, value)); WRENBIND17_PUSH_HELPER(bool, wrenSetSlotBool(vm, idx, value)); WRENBIND17_PUSH_HELPER(std::nullptr_t, wrenSetSlotNull(vm, idx)); template \u0026lt;\u0026gt; struct PushHelper\u0026lt;std::string\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::string value) { wrenSetSlotString(vm, idx, value.c_str()); } }; template \u0026lt;size_t N\u0026gt; struct PushHelper\u0026lt;const char (\u0026amp;)[N]\u0026gt; { static inline void f(WrenVM* vm, int idx, const char (\u0026amp;value)[N]) { wrenSetSlotString(vm, idx, value); } }; template \u0026lt;size_t N\u0026gt; struct PushHelper\u0026lt;char (\u0026amp;)[N]\u0026gt; { static inline void f(WrenVM* vm, int idx, char (\u0026amp;value)[N]) { wrenSetSlotString(vm, idx, value); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;const char*\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const char*\u0026amp; value) { wrenSetSlotString(vm, idx, value); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;char*\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, char*\u0026amp; value) { wrenSetSlotString(vm, idx, value); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;const std::string\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::string value) { wrenSetSlotString(vm, idx, value.c_str()); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;std::string\u0026amp;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::string\u0026amp;\u0026amp; value) { wrenSetSlotString(vm, idx, value.c_str()); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;std::string\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::string\u0026amp; value) { wrenSetSlotString(vm, idx, value.c_str()); } }; template \u0026lt;\u0026gt; struct PushHelper\u0026lt;const std::string\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::string\u0026amp; value) { wrenSetSlotString(vm, idx, value.c_str()); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::shared_ptr\u0026lt;T\u0026gt; value) { static_assert(!std::is_same\u0026lt;std::string, T\u0026gt;(), \u0026#34;type can\u0026#39;t be std::string\u0026#34;); static_assert(!is_shared_ptr\u0026lt;T\u0026gt;::value, \u0026#34;type can\u0026#39;t be shared_ptr\u0026lt;T\u0026gt;\u0026#34;); try { std::string module; std::string klass; getClassType(vm, module, klass, typeid(T).hash_code()); wrenEnsureSlots(vm, idx + 1); wrenGetVariable(vm, module.c_str(), klass.c_str(), idx); auto memory = wrenSetSlotNewForeign(vm, idx, idx, sizeof(ForeignObject\u0026lt;T\u0026gt;)); auto* foreign = new (memory) ForeignObject\u0026lt;T\u0026gt;(value); (void)foreign; } catch (std::out_of_range\u0026amp; e) { (void)e; throw BadCast(\u0026#34;Class type not registered in Wren VM\u0026#34;); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::shared_ptr\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::shared_ptr\u0026lt;T\u0026gt; value) { PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp; value) { PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, std::move(value)); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::shared_ptr\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename Iter\u0026gt; inline void loopAndPushIterable(WrenVM* vm, const int idx, Iter begin, Iter end) { using T = typename std::iterator_traits\u0026lt;Iter\u0026gt;::value_type; wrenSetSlotNewList(vm, idx); auto i = 0; for (auto it = begin; it != end; ++it) { PushHelper\u0026lt;T\u0026gt;::f(vm, idx + 1, *it); wrenInsertInList(vm, idx, i++, idx + 1); } } template \u0026lt;typename Iter\u0026gt; inline void loopAndPushKeyPair(WrenVM* vm, const int idx, Iter begin, Iter end) { using T = typename std::iterator_traits\u0026lt;Iter\u0026gt;::value_type; using Key = typename T::first_type; using Value = typename T::second_type; wrenSetSlotNewMap(vm, idx); wrenEnsureSlots(vm, 3); for (auto it = begin; it != end; ++it) { PushHelper\u0026lt;Key\u0026gt;::f(vm, idx + 1, std::forward\u0026lt;Key\u0026gt;(it-\u0026gt;first)); PushHelper\u0026lt;Value\u0026gt;::f(vm, idx + 2, std::forward\u0026lt;Value\u0026gt;(it-\u0026gt;second)); wrenSetMapValue(vm, idx, idx + 1, idx + 2); } } } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':29,'href':'/wrenbind17/files/std_8hpp/','title':"include/wrenbind17/std.hpp",'section':"Files",'content':"include/wrenbind17/std.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::StdVectorBindings   class wrenbind17::StdListBindings   class wrenbind17::AbstractMapBindings    Source code #  #pragma once  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;list\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt; #include \u0026#34;module.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T, typename = void\u0026gt; struct is_equality_comparable : std::false_type {}; template \u0026lt;typename T\u0026gt; struct is_equality_comparable\u0026lt; T, typename std::enable_if\u0026lt;true, decltype(std::declval\u0026lt;T\u0026amp;\u0026gt;() == std::declval\u0026lt;T\u0026amp;\u0026gt;(), (void)0)\u0026gt;::type\u0026gt; : std::true_type {}; } // namespace detail  template \u0026lt;typename T, typename T2 = void\u0026gt; class StdVectorHelper; template \u0026lt;typename T\u0026gt; class StdVectorHelper\u0026lt;T, typename std::enable_if\u0026lt;detail::is_equality_comparable\u0026lt;T\u0026gt;::value\u0026gt;::type\u0026gt; { public: static bool contains(std::vector\u0026lt;T\u0026gt;\u0026amp; self, const T\u0026amp; value) { return std::find(self.begin(), self.end(), value) != self.end(); } }; template \u0026lt;typename T\u0026gt; class StdVectorHelper\u0026lt;T, typename std::enable_if\u0026lt;!detail::is_equality_comparable\u0026lt;T\u0026gt;::value\u0026gt;::type\u0026gt; { public: static bool contains(std::vector\u0026lt;T\u0026gt;\u0026amp; self, const T\u0026amp; value) { return std::find_if(self.begin(), self.end(), [\u0026amp;](const T\u0026amp; e) -\u0026gt; bool { return \u0026amp;e == \u0026amp;value; }) != self.end(); } }; #endif  template \u0026lt;typename T\u0026gt; class StdVectorBindings { public: typedef typename std::vector\u0026lt;T\u0026gt;::iterator Iterator; typedef typename std::vector\u0026lt;T\u0026gt; Vector; static void setIndex(Vector\u0026amp; self, size_t index, T value) { self[index] = std::move(value); } static const T\u0026amp; getIndex(Vector\u0026amp; self, size_t index) { return self[index]; } static void add(Vector\u0026amp; self, T value) { self.push_back(std::move(value)); } static std::variant\u0026lt;bool, Iterator\u0026gt; iterate(Vector\u0026amp; self, std::variant\u0026lt;std::nullptr_t, Iterator\u0026gt; other) { if (other.index() == 1) { auto it = std::get\u0026lt;Iterator\u0026gt;(other); ++it; if (it != self.end()) { return {it}; } return {false}; } else { if (self.empty()) return {false}; return {self.begin()}; } } static const T\u0026amp; iteratorValue(Vector\u0026amp; self, std::shared_ptr\u0026lt;Iterator\u0026gt; other) { auto\u0026amp; it = *other; return *it; } static size_t count(Vector\u0026amp; self) { return self.size(); } static T removeAt(Vector\u0026amp; self, int32_t index) { if (index == -1) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } else { if (index \u0026lt; 0) { index = static_cast\u0026lt;int32_t\u0026gt;(self.size()) + index; } if (index \u0026gt; static_cast\u0026lt;int32_t\u0026gt;(self.size())) { throw std::out_of_range(\u0026#34;invalid index\u0026#34;); } else if (index == static_cast\u0026lt;int32_t\u0026gt;(self.size())) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } else { auto ret = std::move(self.at(index)); self.erase(self.begin() + index); return std::move(ret); } } } static void insert(Vector\u0026amp; self, int32_t index, T value) { if (index == -1) { self.push_back(std::move(value)); } else { if (index \u0026lt; 0) { index = static_cast\u0026lt;int32_t\u0026gt;(self.size()) + index; } if (index \u0026gt; static_cast\u0026lt;int32_t\u0026gt;(self.size())) { throw std::out_of_range(\u0026#34;invalid index\u0026#34;); } else if (index == static_cast\u0026lt;int32_t\u0026gt;(self.size())) { self.push_back(std::move(value)); } else { auto it = self.begin() + index; self.insert(it, std::move(value)); } } } static bool contains(Vector\u0026amp; self, const T\u0026amp; value) { // return std::find(self.begin(), self.end(), value) != self.end();  return StdVectorHelper\u0026lt;T\u0026gt;::contains(self, value); } static T pop(Vector\u0026amp; self) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } static void clear(Vector\u0026amp; self) { self.clear(); } static size_t size(Vector\u0026amp; self) { return self.size(); } static bool empty(Vector\u0026amp; self) { return self.empty(); } static void bind(ForeignModule\u0026amp; m, const std::string\u0026amp; name) { auto\u0026amp; iter = m.klass\u0026lt;Iterator\u0026gt;(name + \u0026#34;Iter\u0026#34;); iter.ctor(); auto\u0026amp; cls = m.klass\u0026lt;Vector\u0026gt;(name); cls.ctor(); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::getIndex\u0026gt;(OPERATOR_GET_INDEX); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::setIndex\u0026gt;(OPERATOR_SET_INDEX); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::add\u0026gt;(\u0026#34;add\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::iterate\u0026gt;(\u0026#34;iterate\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::iteratorValue\u0026gt;(\u0026#34;iteratorValue\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::removeAt\u0026gt;(\u0026#34;removeAt\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::insert\u0026gt;(\u0026#34;insert\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::contains\u0026gt;(\u0026#34;contains\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::pop\u0026gt;(\u0026#34;pop\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::clear\u0026gt;(\u0026#34;clear\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::size\u0026gt;(\u0026#34;size\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::empty\u0026gt;(\u0026#34;empty\u0026#34;); cls.template propReadonlyExt\u0026lt;\u0026amp;StdVectorBindings\u0026lt;T\u0026gt;::count\u0026gt;(\u0026#34;count\u0026#34;); } }; template \u0026lt;typename T\u0026gt; class StdListBindings { public: typedef typename std::list\u0026lt;T\u0026gt;::iterator Iterator; typedef typename std::list\u0026lt;T\u0026gt; List; static void setIndex(List\u0026amp; self, size_t index, T value) { auto it = self.begin(); std::advance(it, index); *it = std::move(value); } static const T\u0026amp; getIndex(List\u0026amp; self, size_t index) { auto it = self.begin(); std::advance(it, index); return *it; } static void add(List\u0026amp; self, T value) { self.push_back(std::move(value)); } static std::variant\u0026lt;bool, Iterator\u0026gt; iterate(List\u0026amp; self, std::variant\u0026lt;std::nullptr_t, Iterator\u0026gt; other) { if (other.index() == 1) { auto it = std::get\u0026lt;Iterator\u0026gt;(other); ++it; if (it != self.end()) { return {it}; } return {false}; } else { if (self.empty()) return {false}; return {self.begin()}; } } static const T\u0026amp; iteratorValue(List\u0026amp; self, std::shared_ptr\u0026lt;Iterator\u0026gt; other) { auto\u0026amp; it = *other; return *it; } static size_t count(List\u0026amp; self) { return self.size(); } static T removeAt(List\u0026amp; self, int32_t index) { if (index == -1) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } else { if (index \u0026lt; 0) { index = static_cast\u0026lt;int32_t\u0026gt;(self.size()) + index; } if (index \u0026gt; static_cast\u0026lt;int32_t\u0026gt;(self.size())) { throw std::out_of_range(\u0026#34;invalid index\u0026#34;); } else if (index == static_cast\u0026lt;int32_t\u0026gt;(self.size())) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } else { auto it = self.begin(); std::advance(it, index); auto ret = std::move(*it); self.erase(it); return std::move(ret); } } } static void insert(List\u0026amp; self, int32_t index, T value) { if (index == -1) { self.push_back(std::move(value)); } else { if (index \u0026lt; 0) { index = static_cast\u0026lt;int32_t\u0026gt;(self.size()) + index; } if (index \u0026gt; static_cast\u0026lt;int32_t\u0026gt;(self.size())) { throw std::out_of_range(\u0026#34;invalid index\u0026#34;); } else if (index == static_cast\u0026lt;int32_t\u0026gt;(self.size())) { self.push_back(std::move(value)); } else { auto it = self.begin(); std::advance(it, index); self.insert(it, std::move(value)); } } } static bool contains(List\u0026amp; self, const T\u0026amp; value) { return std::find(self.begin(), self.end(), value) != self.end(); } static T pop(List\u0026amp; self) { auto ret = std::move(self.back()); self.pop_back(); return std::move(ret); } static void clear(List\u0026amp; self) { self.clear(); } static size_t size(List\u0026amp; self) { return self.size(); } static bool empty(List\u0026amp; self) { return self.empty(); } static void bind(ForeignModule\u0026amp; m, const std::string\u0026amp; name) { auto\u0026amp; iter = m.klass\u0026lt;Iterator\u0026gt;(name + \u0026#34;Iter\u0026#34;); iter.ctor(); auto\u0026amp; cls = m.klass\u0026lt;List\u0026gt;(name); cls.ctor(); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::getIndex\u0026gt;(OPERATOR_GET_INDEX); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::setIndex\u0026gt;(OPERATOR_SET_INDEX); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::add\u0026gt;(\u0026#34;add\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::iterate\u0026gt;(\u0026#34;iterate\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::iteratorValue\u0026gt;(\u0026#34;iteratorValue\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::removeAt\u0026gt;(\u0026#34;removeAt\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::insert\u0026gt;(\u0026#34;insert\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::contains\u0026gt;(\u0026#34;contains\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::pop\u0026gt;(\u0026#34;pop\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::clear\u0026gt;(\u0026#34;clear\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::size\u0026gt;(\u0026#34;size\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::empty\u0026gt;(\u0026#34;empty\u0026#34;); cls.template propReadonlyExt\u0026lt;\u0026amp;StdListBindings\u0026lt;T\u0026gt;::count\u0026gt;(\u0026#34;count\u0026#34;); } }; template \u0026lt;typename Map\u0026gt; class AbstractMapBindings { public: typedef typename Map::key_type K; typedef typename Map::mapped_type T; typedef typename Map::iterator Iterator; typedef typename Map::value_type Pair; static void setIndex(Map\u0026amp; self, const K\u0026amp; key, T value) { self[key] = std::move(value); } static T\u0026amp; getIndex(Map\u0026amp; self, const K\u0026amp; key) { return self[key]; } static std::variant\u0026lt;T, std::nullptr_t\u0026gt; remove(Map\u0026amp; self, const K\u0026amp; key) { auto it = self.find(key); if (it != self.end()) { auto ret = std::move(it-\u0026gt;second); self.erase(it); return {ret}; } else { return {nullptr}; } } static bool containsKey(Map\u0026amp; self, const K\u0026amp; key) { return self.find(key) != self.end(); } static size_t count(Map\u0026amp; self) { return self.size(); } static void clear(Map\u0026amp; self) { self.clear(); } static size_t size(Map\u0026amp; self) { return self.size(); } static bool empty(Map\u0026amp; self) { return self.empty(); } static std::variant\u0026lt;bool, Iterator\u0026gt; iterate(Map\u0026amp; self, std::variant\u0026lt;std::nullptr_t, Iterator\u0026gt; other) { if (other.index() == 1) { auto it = std::get\u0026lt;Iterator\u0026gt;(other); ++it; if (it != self.end()) { return {it}; } return {false}; } else { return {self.begin()}; } } static Pair iteratorValue(Map\u0026amp; self, std::shared_ptr\u0026lt;Iterator\u0026gt; other) { auto\u0026amp; it = *other; return *it; } static const K\u0026amp; pairKey(Pair\u0026amp; pair) { return pair.first; } static const T\u0026amp; pairValue(Pair\u0026amp; pair) { return pair.second; } static void bind(ForeignModule\u0026amp; m, const std::string\u0026amp; name) { auto\u0026amp; pair = m.klass\u0026lt;Pair\u0026gt;(name + \u0026#34;Pair\u0026#34;); pair.template propReadonlyExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::pairKey\u0026gt;(\u0026#34;key\u0026#34;); pair.template propReadonlyExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::pairValue\u0026gt;(\u0026#34;value\u0026#34;); auto\u0026amp; iter = m.klass\u0026lt;Iterator\u0026gt;(name + \u0026#34;Iter\u0026#34;); iter.ctor(); auto\u0026amp; cls = m.klass\u0026lt;Map\u0026gt;(name); cls.ctor(); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::getIndex\u0026gt;(OPERATOR_GET_INDEX); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::setIndex\u0026gt;(OPERATOR_SET_INDEX); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::remove\u0026gt;(\u0026#34;remove\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::containsKey\u0026gt;(\u0026#34;containsKey\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::iterate\u0026gt;(\u0026#34;iterate\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::iteratorValue\u0026gt;(\u0026#34;iteratorValue\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::clear\u0026gt;(\u0026#34;clear\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::size\u0026gt;(\u0026#34;size\u0026#34;); cls.template funcExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::empty\u0026gt;(\u0026#34;empty\u0026#34;); cls.template propReadonlyExt\u0026lt;\u0026amp;AbstractMapBindings\u0026lt;Map\u0026gt;::count\u0026gt;(\u0026#34;count\u0026#34;); } }; template \u0026lt;typename K, typename V\u0026gt; using StdMapBindings = AbstractMapBindings\u0026lt;std::map\u0026lt;K, V\u0026gt;\u0026gt;; template \u0026lt;typename K, typename V\u0026gt; using StdUnorderedMapBindings = AbstractMapBindings\u0026lt;std::unordered_map\u0026lt;K, V\u0026gt;\u0026gt;; } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':30,'href':'/wrenbind17/files/stddeque_8hpp/','title':"include/wrenbind17/stddeque.hpp",'section':"Files",'content':"include/wrenbind17/stddeque.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::deque\u0026lt;T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::deque\u0026lt;T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::deque\u0026lt;T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::deque\u0026lt;T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::deque\u0026lt;T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::deque\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::deque\u0026lt;T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::deque\u0026lt;T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::deque\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::deque\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_FOREIGN) { return *getSlotForeign\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;(vm, idx).get(); } if (type != WrenType::WREN_TYPE_LIST) throw BadCast(\u0026#34;Bad cast when getting value from Wren expected list\u0026#34;); std::deque\u0026lt;T\u0026gt; res; const auto size = wrenGetListCount(vm, idx); wrenEnsureSlots(vm, 1); for (size_t i = 0; i \u0026lt; size; i++) { wrenGetListElement(vm, idx, static_cast\u0026lt;int\u0026gt;(i), idx + 1); res.push_back(PopHelper\u0026lt;T\u0026gt;::f(vm, idx + 1)); } return res; } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt; { static inline std::deque\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;std::deque\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':31,'href':'/wrenbind17/files/stdlist_8hpp/','title':"include/wrenbind17/stdlist.hpp",'section':"Files",'content':"include/wrenbind17/stdlist.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::list\u0026lt;T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::list\u0026lt;T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::list\u0026lt;T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::list\u0026lt;T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::list\u0026lt;T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::list\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::list\u0026lt;T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::list\u0026lt;T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::list\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::list\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_FOREIGN) { return *getSlotForeign\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt;(vm, idx).get(); } if (type != WrenType::WREN_TYPE_LIST) throw BadCast(\u0026#34;Bad cast when getting value from Wren expected list\u0026#34;); std::list\u0026lt;T\u0026gt; res; const auto size = wrenGetListCount(vm, idx); wrenEnsureSlots(vm, 1); for (size_t i = 0; i \u0026lt; size; i++) { wrenGetListElement(vm, idx, static_cast\u0026lt;int\u0026gt;(i), idx + 1); res.push_back(PopHelper\u0026lt;T\u0026gt;::f(vm, idx + 1)); } return res; } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt; { static inline std::list\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;const std::list\u0026lt;T\u0026gt;\u0026amp;\u0026gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':32,'href':'/wrenbind17/files/stdmap_8hpp/','title':"include/wrenbind17/stdmap.hpp",'section':"Files",'content':"include/wrenbind17/stdmap.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;map\u0026gt;#include \u0026lt;unordered_map\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::map\u0026lt;std::string, T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::map\u0026lt;std::string, T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushKeyPair(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::map\u0026lt;std::string, T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::map\u0026lt;std::string, T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushKeyPair(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::map\u0026lt;std::string, T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::map\u0026lt;std::string, T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushKeyPair(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::unordered_map\u0026lt;std::string, T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::unordered_map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushKeyPair(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::unordered_map\u0026lt;std::string, T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::unordered_map\u0026lt;std::string, T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::unordered_map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushKeyPair(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::unordered_map\u0026lt;std::string, T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::unordered_map\u0026lt;std::string, T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushKeyPair(vm, idx, value.begin(), value.end()); } } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':33,'href':'/wrenbind17/files/stdoptional_8hpp/','title':"include/wrenbind17/stdoptional.hpp",'section':"Files",'content':"include/wrenbind17/stdoptional.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;optional\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::optional\u0026lt;T\u0026gt;\u0026amp; value) { if (value.has_value()) { PushHelper\u0026lt;T\u0026gt;::f(vm, idx, value.value()); } else { PushHelper\u0026lt;std::nullptr_t\u0026gt;::f(vm, idx, nullptr); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::optional\u0026lt;T\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;*\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::optional\u0026lt;T\u0026gt;* value) { PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, *value); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::optional\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::optional\u0026lt;T\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt; { static inline std::optional\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { if (is\u0026lt;std::nullptr_t\u0026gt;(vm, idx)) { return std::nullopt; } else { return PopHelper\u0026lt;T\u0026gt;::f(vm, idx); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::optional\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::optional\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':34,'href':'/wrenbind17/files/stdset_8hpp/','title':"include/wrenbind17/stdset.hpp",'section':"Files",'content':"include/wrenbind17/stdset.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;set\u0026gt;#include \u0026lt;unordered_set\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::set\u0026lt;T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::set\u0026lt;T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::set\u0026lt;T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::set\u0026lt;T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::set\u0026lt;T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::set\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::set\u0026lt;T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::set\u0026lt;T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::set\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::set\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_FOREIGN) { return *getSlotForeign\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;(vm, idx).get(); } if (type != WrenType::WREN_TYPE_LIST) throw BadCast(\u0026#34;Bad cast when getting value from Wren expected list\u0026#34;); std::set\u0026lt;T\u0026gt; res; const auto size = wrenGetListCount(vm, idx); wrenEnsureSlots(vm, 1); res.reserve(size); for (size_t i = 0; i \u0026lt; size; i++) { wrenGetListElement(vm, idx, static_cast\u0026lt;int\u0026gt;(i), idx + 1); res.insert(PopHelper\u0026lt;T\u0026gt;::f(vm, idx + 1)); } return res; } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt; { static inline std::set\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;const std::set\u0026lt;T\u0026gt;\u0026amp;\u0026gt;::f(vm, idx); } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::unordered_set\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::unordered_set\u0026lt;T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::unordered_set\u0026lt;T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::unordered_set\u0026lt;T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::unordered_set\u0026lt;T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::unordered_set\u0026lt;T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::unordered_set\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::unordered_set\u0026lt;T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::unordered_set\u0026lt;T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::set\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::unordered_set\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::set\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_FOREIGN) { return *getSlotForeign\u0026lt;std::unordered_set\u0026lt;T\u0026gt;\u0026gt;(vm, idx).get(); } if (type != WrenType::WREN_TYPE_LIST) throw BadCast(\u0026#34;Bad cast when getting value from Wren expected list\u0026#34;); std::unordered_set\u0026lt;T\u0026gt; res; const auto size = wrenGetListCount(vm, idx); wrenEnsureSlots(vm, 1); res.reserve(size); for (size_t i = 0; i \u0026lt; size; i++) { wrenGetListElement(vm, idx, static_cast\u0026lt;int\u0026gt;(i), idx + 1); res.insert(PopHelper\u0026lt;T\u0026gt;::f(vm, idx + 1)); } return res; } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::unordered_set\u0026lt;T\u0026gt;\u0026gt; { static inline std::set\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;const std::unordered_set\u0026lt;T\u0026gt;\u0026amp;\u0026gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':35,'href':'/wrenbind17/files/stdvariant_8hpp/','title':"include/wrenbind17/stdvariant.hpp",'section':"Files",'content':"include/wrenbind17/stdvariant.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;variant\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename VariantType\u0026gt; inline void loopAndPushVariant(WrenVM* vm, int idx, const VariantType\u0026amp; v, size_t i) { PushHelper\u0026lt;std::nullptr_t\u0026gt;::f(vm, idx, nullptr); } template \u0026lt;typename VariantType, typename T, typename... Ts\u0026gt; inline void loopAndPushVariant(WrenVM* vm, int idx, const VariantType\u0026amp; v, size_t i) { if (v.index() == i) { PushHelper\u0026lt;T\u0026gt;::f(vm, idx, std::get\u0026lt;T\u0026gt;(v)); } else { loopAndPushVariant\u0026lt;VariantType, Ts...\u0026gt;(vm, idx, v, i + 1); } } template \u0026lt;typename... Ts\u0026gt; struct PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::variant\u0026lt;Ts...\u0026gt;\u0026amp; value) { loopAndPushVariant\u0026lt;std::variant\u0026lt;Ts...\u0026gt;, Ts...\u0026gt;(vm, idx, value, 0); } }; template \u0026lt;typename... Ts\u0026gt; struct PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026amp;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::variant\u0026lt;Ts...\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename... Ts\u0026gt; struct PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;*\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::variant\u0026lt;Ts...\u0026gt;* value) { PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026gt;::f(vm, idx, *value); } }; template \u0026lt;typename... Ts\u0026gt; struct PushHelper\u0026lt;const std::variant\u0026lt;Ts...\u0026gt;\u0026amp;\u0026gt; { inline static void f(WrenVM* vm, int idx, const std::variant\u0026lt;Ts...\u0026gt;\u0026amp; value) { PushHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026gt;::f(vm, idx, value); } }; template \u0026lt;typename VariantType\u0026gt; VariantType loopAndFindVariant(WrenVM* vm, int idx) { throw BadCast(\u0026#34;Bad cast when getting variant from Wren\u0026#34;); } template \u0026lt;typename VariantType, typename T, typename... Ts\u0026gt; VariantType loopAndFindVariant(WrenVM* vm, const int idx) { if (CheckSlot\u0026lt;T\u0026gt;::f(vm, idx)) { return {PopHelper\u0026lt;T\u0026gt;::f(vm, idx)}; } return loopAndFindVariant\u0026lt;VariantType, Ts...\u0026gt;(vm, idx); } template \u0026lt;typename... Ts\u0026gt; struct PopHelper\u0026lt;std::variant\u0026lt;Ts...\u0026gt;\u0026gt; { static inline std::variant\u0026lt;Ts...\u0026gt; f(WrenVM* vm, const int idx) { using VariantType = typename std::variant\u0026lt;Ts...\u0026gt;; return loopAndFindVariant\u0026lt;VariantType, Ts...\u0026gt;(vm, idx); } }; template \u0026lt;typename... Ts\u0026gt; struct PopHelper\u0026lt;const std::variant\u0026lt;Ts...\u0026gt;\u0026amp;\u0026gt; { static inline std::variant\u0026lt;Ts...\u0026gt; f(WrenVM* vm, const int idx) { using VariantType = typename std::variant\u0026lt;Ts...\u0026gt;; return loopAndFindVariant\u0026lt;VariantType, Ts...\u0026gt;(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':36,'href':'/wrenbind17/files/stdvector_8hpp/','title':"include/wrenbind17/stdvector.hpp",'section':"Files",'content':"include/wrenbind17/stdvector.hpp #  Namespaces #     Name     wrenbind17    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { #ifndef DOXYGEN_SHOULD_SKIP_THIS  namespace detail { template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { static inline void f(WrenVM* vm, int idx, std::vector\u0026lt;T\u0026gt; value) { if (isClassRegistered(vm, typeid(std::vector\u0026lt;T\u0026gt;).hash_code())) { pushAsMove\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx, std::move(value)); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;std::vector\u0026lt;T\u0026gt;*\u0026gt; { static inline void f(WrenVM* vm, int idx, std::vector\u0026lt;T\u0026gt;* value) { if (isClassRegistered(vm, typeid(std::vector\u0026lt;T\u0026gt;).hash_code())) { pushAsPtr\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value-\u0026gt;begin(), value-\u0026gt;end()); } } }; template \u0026lt;typename T\u0026gt; struct PushHelper\u0026lt;const std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline void f(WrenVM* vm, int idx, const std::vector\u0026lt;T\u0026gt;\u0026amp; value) { if (isClassRegistered(vm, typeid(std::vector\u0026lt;T\u0026gt;).hash_code())) { pushAsConstRef\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx, value); } else { loopAndPushIterable(vm, idx, value.begin(), value.end()); } } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;const std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026gt; { static inline std::vector\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { const auto type = wrenGetSlotType(vm, idx); if (type == WrenType::WREN_TYPE_FOREIGN) { return *getSlotForeign\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;(vm, idx).get(); } if (type != WrenType::WREN_TYPE_LIST) throw BadCast(\u0026#34;Bad cast when getting value from Wren expected list\u0026#34;); std::vector\u0026lt;T\u0026gt; res; const auto size = wrenGetListCount(vm, idx); wrenEnsureSlots(vm, 1); res.reserve(size); for (size_t i = 0; i \u0026lt; size; i++) { wrenGetListElement(vm, idx, static_cast\u0026lt;int\u0026gt;(i), idx + 1); res.push_back(PopHelper\u0026lt;T\u0026gt;::f(vm, idx + 1)); } return res; } }; template \u0026lt;typename T\u0026gt; struct PopHelper\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { static inline std::vector\u0026lt;T\u0026gt; f(WrenVM* vm, const int idx) { return PopHelper\u0026lt;const std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026gt;::f(vm, idx); } }; } // namespace detail #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':37,'href':'/wrenbind17/files/variable_8hpp/','title':"include/wrenbind17/variable.hpp",'section':"Files",'content':"include/wrenbind17/variable.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::Variable Holds some Wren variable which can be a class or class instance.    Source code #  #pragma once  #include \u0026lt;memory\u0026gt; #include \u0026#34;exception.hpp\u0026#34;#include \u0026#34;method.hpp\u0026#34;#include \u0026#34;pop.hpp\u0026#34;#include \u0026#34;push.hpp\u0026#34; namespace wrenbind17 { class Variable { public: Variable() { } Variable(const std::shared_ptr\u0026lt;Handle\u0026gt;\u0026amp; handle) : handle(handle) { } ~Variable() { reset(); } Method func(const std::string\u0026amp; signature) { if (const auto ptr = handle-\u0026gt;getVmWeak().lock()) { auto* h = wrenMakeCallHandle(ptr.get(), signature.c_str()); return Method(handle, std::make_shared\u0026lt;Handle\u0026gt;(ptr, h)); } else { throw RuntimeError(\u0026#34;Invalid handle\u0026#34;); } } Handle\u0026amp; getHandle() { return *handle; } const Handle\u0026amp; getHandle() const { return *handle; } operator bool() const { return handle.operator bool(); } void reset() { handle.reset(); } private: std::shared_ptr\u0026lt;Handle\u0026gt; handle; }; template \u0026lt;\u0026gt; inline Variable detail::getSlot\u0026lt;Variable\u0026gt;(WrenVM* vm, const int idx) { validate\u0026lt;WrenType::WREN_TYPE_UNKNOWN\u0026gt;(vm, idx); return Variable(std::make_shared\u0026lt;Handle\u0026gt;(getSharedVm(vm), wrenGetSlotHandle(vm, idx))); } template \u0026lt;\u0026gt; inline bool detail::is\u0026lt;Variable\u0026gt;(WrenVM* vm, const int idx) { return wrenGetSlotType(vm, idx) == WREN_TYPE_UNKNOWN; } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Variable\u0026gt;::f(WrenVM* vm, int idx, const Variable\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Variable\u0026gt;::f(WrenVM* vm, int idx, Variable\u0026amp;\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;const Variable\u0026gt;::f(WrenVM* vm, int idx, const Variable value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;const Variable\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, const Variable\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } template \u0026lt;\u0026gt; inline void detail::PushHelper\u0026lt;Variable\u0026amp;\u0026gt;::f(WrenVM* vm, int idx, Variable\u0026amp; value) { wrenSetSlotHandle(value.getHandle().getVm(), idx, value.getHandle().getHandle()); } } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':38,'href':'/wrenbind17/files/vm_8hpp/','title':"include/wrenbind17/vm.hpp",'section':"Files",'content':"include/wrenbind17/vm.hpp #  Namespaces #     Name     wrenbind17    Classes #      Name     class wrenbind17::VM Holds the entire Wren VM from which all of the magic happens.   class wrenbind17::VM::Data    Source code #  #pragma once  #include \u0026lt;wren.hpp\u0026gt; #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;cassert\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;memory\u0026gt; #include \u0026#34;exception.hpp\u0026#34;#include \u0026#34;map.hpp\u0026#34;#include \u0026#34;module.hpp\u0026#34;#include \u0026#34;variable.hpp\u0026#34; #ifndef DOXYGEN_SHOULD_SKIP_THIS namespace std { template \u0026lt;\u0026gt; struct hash\u0026lt;std::pair\u0026lt;size_t, size_t\u0026gt;\u0026gt; { inline size_t operator()(const std::pair\u0026lt;size_t, size_t\u0026gt;\u0026amp; v) const { const std::hash\u0026lt;size_t\u0026gt; hasher; return hasher(v.first) ^ hasher(v.second); } }; } // namespace std #endif  namespace wrenbind17 { typedef std::function\u0026lt;void(const char*)\u0026gt; PrintFn; typedef std::function\u0026lt;std::string(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name)\u0026gt; LoadFileFn; class VM { public: inline explicit VM(std::vector\u0026lt;std::string\u0026gt; paths = {\u0026#34;./\u0026#34;}, const size_t initHeap = 1024 * 1024, const size_t minHeap = 1024 * 1024 * 10, const int heapGrowth = 50) : data(std::make_unique\u0026lt;Data\u0026gt;()) { data-\u0026gt;paths = std::move(paths); data-\u0026gt;printFn = [](const char* text) -\u0026gt; void { std::cout \u0026lt;\u0026lt; text; }; data-\u0026gt;loadFileFn = [](const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name) -\u0026gt; std::string { for (const auto\u0026amp; path : paths) { const auto test = path + \u0026#34;/\u0026#34; + std::string(name) + \u0026#34;.wren\u0026#34;; std::ifstream t(test); if (!t) continue; std::string source((std::istreambuf_iterator\u0026lt;char\u0026gt;(t)), std::istreambuf_iterator\u0026lt;char\u0026gt;()); return source; } throw NotFound(); }; wrenInitConfiguration(\u0026amp;data-\u0026gt;config); data-\u0026gt;config.initialHeapSize = initHeap; data-\u0026gt;config.minHeapSize = minHeap; data-\u0026gt;config.heapGrowthPercent = heapGrowth; data-\u0026gt;config.userData = data.get(); #if WREN_VERSION_NUMBER \u0026gt;= 4000 // \u0026gt;= 0.4.0  data-\u0026gt;config.reallocateFn = [](void* memory, size_t newSize, void* userData) -\u0026gt; void* { return std::realloc(memory, newSize); }; data-\u0026gt;config.loadModuleFn = [](WrenVM* vm, const char* name) -\u0026gt; WrenLoadModuleResult { auto res = WrenLoadModuleResult(); auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); const auto mod = self.modules.find(name); if (mod != self.modules.end()) { auto source = mod-\u0026gt;second.str(); auto buffer = new char[source.size() + 1]; std::memcpy(buffer, \u0026amp;source[0], source.size() + 1); res.source = buffer; res.onComplete = [](WrenVM* vm, const char* name, struct WrenLoadModuleResult result) { delete[] result.source; }; return res; } try { auto source = self.loadFileFn(self.paths, std::string(name)); auto buffer = new char[source.size() + 1]; std::memcpy(buffer, \u0026amp;source[0], source.size() + 1); res.source = buffer; res.onComplete = [](WrenVM* vm, const char* name, struct WrenLoadModuleResult result) { delete[] result.source; }; } catch (std::exception\u0026amp; e) { (void)e; } return res; }; #else // \u0026lt; 0.4.0  data-\u0026gt;config.reallocateFn = std::realloc; data-\u0026gt;config.loadModuleFn = [](WrenVM* vm, const char* name) -\u0026gt; char* { auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); const auto mod = self.modules.find(name); if (mod != self.modules.end()) { auto source = mod-\u0026gt;second.str(); auto buffer = new char[source.size() + 1]; std::memcpy(buffer, \u0026amp;source[0], source.size() + 1); return buffer; } try { auto source = self.loadFileFn(self.paths, std::string(name)); auto buffer = new char[source.size() + 1]; std::memcpy(buffer, \u0026amp;source[0], source.size() + 1); return buffer; } catch (std::exception\u0026amp; e) { (void)e; return nullptr; } }; #endif // WREN_VERSION_NUMBER \u0026gt;= 4000  data-\u0026gt;config.bindForeignMethodFn = [](WrenVM* vm, const char* module, const char* className, const bool isStatic, const char* signature) -\u0026gt; WrenForeignMethodFn { auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); try { auto\u0026amp; found = self.modules.at(module); auto\u0026amp; klass = found.findKlass(className); return klass.findSignature(signature, isStatic); } catch (...) { std::cerr \u0026lt;\u0026lt; \u0026#34;Wren foreign method \u0026#34; \u0026lt;\u0026lt; signature \u0026lt;\u0026lt; \u0026#34; not found in C++\u0026#34; \u0026lt;\u0026lt; std::endl; std::abort(); return nullptr; } }; data-\u0026gt;config.bindForeignClassFn = [](WrenVM* vm, const char* module, const char* className) -\u0026gt; WrenForeignClassMethods { auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); try { auto\u0026amp; found = self.modules.at(module); auto\u0026amp; klass = found.findKlass(className); return klass.getAllocators(); } catch (...) { exceptionHandler(vm, std::current_exception()); return WrenForeignClassMethods{nullptr, nullptr}; } }; data-\u0026gt;config.writeFn = [](WrenVM* vm, const char* text) { auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); self.printFn(text); }; data-\u0026gt;config.errorFn = [](WrenVM* vm, WrenErrorType type, const char* module, const int line, const char* message) { auto\u0026amp; self = *reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); std::stringstream ss; switch (type) { case WREN_ERROR_COMPILE: ss \u0026lt;\u0026lt; \u0026#34;Compile error: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; \u0026#34; at \u0026#34; \u0026lt;\u0026lt; module \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; case WREN_ERROR_RUNTIME: if (!self.nextError.empty()) { ss \u0026lt;\u0026lt; \u0026#34;Runtime error: \u0026#34; \u0026lt;\u0026lt; self.nextError \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; self.nextError.clear(); } else { ss \u0026lt;\u0026lt; \u0026#34;Runtime error: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } break; case WREN_ERROR_STACK_TRACE: ss \u0026lt;\u0026lt; \u0026#34; at: \u0026#34; \u0026lt;\u0026lt; module \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; default: break; } self.lastError += ss.str(); }; data-\u0026gt;vm = std::shared_ptr\u0026lt;WrenVM\u0026gt;(wrenNewVM(\u0026amp;data-\u0026gt;config), [](WrenVM* ptr) { wrenFreeVM(ptr); }); } inline VM(const VM\u0026amp; other) = delete; inline VM(VM\u0026amp;\u0026amp; other) noexcept { swap(other); } inline ~VM() = default; inline VM\u0026amp; operator=(const VM\u0026amp; other) = delete; inline VM\u0026amp; operator=(VM\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { swap(other); } return *this; } inline void swap(VM\u0026amp; other) noexcept { std::swap(data, other.data); } inline void runFromSource(const std::string\u0026amp; name, const std::string\u0026amp; code) { const auto result = wrenInterpret(data-\u0026gt;vm.get(), name.c_str(), code.c_str()); if (result != WREN_RESULT_SUCCESS) { throw CompileError(getLastError()); } return; } inline void runFromFile(const std::string\u0026amp; name, const std::string\u0026amp; path) { std::ifstream t(path); if (!t) throw Exception(\u0026#34;Compile error: Failed to open source file\u0026#34;); std::string str((std::istreambuf_iterator\u0026lt;char\u0026gt;(t)), std::istreambuf_iterator\u0026lt;char\u0026gt;()); runFromSource(name, str); } inline void runFromModule(const std::string\u0026amp; name) { const auto source = data-\u0026gt;loadFileFn(data-\u0026gt;paths, name); runFromSource(name, source); } inline Variable find(const std::string\u0026amp; module, const std::string\u0026amp; name) { wrenEnsureSlots(data-\u0026gt;vm.get(), 1); wrenGetVariable(data-\u0026gt;vm.get(), module.c_str(), name.c_str(), 0); auto* handle = wrenGetSlotHandle(data-\u0026gt;vm.get(), 0); if (!handle) throw NotFound(); return Variable(std::make_shared\u0026lt;Handle\u0026gt;(data-\u0026gt;vm, handle)); } inline ForeignModule\u0026amp; module(const std::string\u0026amp; name) { auto it = data-\u0026gt;modules.find(name); if (it == data-\u0026gt;modules.end()) { it = data-\u0026gt;modules.insert(std::make_pair(name, ForeignModule(name, data-\u0026gt;vm.get()))).first; } return it-\u0026gt;second; } inline void addClassType(const std::string\u0026amp; module, const std::string\u0026amp; name, const size_t hash) { data-\u0026gt;addClassType(module, name, hash); } inline void getClassType(std::string\u0026amp; module, std::string\u0026amp; name, const size_t hash) { data-\u0026gt;getClassType(module, name, hash); } inline bool isClassRegistered(const size_t hash) const { return data-\u0026gt;isClassRegistered(hash); } inline void addClassCast(std::shared_ptr\u0026lt;detail::ForeignPtrConvertor\u0026gt; convertor, const size_t hash, const size_t other) { data-\u0026gt;addClassCast(std::move(convertor), hash, other); } inline detail::ForeignPtrConvertor* getClassCast(const size_t hash, const size_t other) { return data-\u0026gt;getClassCast(hash, other); } inline std::string getLastError() { return data-\u0026gt;getLastError(); } inline void setNextError(std::string str) { data-\u0026gt;setNextError(std::move(str)); } inline void setPrintFunc(const PrintFn\u0026amp; fn) { data-\u0026gt;printFn = fn; } inline void setLoadFileFunc(const LoadFileFn\u0026amp; fn) { data-\u0026gt;loadFileFn = fn; } inline void gc() { wrenCollectGarbage(data-\u0026gt;vm.get()); } class Data { public: std::shared_ptr\u0026lt;WrenVM\u0026gt; vm; WrenConfiguration config; std::vector\u0026lt;std::string\u0026gt; paths; std::unordered_map\u0026lt;std::string, ForeignModule\u0026gt; modules; std::unordered_map\u0026lt;size_t, std::string\u0026gt; classToModule; std::unordered_map\u0026lt;size_t, std::string\u0026gt; classToName; std::unordered_map\u0026lt;std::pair\u0026lt;size_t, size_t\u0026gt;, std::shared_ptr\u0026lt;detail::ForeignPtrConvertor\u0026gt;\u0026gt; classCasting; std::string lastError; std::string nextError; PrintFn printFn; LoadFileFn loadFileFn; inline void addClassType(const std::string\u0026amp; module, const std::string\u0026amp; name, const size_t hash) { classToModule.insert(std::make_pair(hash, module)); classToName.insert(std::make_pair(hash, name)); } inline void getClassType(std::string\u0026amp; module, std::string\u0026amp; name, const size_t hash) { module = classToModule.at(hash); name = classToName.at(hash); } inline bool isClassRegistered(const size_t hash) const { return classToModule.find(hash) != classToModule.end(); } inline void addClassCast(std::shared_ptr\u0026lt;detail::ForeignPtrConvertor\u0026gt; convertor, const size_t hash, const size_t other) { classCasting.insert(std::make_pair(std::make_pair(hash, other), std::move(convertor))); } inline detail::ForeignPtrConvertor* getClassCast(const size_t hash, const size_t other) { return classCasting.at(std::pair(hash, other)).get(); } inline std::string getLastError() { std::string str; std::swap(str, lastError); return str; } inline void setNextError(std::string str) { nextError = std::move(str); } }; private: std::unique_ptr\u0026lt;Data\u0026gt; data; }; #ifndef DOXYGEN_SHOULD_SKIP_THIS  inline std::shared_ptr\u0026lt;WrenVM\u0026gt; getSharedVm(WrenVM* vm) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); assert(self-\u0026gt;vm); return self-\u0026gt;vm; } inline void addClassType(WrenVM* vm, const std::string\u0026amp; module, const std::string\u0026amp; name, const size_t hash) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); self-\u0026gt;addClassType(module, name, hash); } inline void getClassType(WrenVM* vm, std::string\u0026amp; module, std::string\u0026amp; name, const size_t hash) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); self-\u0026gt;getClassType(module, name, hash); } inline bool isClassRegistered(WrenVM* vm, const size_t hash) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); return self-\u0026gt;isClassRegistered(hash); } inline void addClassCast(WrenVM* vm, std::shared_ptr\u0026lt;detail::ForeignPtrConvertor\u0026gt; convertor, const size_t hash, const size_t other) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); self-\u0026gt;addClassCast(std::move(convertor), hash, other); } inline detail::ForeignPtrConvertor* getClassCast(WrenVM* vm, const size_t hash, const size_t other) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); return self-\u0026gt;getClassCast(hash, other); } inline std::string getLastError(WrenVM* vm) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); return self-\u0026gt;getLastError(); } inline void setNextError(WrenVM* vm, std::string str) { assert(vm); auto self = reinterpret_cast\u0026lt;VM::Data*\u0026gt;(wrenGetUserData(vm)); self-\u0026gt;setNextError(std::move(str)); } #endif } // namespace wrenbind17  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':39,'href':'/wrenbind17/files/wrenbind17_8hpp/','title':"include/wrenbind17/wrenbind17.hpp",'section':"Files",'content':"include/wrenbind17/wrenbind17.hpp #  Source code #  #pragma once  #include \u0026#34;std.hpp\u0026#34;#include \u0026#34;stddeque.hpp\u0026#34;#include \u0026#34;stdlist.hpp\u0026#34;#include \u0026#34;stdmap.hpp\u0026#34;#include \u0026#34;stdoptional.hpp\u0026#34;#include \u0026#34;stdset.hpp\u0026#34;#include \u0026#34;stdvariant.hpp\u0026#34;#include \u0026#34;stdvector.hpp\u0026#34;#include \u0026#34;vm.hpp\u0026#34; Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':40,'href':'/wrenbind17/modules/','title':"Modules",'section':"",'content':"Modules #   group Wrenbind17 Wren lang binding library for C++17.   Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':41,'href':'/wrenbind17/namespaces/','title':"Namespaces",'section':"",'content':"Namespaces #   namespace std namespace wrenbind17   Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':42,'href':'/wrenbind17/namespaces/namespacestd/','title':"std",'section':"Namespaces",'content':"std #   Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':43,'href':'/wrenbind17/tutorial/','title':"Tutorial",'section':"",'content':"Tutorial #   1. Installation 2. Hello World 3. Call Wren function 4. Supported types 5. Executing from file 6. Custom types 7. Class operators 8. Modules and files 9. Customize VM 10. Fn.new and callbacks 11. STL containers  "});index.add({'id':44,'href':'/wrenbind17/modules/group__wrenbind17/','title':"Wrenbind17",'section':"Modules",'content':"Wrenbind17 #  Wren lang binding library for C++17. ## Classes\n    Name     class wrenbind17::ReturnValue A return value when calling a Wren function (alias Any)   class wrenbind17::Exception   class wrenbind17::NotFound   class wrenbind17::BadCast   class wrenbind17::RuntimeError   class wrenbind17::CompileError   class wrenbind17::ForeignMethod Holds information about a foreign function of a foreign class.   class wrenbind17::ForeignProp Holds information about a foreign property of a foreign class.   class wrenbind17::ForeignKlass A foreign class.   class wrenbind17::ForeignMethodImpl Type specific implementation of foreign method.   class wrenbind17::ForeignPropImpl   class wrenbind17::ForeignKlassImpl   class wrenbind17::Handle Holds a reference to some Wren type.   class wrenbind17::Map Holds native Wren map.   class wrenbind17::Method   class wrenbind17::ForeignModule   class wrenbind17::Variable Holds some Wren variable which can be a class or class instance.   class wrenbind17::VM Holds the entire Wren VM from which all of the magic happens.    Types #      Name     enum ForeignMethodOperator { OPERATOR_GET_INDEX, OPERATOR_SET_INDEX, OPERATOR_SUB, OPERATOR_ADD, OPERATOR_MUL, OPERATOR_DIV, OPERATOR_NEG, OPERATOR_MOD, OPERATOR_EQUAL, OPERATOR_NOT_EQUAL, OPERATOR_GT, OPERATOR_LT, OPERATOR_GT_EQUAL, OPERATOR_LT_EQUAL, OPERATOR_SHIFT_LEFT, OPERATOR_SHIFT_RIGHT, OPERATOR_AND, OPERATOR_XOR, OPERATOR_OR}   using ReturnValue Any An alias of ReturnValue class.   typedef std::function\u0026lt; void(const char *)\u0026gt; PrintFn   typedef std::function\u0026lt; std::string(const std::vector\u0026lt; std::string \u0026gt; \u0026amp;paths, const std::string \u0026amp;name)\u0026gt; LoadFileFn    Types Documentation #  enum ForeignMethodOperator #     Enumerator Value Description     OPERATOR_GET_INDEX     OPERATOR_SET_INDEX     OPERATOR_SUB     OPERATOR_ADD     OPERATOR_MUL     OPERATOR_DIV     OPERATOR_NEG     OPERATOR_MOD     OPERATOR_EQUAL     OPERATOR_NOT_EQUAL     OPERATOR_GT     OPERATOR_LT     OPERATOR_GT_EQUAL     OPERATOR_LT_EQUAL     OPERATOR_SHIFT_LEFT     OPERATOR_SHIFT_RIGHT     OPERATOR_AND     OPERATOR_XOR     OPERATOR_OR      using Any #  using wrenbind17::Any = typedef ReturnValue; An alias of ReturnValue class.\nSee: ReturnValue\ntypedef PrintFn #  typedef std::function\u0026lt;void(const char*)\u0026gt; wrenbind17::PrintFn; typedef LoadFileFn #  typedef std::function\u0026lt;std::string(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name)\u0026gt; wrenbind17::LoadFileFn;  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':45,'href':'/wrenbind17/namespaces/namespacewrenbind17/','title':"wrenbind17",'section':"Namespaces",'content':"wrenbind17 #  Classes #      Name     class wrenbind17::ReturnValue A return value when calling a Wren function (alias Any)   class wrenbind17::Exception   class wrenbind17::NotFound   class wrenbind17::BadCast   class wrenbind17::RuntimeError   class wrenbind17::CompileError   class wrenbind17::ForeignMethod Holds information about a foreign function of a foreign class.   class wrenbind17::ForeignProp Holds information about a foreign property of a foreign class.   class wrenbind17::ForeignKlass A foreign class.   class wrenbind17::ForeignMethodImpl Type specific implementation of foreign method.   class wrenbind17::ForeignPropImpl   class wrenbind17::ForeignKlassImpl   class wrenbind17::Handle Holds a reference to some Wren type.   class wrenbind17::Map Holds native Wren map.   class wrenbind17::Method   class wrenbind17::ForeignModule   class wrenbind17::StdVectorBindings   class wrenbind17::StdListBindings   class wrenbind17::AbstractMapBindings   class wrenbind17::Variable Holds some Wren variable which can be a class or class instance.   class wrenbind17::VM Holds the entire Wren VM from which all of the magic happens.    Types #      Name     enum ForeignMethodOperator { OPERATOR_GET_INDEX, OPERATOR_SET_INDEX, OPERATOR_SUB, OPERATOR_ADD, OPERATOR_MUL, OPERATOR_DIV, OPERATOR_NEG, OPERATOR_MOD, OPERATOR_EQUAL, OPERATOR_NOT_EQUAL, OPERATOR_GT, OPERATOR_LT, OPERATOR_GT_EQUAL, OPERATOR_LT_EQUAL, OPERATOR_SHIFT_LEFT, OPERATOR_SHIFT_RIGHT, OPERATOR_AND, OPERATOR_XOR, OPERATOR_OR}   using ReturnValue Any An alias of ReturnValue class.   template \u0026lt;typename K ,typename V \u0026gt; using AbstractMapBindings\u0026lt; std::map\u0026lt; K, V \u0026gt; \u0026gt; StdMapBindings   template \u0026lt;typename K ,typename V \u0026gt; using AbstractMapBindings\u0026lt; std::unordered_map\u0026lt; K, V \u0026gt; \u0026gt; StdUnorderedMapBindings   typedef std::function\u0026lt; void(const char *)\u0026gt; PrintFn   typedef std::function\u0026lt; std::string(const std::vector\u0026lt; std::string \u0026gt; \u0026amp;paths, const std::string \u0026amp;name)\u0026gt; LoadFileFn    Functions #      Name     void setNextError(WrenVM * vm, std::string str)   std::shared_ptr\u0026lt; WrenVM \u0026gt; getSharedVm(WrenVM * vm)   void addClassType(WrenVM * vm, const std::string \u0026amp; module, const std::string \u0026amp; name, size_t hash)   void addClassCast(WrenVM * vm, std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, size_t hash, size_t other)   void getClassType(WrenVM * vm, std::string \u0026amp; module, std::string \u0026amp; name, size_t hash)   detail::ForeignPtrConvertor * getClassCast(WrenVM * vm, size_t hash, size_t other)    Types Documentation #  enum ForeignMethodOperator #     Enumerator Value Description     OPERATOR_GET_INDEX     OPERATOR_SET_INDEX     OPERATOR_SUB     OPERATOR_ADD     OPERATOR_MUL     OPERATOR_DIV     OPERATOR_NEG     OPERATOR_MOD     OPERATOR_EQUAL     OPERATOR_NOT_EQUAL     OPERATOR_GT     OPERATOR_LT     OPERATOR_GT_EQUAL     OPERATOR_LT_EQUAL     OPERATOR_SHIFT_LEFT     OPERATOR_SHIFT_RIGHT     OPERATOR_AND     OPERATOR_XOR     OPERATOR_OR      using Any #  using wrenbind17::Any = typedef ReturnValue; An alias of ReturnValue class.\nSee: ReturnValue\nusing StdMapBindings #  template \u0026lt;typename K , typename V \u0026gt; using wrenbind17::StdMapBindings = typedef AbstractMapBindings\u0026lt;std::map\u0026lt;K, V\u0026gt; \u0026gt;; using StdUnorderedMapBindings #  template \u0026lt;typename K , typename V \u0026gt; using wrenbind17::StdUnorderedMapBindings = typedef AbstractMapBindings\u0026lt;std::unordered_map\u0026lt;K, V\u0026gt; \u0026gt;; typedef PrintFn #  typedef std::function\u0026lt;void(const char*)\u0026gt; wrenbind17::PrintFn; typedef LoadFileFn #  typedef std::function\u0026lt;std::string(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; paths, const std::string\u0026amp; name)\u0026gt; wrenbind17::LoadFileFn; Functions Documentation #  function setNextError #  void setNextError( WrenVM * vm, std::string str ) function getSharedVm #  std::shared_ptr\u0026lt; WrenVM \u0026gt; getSharedVm( WrenVM * vm ) function addClassType #  void addClassType( WrenVM * vm, const std::string \u0026amp; module, const std::string \u0026amp; name, size_t hash ) function addClassCast #  void addClassCast( WrenVM * vm, std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, size_t hash, size_t other ) function getClassType #  void getClassType( WrenVM * vm, std::string \u0026amp; module, std::string \u0026amp; name, size_t hash ) function getClassCast #  detail::ForeignPtrConvertor * getClassCast( WrenVM * vm, size_t hash, size_t other )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':46,'href':'/wrenbind17/classes/classwrenbind17_1_1_abstract_map_bindings/','title':"wrenbind17::AbstractMapBindings",'section':"Classes",'content':"wrenbind17::AbstractMapBindings #  More\u0026hellip;\n#include \u0026lt;std.hpp\u0026gt;\nPublic Types #      Name     typedef Map::key_type K   typedef Map::mapped_type T   typedef Map::iterator Iterator   typedef Map::value_type Pair    Public Functions #      Name     void setIndex(Map \u0026amp; self, const K \u0026amp; key, T value)   T \u0026amp; getIndex(Map \u0026amp; self, const K \u0026amp; key)   std::variant\u0026lt; T, std::nullptr_t \u0026gt; remove(Map \u0026amp; self, const K \u0026amp; key)   bool containsKey(Map \u0026amp; self, const K \u0026amp; key)   size_t count(Map \u0026amp; self)   void clear(Map \u0026amp; self)   size_t size(Map \u0026amp; self)   bool empty(Map \u0026amp; self)   std::variant\u0026lt; bool, Iterator \u0026gt; iterate(Map \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other)   Pair iteratorValue(Map \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other)   const K \u0026amp; pairKey(Pair \u0026amp; pair)   const T \u0026amp; pairValue(Pair \u0026amp; pair)   void bind(ForeignModule \u0026amp; m, const std::string \u0026amp; name)    Detailed Description #  template \u0026lt;typename Map \u0026gt; class wrenbind17::AbstractMapBindings; Public Types Documentation #  typedef K #  typedef Map::key_type wrenbind17::AbstractMapBindings\u0026lt; Map \u0026gt;::K; typedef T #  typedef Map::mapped_type wrenbind17::AbstractMapBindings\u0026lt; Map \u0026gt;::T; typedef Iterator #  typedef Map::iterator wrenbind17::AbstractMapBindings\u0026lt; Map \u0026gt;::Iterator; typedef Pair #  typedef Map::value_type wrenbind17::AbstractMapBindings\u0026lt; Map \u0026gt;::Pair; Public Functions Documentation #  function setIndex #  static inline void setIndex( Map \u0026amp; self, const K \u0026amp; key, T value ) function getIndex #  static inline T \u0026amp; getIndex( Map \u0026amp; self, const K \u0026amp; key ) function remove #  static inline std::variant\u0026lt; T, std::nullptr_t \u0026gt; remove( Map \u0026amp; self, const K \u0026amp; key ) function containsKey #  static inline bool containsKey( Map \u0026amp; self, const K \u0026amp; key ) function count #  static inline size_t count( Map \u0026amp; self ) function clear #  static inline void clear( Map \u0026amp; self ) function size #  static inline size_t size( Map \u0026amp; self ) function empty #  static inline bool empty( Map \u0026amp; self ) function iterate #  static inline std::variant\u0026lt; bool, Iterator \u0026gt; iterate( Map \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other ) function iteratorValue #  static inline Pair iteratorValue( Map \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other ) function pairKey #  static inline const K \u0026amp; pairKey( Pair \u0026amp; pair ) function pairValue #  static inline const T \u0026amp; pairValue( Pair \u0026amp; pair ) function bind #  static inline void bind( ForeignModule \u0026amp; m, const std::string \u0026amp; name )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':47,'href':'/wrenbind17/classes/classwrenbind17_1_1_bad_cast/','title':"wrenbind17::BadCast",'section':"Classes",'content':"wrenbind17::BadCast #  Module: Wrenbind17\n#include \u0026lt;exception.hpp\u0026gt;\nInherits from wrenbind17::Exception, std::exception\nPublic Functions #      Name      BadCast()    BadCast(std::string msg)    Additional inherited members #  Public Functions inherited from wrenbind17::Exception\n    Name      Exception() =default    Exception(std::string msg)   const char * what() const override    Public Functions Documentation #  function BadCast #  inline BadCast() function BadCast #  inline explicit BadCast( std::string msg )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':48,'href':'/wrenbind17/classes/classwrenbind17_1_1_compile_error/','title':"wrenbind17::CompileError",'section':"Classes",'content':"wrenbind17::CompileError #  Module: Wrenbind17\n#include \u0026lt;exception.hpp\u0026gt;\nInherits from wrenbind17::Exception, std::exception\nPublic Functions #      Name      CompileError(std::string msg)    Additional inherited members #  Public Functions inherited from wrenbind17::Exception\n    Name      Exception() =default    Exception(std::string msg)   const char * what() const override    Public Functions Documentation #  function CompileError #  inline explicit CompileError( std::string msg )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':49,'href':'/wrenbind17/classes/classwrenbind17_1_1_exception/','title':"wrenbind17::Exception",'section':"Classes",'content':"wrenbind17::Exception #  Module: Wrenbind17\n#include \u0026lt;exception.hpp\u0026gt;\nInherits from std::exception\nInherited by wrenbind17::BadCast, wrenbind17::CompileError, wrenbind17::NotFound, wrenbind17::RuntimeError\nPublic Functions #      Name      Exception() =default    Exception(std::string msg)   const char * what() const override    Public Functions Documentation #  function Exception #  Exception() =default function Exception #  inline explicit Exception( std::string msg ) function what #  inline const char * what() const override  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':50,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_klass/','title':"wrenbind17::ForeignKlass",'section':"Classes",'content':"wrenbind17::ForeignKlass #  Module: Wrenbind17\nA foreign class. #include \u0026lt;foreign.hpp\u0026gt;\nInherited by wrenbind17::ForeignKlassImpl\u0026lt; T \u0026gt;\nPublic Functions #      Name      ForeignKlass(std::string name)   virtual ~ForeignKlass() =default    ForeignKlass(const ForeignKlass \u0026amp; other)   virtual void generate(std::ostream \u0026amp; os) const =0   ForeignMethod \u0026amp; findFunc(const std::string \u0026amp; name, const bool isStatic)Looks up a foreign function that belongs to this class.   ForeignProp \u0026amp; findProp(const std::string \u0026amp; name, const bool isStatic)Looks up a foreign property that belongs to this class.   WrenForeignMethodFn findSignature(const std::string \u0026amp; signature, const bool isStatic)Finds a function based on the signature.   const std::string \u0026amp; getName() constReturns the name of this foreign class.   WrenForeignClassMethods \u0026amp; getAllocators()Returns a struct with pointers to the allocator and deallocator.    Protected Attributes #      Name     std::string name   std::string ctorDef   std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignMethod \u0026gt; \u0026gt; methods   std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignProp \u0026gt; \u0026gt; props   WrenForeignClassMethods allocators    Public Functions Documentation #  function ForeignKlass #  inline ForeignKlass( std::string name ) function ~ForeignKlass #  virtual ~ForeignKlass() =default function ForeignKlass #  ForeignKlass( const ForeignKlass \u0026amp; other ) function generate #  virtual void generate( std::ostream \u0026amp; os ) const =0 Reimplemented by: wrenbind17::ForeignKlassImpl::generate\nfunction findFunc #  inline ForeignMethod \u0026amp; findFunc( const std::string \u0026amp; name, const bool isStatic ) Looks up a foreign function that belongs to this class.\nfunction findProp #  inline ForeignProp \u0026amp; findProp( const std::string \u0026amp; name, const bool isStatic ) Looks up a foreign property that belongs to this class.\nfunction findSignature #  inline WrenForeignMethodFn findSignature( const std::string \u0026amp; signature, const bool isStatic ) Finds a function based on the signature.\nfunction getName #  inline const std::string \u0026amp; getName() const Returns the name of this foreign class.\nfunction getAllocators #  inline WrenForeignClassMethods \u0026amp; getAllocators() Returns a struct with pointers to the allocator and deallocator.\nProtected Attributes Documentation #  variable name #  std::string name; variable ctorDef #  std::string ctorDef; variable methods #  std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignMethod \u0026gt; \u0026gt; methods; variable props #  std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignProp \u0026gt; \u0026gt; props; variable allocators #  WrenForeignClassMethods allocators;  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':51,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_klass_impl/','title':"wrenbind17::ForeignKlassImpl",'section':"Classes",'content':"wrenbind17::ForeignKlassImpl #  Module: Wrenbind17\nMore\u0026hellip;\n#include \u0026lt;foreign.hpp\u0026gt;\nInherits from wrenbind17::ForeignKlass\nPublic Functions #      Name      ForeignKlassImpl(std::string name)    ~ForeignKlassImpl() =default    ForeignKlassImpl(const ForeignKlassImpl\u0026lt; T \u0026gt; \u0026amp; other)   virtual void generate(std::ostream \u0026amp; os) const overrideGenerate Wren code for this class.   template \u0026lt;typename\u0026hellip; Args\u0026gt; void ctor(const std::string \u0026amp; name =\u0026quot;new\u0026rdquo;)Add a constructor to this class.   template \u0026lt;auto Fn\u0026gt; void func(std::string name)Add a member function to this class.   template \u0026lt;auto Fn\u0026gt; void func(const ForeignMethodOperator name)Add a member operator function to this class that exists outside of the class.   template \u0026lt;auto Fn\u0026gt; void funcExt(std::string name)Add a member function via a static function.   template \u0026lt;auto Fn\u0026gt; void funcExt(const ForeignMethodOperator name)Add a member operator via a static function that exists outside of the class.   template \u0026lt;auto Fn\u0026gt; void funcStatic(std::string name)Add a static function to this class.   template \u0026lt;auto Fn\u0026gt; void funcStaticExt(std::string name)Add a static function to this class that exists outside of the class.   template \u0026lt;auto Var\u0026gt; void var(std::string name)Add a read-write variable to this class.   template \u0026lt;auto Var\u0026gt; void varReadonly(std::string name)Add a read-only variable to this class.   template \u0026lt;auto Getter,auto Setter\u0026gt; void prop(std::string name)Add a read-write property to this class via a getter and a setter.   template \u0026lt;auto Getter\u0026gt; void propReadonly(std::string name)Add a read-onlu property to this class via a getter.   template \u0026lt;auto Getter,auto Setter\u0026gt; void propExt(std::string name)Add a read-write property to this class via a getter and a setter.   template \u0026lt;auto Getter\u0026gt; void propReadonlyExt(std::string name)Add a read-only property to this class via a getter.    Additional inherited members #  Public Functions inherited from wrenbind17::ForeignKlass\n    Name      ForeignKlass(std::string name)   virtual ~ForeignKlass() =default    ForeignKlass(const ForeignKlass \u0026amp; other)   ForeignMethod \u0026amp; findFunc(const std::string \u0026amp; name, const bool isStatic)Looks up a foreign function that belongs to this class.   ForeignProp \u0026amp; findProp(const std::string \u0026amp; name, const bool isStatic)Looks up a foreign property that belongs to this class.   WrenForeignMethodFn findSignature(const std::string \u0026amp; signature, const bool isStatic)Finds a function based on the signature.   const std::string \u0026amp; getName() constReturns the name of this foreign class.   WrenForeignClassMethods \u0026amp; getAllocators()Returns a struct with pointers to the allocator and deallocator.    Protected Attributes inherited from wrenbind17::ForeignKlass\n    Name     std::string name   std::string ctorDef   std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignMethod \u0026gt; \u0026gt; methods   std::unordered_map\u0026lt; std::string, std::unique_ptr\u0026lt; ForeignProp \u0026gt; \u0026gt; props   WrenForeignClassMethods allocators    Detailed Description #  template \u0026lt;typename T \u0026gt; class wrenbind17::ForeignKlassImpl; @brtief Type specific implementation of foreign class\nPublic Functions Documentation #  function ForeignKlassImpl #  inline ForeignKlassImpl( std::string name ) function ~ForeignKlassImpl #  ~ForeignKlassImpl() =default function ForeignKlassImpl #  ForeignKlassImpl( const ForeignKlassImpl\u0026lt; T \u0026gt; \u0026amp; other ) function generate #  inline virtual void generate( std::ostream \u0026amp; os ) const override Generate Wren code for this class.\nReimplements: wrenbind17::ForeignKlass::generate\nfunction ctor #  template \u0026lt;typename... Args\u0026gt; inline void ctor( const std::string \u0026amp; name =\u0026#34;new\u0026#34; ) Add a constructor to this class.\nfunction func #  template \u0026lt;auto Fn\u0026gt; inline void func( std::string name ) Add a member function to this class.\nThe number of arguments and what type of arguments this class needs is handled at compile time with metaprogramming. When this C++ function you are adding is called from Wren, it will check the types passed and will match the C++ signature. If the types do not match an exception is thrown that can be handled by Wren as a fiber.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} void bar() {...} int baz() const {...} }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods  cls.func\u0026lt;\u0026amp;Foo::bar\u0026gt;(\u0026#34;bar\u0026#34;); cls.func\u0026lt;\u0026amp;Foo::baz\u0026gt;(\u0026#34;baz\u0026#34;); } function func #  template \u0026lt;auto Fn\u0026gt; inline void func( const ForeignMethodOperator name ) Add a member operator function to this class that exists outside of the class.\nSee: ForeignMethodOperator\nThe number of arguments and what type of arguments this class needs is handled at compile time with metaprogramming. When this C++ function you are adding is called from Wren, it will check the types passed and will match the C++ signature. If the types do not match an exception is thrown that can be handled by Wren as a fiber.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} Foo\u0026amp; operator+(const std::string\u0026amp; other) {...} }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods  cls.func\u0026lt;\u0026amp;Foo::operator+\u0026gt;(wren::ForeignMethodOperator::OPERATOR_ADD); } function funcExt #  template \u0026lt;auto Fn\u0026gt; inline void funcExt( std::string name ) Add a member function via a static function.\nThe number of arguments and what type of arguments this class needs is handled at compile time with metaprogramming. When this C++ function you are adding is called from Wren, it will check the types passed and will match the C++ signature. If the types do not match an exception is thrown that can be handled by Wren as a fiber.\nThis function does not accept class methods, but instead it uses regular functions that have first parameter as \u0026ldquo;this\u0026rdquo; which is a reference to the class you are adding.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} std::string message; }; static std::string fooBaz(Foo\u0026amp; self, int a, int b) { return self.message; } int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods  cls.funcExt\u0026lt;\u0026amp;fooBaz\u0026gt;(\u0026#34;bar\u0026#34;); } function funcExt #  template \u0026lt;auto Fn\u0026gt; inline void funcExt( const ForeignMethodOperator name ) Add a member operator via a static function that exists outside of the class.\nSee: ForeignMethodOperator\nSame as funcExt but instead it can accept an operator enumeration.\nfunction funcStatic #  template \u0026lt;auto Fn\u0026gt; inline void funcStatic( std::string name ) Add a static function to this class.\nSee: func\nThe number of arguments and what type of arguments this class needs is handled at compile time with metaprogramming. When this C++ function you are adding is called from Wren, it will check the types passed and will match the C++ signature. If the types do not match an exception is thrown that can be handled by Wren as a fiber.\nThis only works if the function you are adding is static.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} static void bar() {...} static int baz() const {...} }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods  cls.funcStatic\u0026lt;\u0026amp;Foo::bar\u0026gt;(\u0026#34;bar\u0026#34;); cls.funcStatic\u0026lt;\u0026amp;Foo::baz\u0026gt;(\u0026#34;baz\u0026#34;); } function funcStaticExt #  template \u0026lt;auto Fn\u0026gt; inline void funcStaticExt( std::string name ) Add a static function to this class that exists outside of the class.\nSee: funcStatic\nThe number of arguments and what type of arguments this class needs is handled at compile time with metaprogramming. When this C++ function you are adding is called from Wren, it will check the types passed and will match the C++ signature. If the types do not match an exception is thrown that can be handled by Wren as a fiber.\nThis only works if the function you are adding is static.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} }; static void fooBar() { ... } static void fooBaz() { ... } int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add some methods  cls.funcStatic\u0026lt;\u0026amp;fooBar\u0026gt;(\u0026#34;bar\u0026#34;); cls.funcStatic\u0026lt;\u0026amp;fooBaz\u0026gt;(\u0026#34;baz\u0026#34;); } function var #  template \u0026lt;auto Var\u0026gt; inline void var( std::string name ) Add a read-write variable to this class.\nExample:\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} std::string msg; }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add class variable as a read write Wren class property  cls.var\u0026lt;\u0026amp;Foo::msg\u0026gt;(\u0026#34;msg\u0026#34;); } function varReadonly #  template \u0026lt;auto Var\u0026gt; inline void varReadonly( std::string name ) Add a read-only variable to this class.\nThis is exactly the same as var() but the variable can be only read from Wren. It cannot be reassigned.\nfunction prop #  template \u0026lt;auto Getter, auto Setter\u0026gt; inline void prop( std::string name ) Add a read-write property to this class via a getter and a setter.\nThis essentially creates the same thing as var() but instead of using pointer to the class field, it uses getter and setter functions.\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} void setMsg(const std::string\u0026amp; msg) {...} const std::string\u0026amp; getMsg() const {...} private: std::string msg; }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add class variable as a read write Wren class property  cls.prop\u0026lt;\u0026amp;Foo::getMsg, \u0026amp;Foo::setMsg\u0026gt;(\u0026#34;msg\u0026#34;); } function propReadonly #  template \u0026lt;auto Getter\u0026gt; inline void propReadonly( std::string name ) Add a read-onlu property to this class via a getter.\nThis essentially creates the same thing as varReadonly() but instead of using pointer to the class field, it uses a getter. This property will be read only and cannot be reassigned from Wren.\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} void setMsg(const std::string\u0026amp; msg) {...} const std::string\u0026amp; getMsg() const {...} private: std::string msg; }; int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add class variable as a read only Wren class property  cls.propReadonly\u0026lt;\u0026amp;Foo::getMsg\u0026gt;(\u0026#34;msg\u0026#34;); } function propExt #  template \u0026lt;auto Getter, auto Setter\u0026gt; inline void propExt( std::string name ) Add a read-write property to this class via a getter and a setter.\nSee: prop\nThis essentially creates the same thing as var() but instead of using pointer to the class field, it uses a static getter and setter. The setter and getter do not have to belong to the class itself, but must be static functions, and must accept the class as a reference as a first parameter.\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} std::string msg; }; static void fooSetMsg(Foo\u0026amp; self, const std::string\u0026amp; msg) { self.msg = msg; } static const std::string\u0026amp; msg fooGetMsg(Foo\u0026amp; self) { return self.msg; } int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add class variable as a read write Wren class property  cls.propExt\u0026lt;\u0026amp;fooGetMsg, \u0026amp;fooSetMsg\u0026gt;(\u0026#34;msg\u0026#34;); } function propReadonlyExt #  template \u0026lt;auto Getter\u0026gt; inline void propReadonlyExt( std::string name ) Add a read-only property to this class via a getter.\nSee: propReadonly\nThis essentially creates the same thing as varReadonly() but instead of using pointer to the class field, it uses a static getter. The setter and does not have to belong to the class itself, but must be static function, and must accept the class as a reference as a first parameter.\nclass Foo { public: Foo(const std::string\u0026amp; msg) {...} std::string msg; }; static const std::string\u0026amp; msg fooGetMsg(Foo\u0026amp; self) { return self.msg; } int main() { ... wren::VM vm; auto\u0026amp; m = vm.module(\u0026#34;mymodule\u0026#34;); // Add class \u0026#34;Foo\u0026#34;  auto\u0026amp; cls = m.klass\u0026lt;Foo\u0026gt;(\u0026#34;Foo\u0026#34;); // Define constructor (you can only specify one constructor)  cls.ctor\u0026lt;const std::string\u0026amp;\u0026gt;(); // Add class variable as a read only Wren class property  cls.propReadonlyExt\u0026lt;\u0026amp;fooGetMsg\u0026gt;(\u0026#34;msg\u0026#34;); }  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':52,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_method/','title':"wrenbind17::ForeignMethod",'section':"Classes",'content':"wrenbind17::ForeignMethod #  Module: Wrenbind17\nHolds information about a foreign function of a foreign class. #include \u0026lt;foreign.hpp\u0026gt;\nInherited by wrenbind17::ForeignMethodImpl\u0026lt; Args \u0026gt;\nPublic Functions #      Name      ForeignMethod(std::string name, WrenForeignMethodFn method, const bool isStatic)   virtual ~ForeignMethod() =default    ForeignMethod(const ForeignMethod \u0026amp; other)   virtual void generate(std::ostream \u0026amp; os) const =0   const std::string \u0026amp; getName() constReturns the name of the method.   WrenForeignMethodFn getMethod() constReturns the raw pointer of this method.   bool getStatic() constReturns true if this method is marked as static.    Protected Attributes #      Name     std::string name   WrenForeignMethodFn method   bool isStatic    Public Functions Documentation #  function ForeignMethod #  inline ForeignMethod( std::string name, WrenForeignMethodFn method, const bool isStatic ) function ~ForeignMethod #  virtual ~ForeignMethod() =default function ForeignMethod #  ForeignMethod( const ForeignMethod \u0026amp; other ) function generate #  virtual void generate( std::ostream \u0026amp; os ) const =0 Reimplemented by: wrenbind17::ForeignMethodImpl::generate\nfunction getName #  inline const std::string \u0026amp; getName() const Returns the name of the method.\nfunction getMethod #  inline WrenForeignMethodFn getMethod() const Returns the raw pointer of this method.\nfunction getStatic #  inline bool getStatic() const Returns true if this method is marked as static.\nProtected Attributes Documentation #  variable name #  std::string name; variable method #  WrenForeignMethodFn method; variable isStatic #  bool isStatic;  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':53,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_method_impl/','title':"wrenbind17::ForeignMethodImpl",'section':"Classes",'content':"wrenbind17::ForeignMethodImpl #  Module: Wrenbind17\nType specific implementation of foreign method. More\u0026hellip;\n#include \u0026lt;foreign.hpp\u0026gt;\nInherits from wrenbind17::ForeignMethod\nPublic Functions #      Name      ForeignMethodImpl(std::string name, std::string signature, WrenForeignMethodFn fn, const bool isStatic)    ~ForeignMethodImpl() =default   virtual void generate(std::ostream \u0026amp; os) const override   std::string generateSignature(const std::string \u0026amp; name)   std::string generateSignature(const ForeignMethodOperator name)   std::string generateName(const ForeignMethodOperator name)    Additional inherited members #  Public Functions inherited from wrenbind17::ForeignMethod\n    Name      ForeignMethod(std::string name, WrenForeignMethodFn method, const bool isStatic)   virtual ~ForeignMethod() =default    ForeignMethod(const ForeignMethod \u0026amp; other)   const std::string \u0026amp; getName() constReturns the name of the method.   WrenForeignMethodFn getMethod() constReturns the raw pointer of this method.   bool getStatic() constReturns true if this method is marked as static.    Protected Attributes inherited from wrenbind17::ForeignMethod\n    Name     std::string name   WrenForeignMethodFn method   bool isStatic    Detailed Description #  template \u0026lt;typename... Args\u0026gt; class wrenbind17::ForeignMethodImpl; Type specific implementation of foreign method.\nPublic Functions Documentation #  function ForeignMethodImpl #  inline ForeignMethodImpl( std::string name, std::string signature, WrenForeignMethodFn fn, const bool isStatic ) function ~ForeignMethodImpl #  ~ForeignMethodImpl() =default function generate #  inline virtual void generate( std::ostream \u0026amp; os ) const override Reimplements: wrenbind17::ForeignMethod::generate\nfunction generateSignature #  static inline std::string generateSignature( const std::string \u0026amp; name ) function generateSignature #  static inline std::string generateSignature( const ForeignMethodOperator name ) function generateName #  static inline std::string generateName( const ForeignMethodOperator name )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':54,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_module/','title':"wrenbind17::ForeignModule",'section':"Classes",'content':"wrenbind17::ForeignModule #  Module: Wrenbind17\n#include \u0026lt;module.hpp\u0026gt;\nPublic Functions #      Name      ForeignModule(std::string name, WrenVM * vm)    ForeignModule(const ForeignModule \u0026amp; other)    ForeignModule(ForeignModule \u0026amp;\u0026amp; other)    ~ForeignModule() =default   ForeignModule \u0026amp; operator=(const ForeignModule \u0026amp; other)   ForeignModule \u0026amp; operator=(ForeignModule \u0026amp;\u0026amp; other)   void swap(ForeignModule \u0026amp; other)   template \u0026lt;typename T ,typename\u0026hellip; Others\u0026gt; ForeignKlassImpl\u0026lt; T \u0026gt; \u0026amp; klass(std::string name)   std::string str() const   void append(std::string text)   ForeignKlass \u0026amp; findKlass(const std::string \u0026amp; name)   const std::string \u0026amp; getName() const    Public Functions Documentation #  function ForeignModule #  inline ForeignModule( std::string name, WrenVM * vm ) function ForeignModule #  ForeignModule( const ForeignModule \u0026amp; other ) function ForeignModule #  inline ForeignModule( ForeignModule \u0026amp;\u0026amp; other ) function ~ForeignModule #  ~ForeignModule() =default function operator= #  ForeignModule \u0026amp; operator=( const ForeignModule \u0026amp; other ) function operator= #  inline ForeignModule \u0026amp; operator=( ForeignModule \u0026amp;\u0026amp; other ) function swap #  inline void swap( ForeignModule \u0026amp; other ) function klass #  template \u0026lt;typename T , typename... Others\u0026gt; inline ForeignKlassImpl\u0026lt; T \u0026gt; \u0026amp; klass( std::string name ) function str #  inline std::string str() const function append #  inline void append( std::string text ) function findKlass #  inline ForeignKlass \u0026amp; findKlass( const std::string \u0026amp; name ) function getName #  inline const std::string \u0026amp; getName() const  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':55,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_prop/','title':"wrenbind17::ForeignProp",'section':"Classes",'content':"wrenbind17::ForeignProp #  Module: Wrenbind17\nHolds information about a foreign property of a foreign class. #include \u0026lt;foreign.hpp\u0026gt;\nInherited by wrenbind17::ForeignPropImpl\u0026lt; T, V \u0026gt;\nPublic Functions #      Name      ForeignProp(std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic)   virtual ~ForeignProp() =default    ForeignProp(const ForeignProp \u0026amp; other)   void generate(std::ostream \u0026amp; os) const   const std::string \u0026amp; getName() constReturns the name of this property.   WrenForeignMethodFn getSetter()Returns the pointer to the raw function for settings this property.   WrenForeignMethodFn getGetter()Returns the pointer to the raw function for getting this property.   bool getStatic() constReturns true if this property is static.    Protected Attributes #      Name     std::string name   WrenForeignMethodFn getter   WrenForeignMethodFn setter   bool isStatic    Public Functions Documentation #  function ForeignProp #  inline ForeignProp( std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic ) function ~ForeignProp #  virtual ~ForeignProp() =default function ForeignProp #  ForeignProp( const ForeignProp \u0026amp; other ) function generate #  inline void generate( std::ostream \u0026amp; os ) const function getName #  inline const std::string \u0026amp; getName() const Returns the name of this property.\nfunction getSetter #  inline WrenForeignMethodFn getSetter() Returns the pointer to the raw function for settings this property.\nfunction getGetter #  inline WrenForeignMethodFn getGetter() Returns the pointer to the raw function for getting this property.\nfunction getStatic #  inline bool getStatic() const Returns true if this property is static.\nProtected Attributes Documentation #  variable name #  std::string name; variable getter #  WrenForeignMethodFn getter; variable setter #  WrenForeignMethodFn setter; variable isStatic #  bool isStatic;  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':56,'href':'/wrenbind17/classes/classwrenbind17_1_1_foreign_prop_impl/','title':"wrenbind17::ForeignPropImpl",'section':"Classes",'content':"wrenbind17::ForeignPropImpl #  Module: Wrenbind17\nMore\u0026hellip;\n#include \u0026lt;foreign.hpp\u0026gt;\nInherits from wrenbind17::ForeignProp\nPublic Functions #      Name      ForeignPropImpl(std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic)    ~ForeignPropImpl() =default    Additional inherited members #  Public Functions inherited from wrenbind17::ForeignProp\n    Name      ForeignProp(std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic)   virtual ~ForeignProp() =default    ForeignProp(const ForeignProp \u0026amp; other)   void generate(std::ostream \u0026amp; os) const   const std::string \u0026amp; getName() constReturns the name of this property.   WrenForeignMethodFn getSetter()Returns the pointer to the raw function for settings this property.   WrenForeignMethodFn getGetter()Returns the pointer to the raw function for getting this property.   bool getStatic() constReturns true if this property is static.    Protected Attributes inherited from wrenbind17::ForeignProp\n    Name     std::string name   WrenForeignMethodFn getter   WrenForeignMethodFn setter   bool isStatic    Detailed Description #  template \u0026lt;typename T , typename V \u0026gt; class wrenbind17::ForeignPropImpl; Public Functions Documentation #  function ForeignPropImpl #  inline ForeignPropImpl( std::string name, WrenForeignMethodFn getter, WrenForeignMethodFn setter, const bool isStatic ) function ~ForeignPropImpl #  ~ForeignPropImpl() =default  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':57,'href':'/wrenbind17/classes/classwrenbind17_1_1_handle/','title':"wrenbind17::Handle",'section':"Classes",'content':"wrenbind17::Handle #  Module: Wrenbind17\nHolds a reference to some Wren type. More\u0026hellip;\n#include \u0026lt;handle.hpp\u0026gt;\nPublic Functions #      Name      Handle()    Handle(const std::shared_ptr\u0026lt; WrenVM \u0026gt; vm, WrenHandle * handle)    ~Handle()    Handle(const Handle \u0026amp; other)    Handle(Handle \u0026amp;\u0026amp; other)   Handle \u0026amp; operator=(const Handle \u0026amp; other)   Handle \u0026amp; operator=(Handle \u0026amp;\u0026amp; other)   void swap(Handle \u0026amp; other)   WrenHandle * getHandle() const   WrenVM * getVm() const   const std::weak_ptr\u0026lt; WrenVM \u0026gt; \u0026amp; getVmWeak() const   void reset()    operator bool() const    Detailed Description #  class wrenbind17::Handle; Holds a reference to some Wren type.\nThis is used by Map, Method, and Variable classes.\nPublic Functions Documentation #  function Handle #  inline Handle() function Handle #  inline Handle( const std::shared_ptr\u0026lt; WrenVM \u0026gt; vm, WrenHandle * handle ) function ~Handle #  inline ~Handle() function Handle #  Handle( const Handle \u0026amp; other ) function Handle #  inline Handle( Handle \u0026amp;\u0026amp; other ) function operator= #  Handle \u0026amp; operator=( const Handle \u0026amp; other ) function operator= #  inline Handle \u0026amp; operator=( Handle \u0026amp;\u0026amp; other ) function swap #  inline void swap( Handle \u0026amp; other ) function getHandle #  inline WrenHandle * getHandle() const function getVm #  inline WrenVM * getVm() const function getVmWeak #  inline const std::weak_ptr\u0026lt; WrenVM \u0026gt; \u0026amp; getVmWeak() const function reset #  inline void reset() function operator bool #  inline operator bool() const  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':58,'href':'/wrenbind17/classes/classwrenbind17_1_1_map/','title':"wrenbind17::Map",'section':"Classes",'content':"wrenbind17::Map #  Module: Wrenbind17\nHolds native Wren map. #include \u0026lt;map.hpp\u0026gt;\nPublic Functions #      Name      Map()    Map(const std::shared_ptr\u0026lt; Handle \u0026gt; \u0026amp; handle)    ~Map()   Handle \u0026amp; getHandle()   const Handle \u0026amp; getHandle() const    operator bool() const   void reset()   template \u0026lt;typename Key \u0026gt; bool contains(const Key \u0026amp; key) constChecks if a key exists in this map.   template \u0026lt;typename T ,typename Key \u0026gt; T get(const Key \u0026amp; key) constReturns a value specified by T from the map by a key.   template \u0026lt;typename Key \u0026gt; bool erase(const Key \u0026amp; key) constErases a key from the map.   size_t count() constReturns the size of the map.    Public Functions Documentation #  function Map #  inline Map() function Map #  inline Map( const std::shared_ptr\u0026lt; Handle \u0026gt; \u0026amp; handle ) function ~Map #  inline ~Map() function getHandle #  inline Handle \u0026amp; getHandle() function getHandle #  inline const Handle \u0026amp; getHandle() const function operator bool #  inline operator bool() const function reset #  inline void reset() function contains #  template \u0026lt;typename Key \u0026gt; inline bool contains( const Key \u0026amp; key ) const Checks if a key exists in this map.\nExceptions:\n RuntimeError if this is an invalid map or the Wren VM has terminated  Note: This function accepts any type you want. Integers, strings, booleans, does not matter as long as Wren map supports that key type.\nWarning: If using strings, make sure that you use std::string because raw C-strings are not allowed.\nfunction get #  template \u0026lt;typename T , typename Key \u0026gt; inline T get( const Key \u0026amp; key ) const Returns a value specified by T from the map by a key.\nExceptions:\n NotFound if the key does not exist in the map RuntimeError if this is an invalid map or the Wren VM has terminated  Note: This function accepts any type you want. Integers, strings, booleans, does not matter as long as Wren map supports that key type.\nWarning: If using strings, make sure that you use std::string because raw C-strings are not allowed.\nfunction erase #  template \u0026lt;typename Key \u0026gt; inline bool erase( const Key \u0026amp; key ) const Erases a key from the map.\nExceptions:\n NotFound if the key does not exist in the map RuntimeError if this is an invalid map or the Wren VM has terminated  Return: true if the key has been erased, otherwise false\nNote: This function accepts any type you want. Integers, strings, booleans, does not matter as long as Wren map supports that key type.\nWarning: If using strings, make sure that you use std::string because raw C-strings are not allowed.\nfunction count #  inline size_t count() const Returns the size of the map.\nExceptions:\n RuntimeError if this is an invalid map or the Wren VM has terminated   Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':59,'href':'/wrenbind17/classes/classwrenbind17_1_1_method/','title':"wrenbind17::Method",'section':"Classes",'content':"wrenbind17::Method #  Module: Wrenbind17\n#include \u0026lt;method.hpp\u0026gt;\nPublic Functions #      Name      Method() =default    Method(std::shared_ptr\u0026lt; Handle \u0026gt; variable, std::shared_ptr\u0026lt; Handle \u0026gt; handle)    ~Method()   template \u0026lt;typename\u0026hellip; Args\u0026gt; Any operator()(Args \u0026amp;\u0026amp;\u0026hellip; args)    operator bool() const   void reset()    Public Functions Documentation #  function Method #  Method() =default function Method #  inline Method( std::shared_ptr\u0026lt; Handle \u0026gt; variable, std::shared_ptr\u0026lt; Handle \u0026gt; handle ) function ~Method #  inline ~Method() function operator() #  template \u0026lt;typename... Args\u0026gt; inline Any operator()( Args \u0026amp;\u0026amp;... args ) function operator bool #  inline operator bool() const function reset #  inline void reset()  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':60,'href':'/wrenbind17/classes/classwrenbind17_1_1_not_found/','title':"wrenbind17::NotFound",'section':"Classes",'content':"wrenbind17::NotFound #  Module: Wrenbind17\n#include \u0026lt;exception.hpp\u0026gt;\nInherits from wrenbind17::Exception, std::exception\nPublic Functions #      Name      NotFound()    Additional inherited members #  Public Functions inherited from wrenbind17::Exception\n    Name      Exception() =default    Exception(std::string msg)   const char * what() const override    Public Functions Documentation #  function NotFound #  inline NotFound()  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':61,'href':'/wrenbind17/classes/classwrenbind17_1_1_return_value/','title':"wrenbind17::ReturnValue",'section':"Classes",'content':"wrenbind17::ReturnValue #  Module: Wrenbind17\nA return value when calling a Wren function (alias Any) More\u0026hellip;\n#include \u0026lt;any.hpp\u0026gt;\nPublic Functions #      Name      ReturnValue() =default    ReturnValue(const WrenType type, Handle handle)    ~ReturnValue() =default    ReturnValue(const ReturnValue \u0026amp; other)    ReturnValue(ReturnValue \u0026amp;\u0026amp; other)   ReturnValue \u0026amp; operator=(const ReturnValue \u0026amp; other)   ReturnValue \u0026amp; operator=(ReturnValue \u0026amp;\u0026amp; other)   void swap(ReturnValue \u0026amp; other)   const Handle \u0026amp; getHandle() const   Handle \u0026amp; getHandle()   WrenType getType() constThe raw wren type held by this instance.   template \u0026lt;class T \u0026gt; bool is() constCheck if the value held is some specific C++ type.   bool isMap() const   bool isList() const   template \u0026lt;class T \u0026gt; T as()Returns the value.   template \u0026lt;class T \u0026gt; std::shared_ptr\u0026lt; T \u0026gt; shared()Returns the value as a shared pointer.    Detailed Description #  class wrenbind17::ReturnValue; A return value when calling a Wren function (alias Any)\nSee: Any\nNote: This variable can safely outlive the wrenbind17::VM class. If that happens then functions of this class will throw wrenbind17::RuntimeError exception. This holder will not try to free the Wren variable if the VM has been terminated. You don\u0026rsquo;t have to worry about the lifetime of this holder. (uses weak pointers).\nThis extends the lifetime of the Wren object (handle). As long as this ReturnValue instance exists the Wren object will exist.\nPublic Functions Documentation #  function ReturnValue #  ReturnValue() =default function ReturnValue #  inline explicit ReturnValue( const WrenType type, Handle handle ) function ~ReturnValue #  ~ReturnValue() =default function ReturnValue #  ReturnValue( const ReturnValue \u0026amp; other ) function ReturnValue #  inline ReturnValue( ReturnValue \u0026amp;\u0026amp; other ) function operator= #  ReturnValue \u0026amp; operator=( const ReturnValue \u0026amp; other ) function operator= #  inline ReturnValue \u0026amp; operator=( ReturnValue \u0026amp;\u0026amp; other ) function swap #  inline void swap( ReturnValue \u0026amp; other ) function getHandle #  inline const Handle \u0026amp; getHandle() const Returns the handle that this instance owns\nfunction getHandle #  inline Handle \u0026amp; getHandle() Returns the handle that this instance owns\nfunction getType #  inline WrenType getType() const The raw wren type held by this instance.\nfunction is #  template \u0026lt;class T \u0026gt; inline bool is() const Check if the value held is some specific C++ type.\nNote: If the value held is a Wren numeric type then checking for any C++ integral or floating type will return true.\nfunction isMap #  inline bool isMap() const function isList #  inline bool isList() const function as #  template \u0026lt;class T \u0026gt; inline T as() Returns the value.\nExceptions:\n RuntimeError if this instance is invalid (constructed via the default constructor) BadCast if the type required by specifying the template argument does not match the type held  Template Parameters:\n T the type you want to get  See: shared()\nNote: If the value held is a Wren numeric type then getting for any C++ integral or floating type will result in a cast from a double to that type.\nfunction shared #  template \u0026lt;class T \u0026gt; inline std::shared_ptr\u0026lt; T \u0026gt; shared() Returns the value as a shared pointer.\nExceptions:\n RuntimeError if this instance is invalid (constructed via the default constructor) BadCast if the type required by specifying the template argument does not match the type held  Template Parameters:\n T the type of the std::shared_ptr you want to get  See: as()\nNote: Only works for custom C++ classes (foreign classes) that have been bound to the VM.\n Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':62,'href':'/wrenbind17/classes/classwrenbind17_1_1_runtime_error/','title':"wrenbind17::RuntimeError",'section':"Classes",'content':"wrenbind17::RuntimeError #  Module: Wrenbind17\n#include \u0026lt;exception.hpp\u0026gt;\nInherits from wrenbind17::Exception, std::exception\nPublic Functions #      Name      RuntimeError(std::string msg)    Additional inherited members #  Public Functions inherited from wrenbind17::Exception\n    Name      Exception() =default    Exception(std::string msg)   const char * what() const override    Public Functions Documentation #  function RuntimeError #  inline explicit RuntimeError( std::string msg )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':63,'href':'/wrenbind17/classes/classwrenbind17_1_1_std_list_bindings/','title':"wrenbind17::StdListBindings",'section':"Classes",'content':"wrenbind17::StdListBindings #  More\u0026hellip;\n#include \u0026lt;std.hpp\u0026gt;\nPublic Types #      Name     typedef std::list\u0026lt; T \u0026gt;::iterator Iterator   typedef std::list\u0026lt; T \u0026gt; List    Public Functions #      Name     void setIndex(List \u0026amp; self, size_t index, T value)   const T \u0026amp; getIndex(List \u0026amp; self, size_t index)   void add(List \u0026amp; self, T value)   std::variant\u0026lt; bool, Iterator \u0026gt; iterate(List \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other)   const T \u0026amp; iteratorValue(List \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other)   size_t count(List \u0026amp; self)   T removeAt(List \u0026amp; self, int32_t index)   void insert(List \u0026amp; self, int32_t index, T value)   bool contains(List \u0026amp; self, const T \u0026amp; value)   T pop(List \u0026amp; self)   void clear(List \u0026amp; self)   size_t size(List \u0026amp; self)   bool empty(List \u0026amp; self)   void bind(ForeignModule \u0026amp; m, const std::string \u0026amp; name)    Detailed Description #  template \u0026lt;typename T \u0026gt; class wrenbind17::StdListBindings; Public Types Documentation #  typedef Iterator #  typedef std::list\u0026lt;T\u0026gt;::iterator wrenbind17::StdListBindings\u0026lt; T \u0026gt;::Iterator; typedef List #  typedef std::list\u0026lt;T\u0026gt; wrenbind17::StdListBindings\u0026lt; T \u0026gt;::List; Public Functions Documentation #  function setIndex #  static inline void setIndex( List \u0026amp; self, size_t index, T value ) function getIndex #  static inline const T \u0026amp; getIndex( List \u0026amp; self, size_t index ) function add #  static inline void add( List \u0026amp; self, T value ) function iterate #  static inline std::variant\u0026lt; bool, Iterator \u0026gt; iterate( List \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other ) function iteratorValue #  static inline const T \u0026amp; iteratorValue( List \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other ) function count #  static inline size_t count( List \u0026amp; self ) function removeAt #  static inline T removeAt( List \u0026amp; self, int32_t index ) function insert #  static inline void insert( List \u0026amp; self, int32_t index, T value ) function contains #  static inline bool contains( List \u0026amp; self, const T \u0026amp; value ) function pop #  static inline T pop( List \u0026amp; self ) function clear #  static inline void clear( List \u0026amp; self ) function size #  static inline size_t size( List \u0026amp; self ) function empty #  static inline bool empty( List \u0026amp; self ) function bind #  static inline void bind( ForeignModule \u0026amp; m, const std::string \u0026amp; name )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':64,'href':'/wrenbind17/classes/classwrenbind17_1_1_std_vector_bindings/','title':"wrenbind17::StdVectorBindings",'section':"Classes",'content':"wrenbind17::StdVectorBindings #  More\u0026hellip;\n#include \u0026lt;std.hpp\u0026gt;\nPublic Types #      Name     typedef std::vector\u0026lt; T \u0026gt;::iterator Iterator   typedef std::vector\u0026lt; T \u0026gt; Vector    Public Functions #      Name     void setIndex(Vector \u0026amp; self, size_t index, T value)   const T \u0026amp; getIndex(Vector \u0026amp; self, size_t index)   void add(Vector \u0026amp; self, T value)   std::variant\u0026lt; bool, Iterator \u0026gt; iterate(Vector \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other)   const T \u0026amp; iteratorValue(Vector \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other)   size_t count(Vector \u0026amp; self)   T removeAt(Vector \u0026amp; self, int32_t index)   void insert(Vector \u0026amp; self, int32_t index, T value)   bool contains(Vector \u0026amp; self, const T \u0026amp; value)   T pop(Vector \u0026amp; self)   void clear(Vector \u0026amp; self)   size_t size(Vector \u0026amp; self)   bool empty(Vector \u0026amp; self)   void bind(ForeignModule \u0026amp; m, const std::string \u0026amp; name)    Detailed Description #  template \u0026lt;typename T \u0026gt; class wrenbind17::StdVectorBindings; Public Types Documentation #  typedef Iterator #  typedef std::vector\u0026lt;T\u0026gt;::iterator wrenbind17::StdVectorBindings\u0026lt; T \u0026gt;::Iterator; typedef Vector #  typedef std::vector\u0026lt;T\u0026gt; wrenbind17::StdVectorBindings\u0026lt; T \u0026gt;::Vector; Public Functions Documentation #  function setIndex #  static inline void setIndex( Vector \u0026amp; self, size_t index, T value ) function getIndex #  static inline const T \u0026amp; getIndex( Vector \u0026amp; self, size_t index ) function add #  static inline void add( Vector \u0026amp; self, T value ) function iterate #  static inline std::variant\u0026lt; bool, Iterator \u0026gt; iterate( Vector \u0026amp; self, std::variant\u0026lt; std::nullptr_t, Iterator \u0026gt; other ) function iteratorValue #  static inline const T \u0026amp; iteratorValue( Vector \u0026amp; self, std::shared_ptr\u0026lt; Iterator \u0026gt; other ) function count #  static inline size_t count( Vector \u0026amp; self ) function removeAt #  static inline T removeAt( Vector \u0026amp; self, int32_t index ) function insert #  static inline void insert( Vector \u0026amp; self, int32_t index, T value ) function contains #  static inline bool contains( Vector \u0026amp; self, const T \u0026amp; value ) function pop #  static inline T pop( Vector \u0026amp; self ) function clear #  static inline void clear( Vector \u0026amp; self ) function size #  static inline size_t size( Vector \u0026amp; self ) function empty #  static inline bool empty( Vector \u0026amp; self ) function bind #  static inline void bind( ForeignModule \u0026amp; m, const std::string \u0026amp; name )  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':65,'href':'/wrenbind17/classes/classwrenbind17_1_1_variable/','title':"wrenbind17::Variable",'section':"Classes",'content':"wrenbind17::Variable #  Module: Wrenbind17\nHolds some Wren variable which can be a class or class instance. More\u0026hellip;\n#include \u0026lt;variable.hpp\u0026gt;\nPublic Functions #      Name      Variable()    Variable(const std::shared_ptr\u0026lt; Handle \u0026gt; \u0026amp; handle)    ~Variable()   Method func(const std::string \u0026amp; signature)Looks up a function from this Wren variable.   Handle \u0026amp; getHandle()   const Handle \u0026amp; getHandle() const    operator bool() const   void reset()    Detailed Description #  class wrenbind17::Variable; Holds some Wren variable which can be a class or class instance.\nNote: This variable can safely outlive the wrenbind17::VM class. If that happens then functions of this class will throw wrenbind17::RuntimeError exception. This holder will not try to free the Wren variable if the VM has been terminated. You don\u0026rsquo;t have to worry about the lifetime of this holder. (uses weak pointers).\nYou can use this to pass around Wren classes or class instances. You can also use this to get Wren class methods. You can also call a Wren function from C++ side and pass this Variable into Wren. To get this variable, either call a Wren function that returns some class (or class instance), or use wrenbind17::VM::find() function that looks up a class (or class instance) based on the module name.\nPublic Functions Documentation #  function Variable #  inline Variable() function Variable #  inline Variable( const std::shared_ptr\u0026lt; Handle \u0026gt; \u0026amp; handle ) function ~Variable #  inline ~Variable() function func #  inline Method func( const std::string \u0026amp; signature ) Looks up a function from this Wren variable.\nExceptions:\n RuntimeError if this variable is invalid or the Wren VM has terminated.  The signature must match Wren function signature. For example: main() or foo(_,_) etc. Use underscores to specify parameters of that function.\nfunction getHandle #  inline Handle \u0026amp; getHandle() function getHandle #  inline const Handle \u0026amp; getHandle() const function operator bool #  inline operator bool() const function reset #  inline void reset()  Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':66,'href':'/wrenbind17/classes/classwrenbind17_1_1_v_m/','title':"wrenbind17::VM",'section':"Classes",'content':"wrenbind17::VM #  Module: Wrenbind17\nHolds the entire Wren VM from which all of the magic happens. #include \u0026lt;vm.hpp\u0026gt;\nPublic Classes #      Name     class Data    Public Functions #      Name      VM(std::vector\u0026lt; std::string \u0026gt; paths ={\u0026rdquo;./\u0026quot;}, const size_t initHeap =1024 *1024, const size_t minHeap =1024 *1024 *10, const int heapGrowth =50)The only constructor available.    VM(const VM \u0026amp; other)    VM(VM \u0026amp;\u0026amp; other)    ~VM() =default   VM \u0026amp; operator=(const VM \u0026amp; other)   VM \u0026amp; operator=(VM \u0026amp;\u0026amp; other)   void swap(VM \u0026amp; other)   void runFromSource(const std::string \u0026amp; name, const std::string \u0026amp; code)Runs a Wren source code by passing it as a string.   void runFromFile(const std::string \u0026amp; name, const std::string \u0026amp; path)Runs a Wren source code directly from a file.   void runFromModule(const std::string \u0026amp; name)Runs a Wren source code by passing it as a string.   Variable find(const std::string \u0026amp; module, const std::string \u0026amp; name)Looks up a variable from a module.   ForeignModule \u0026amp; module(const std::string \u0026amp; name)Creates a new custom module.   void addClassType(const std::string \u0026amp; module, const std::string \u0026amp; name, const size_t hash)   void getClassType(std::string \u0026amp; module, std::string \u0026amp; name, const size_t hash)   bool isClassRegistered(const size_t hash) const   void addClassCast(std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, const size_t hash, const size_t other)   detail::ForeignPtrConvertor * getClassCast(const size_t hash, const size_t other)   std::string getLastError()   void setNextError(std::string str)   void setPrintFunc(const PrintFn \u0026amp; fn)Set a custom print function that is used by the System.print()   void setLoadFileFunc(const LoadFileFn \u0026amp; fn)Set a custom loader function for imports.   void gc()Runs the garbage collector.    Public Functions Documentation #  function VM #  inline explicit VM( std::vector\u0026lt; std::string \u0026gt; paths ={\u0026#34;./\u0026#34;}, const size_t initHeap =1024 *1024, const size_t minHeap =1024 *1024 *10, const int heapGrowth =50 ) The only constructor available.\nParameters:\n paths The lookup paths used by the import loader function initHeap The size of the heap at the beginning minHeap The minimum size of the heap heapGrowth How the heap should grow  function VM #  inline VM( const VM \u0026amp; other ) function VM #  inline VM( VM \u0026amp;\u0026amp; other ) function ~VM #  inline ~VM() =default function operator= #  inline VM \u0026amp; operator=( const VM \u0026amp; other ) function operator= #  inline VM \u0026amp; operator=( VM \u0026amp;\u0026amp; other ) function swap #  inline void swap( VM \u0026amp; other ) function runFromSource #  inline void runFromSource( const std::string \u0026amp; name, const std::string \u0026amp; code ) Runs a Wren source code by passing it as a string.\nParameters:\n name The module name to assign this code into, this module name can be then used to import this code in some other place code Your raw multiline Wren code  Exceptions:\n CompileError if the compilation has failed  function runFromFile #  inline void runFromFile( const std::string \u0026amp; name, const std::string \u0026amp; path ) Runs a Wren source code directly from a file.\nParameters:\n name The module name to assign this code into, this module name can be then used to import this code in some other place path The path to the file  Exceptions:\n Exception if the file has not been found or the file cannot be read CompileError if the compilation has failed  function runFromModule #  inline void runFromModule( const std::string \u0026amp; name ) Runs a Wren source code by passing it as a string.\nParameters:\n name The module name to load, this will use the loader function to load the file from  Exceptions:\n CompileError if the compilation has failed  See: setLoadFileFunc\nfunction find #  inline Variable find( const std::string \u0026amp; module, const std::string \u0026amp; name ) Looks up a variable from a module.\nParameters:\n module The name of the module to look for the variable in name The name of the variable or a class itself that must start with a capital letter  Exceptions:\n NotFound if the variable has not been found  function module #  inline ForeignModule \u0026amp; module( const std::string \u0026amp; name ) Creates a new custom module.\nNote: Calling this function multiple times with the same name does not create a new module, but instead it returns the same module.\nfunction addClassType #  inline void addClassType( const std::string \u0026amp; module, const std::string \u0026amp; name, const size_t hash ) function getClassType #  inline void getClassType( std::string \u0026amp; module, std::string \u0026amp; name, const size_t hash ) function isClassRegistered #  inline bool isClassRegistered( const size_t hash ) const function addClassCast #  inline void addClassCast( std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, const size_t hash, const size_t other ) function getClassCast #  inline detail::ForeignPtrConvertor * getClassCast( const size_t hash, const size_t other ) function getLastError #  inline std::string getLastError() function setNextError #  inline void setNextError( std::string str ) function setPrintFunc #  inline void setPrintFunc( const PrintFn \u0026amp; fn ) Set a custom print function that is used by the System.print()\nSee: PrintFn\nfunction setLoadFileFunc #  inline void setLoadFileFunc( const LoadFileFn \u0026amp; fn ) Set a custom loader function for imports.\nSee: LoadFileFn\nThis must be a function that accepts a std::vector of strings (which are the lookup paths from the constructor) and the name of the import as the second parameter. You must return the source code from this custom function. If you want to cancel the import, simply throw an exception.\nfunction gc #  inline void gc() Runs the garbage collector.\n Updated on 7 May 2023 at 16:44:23 UTC\n"});index.add({'id':67,'href':'/wrenbind17/classes/classwrenbind17_1_1_v_m_1_1_data/','title':"wrenbind17::VM::Data",'section':"Classes",'content':"wrenbind17::VM::Data #  #include \u0026lt;vm.hpp\u0026gt;\nPublic Functions #      Name     void addClassType(const std::string \u0026amp; module, const std::string \u0026amp; name, const size_t hash)   void getClassType(std::string \u0026amp; module, std::string \u0026amp; name, const size_t hash)   bool isClassRegistered(const size_t hash) const   void addClassCast(std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, const size_t hash, const size_t other)   detail::ForeignPtrConvertor * getClassCast(const size_t hash, const size_t other)   std::string getLastError()   void setNextError(std::string str)    Public Attributes #      Name     std::shared_ptr\u0026lt; WrenVM \u0026gt; vm   WrenConfiguration config   std::vector\u0026lt; std::string \u0026gt; paths   std::unordered_map\u0026lt; std::string, ForeignModule \u0026gt; modules   std::unordered_map\u0026lt; size_t, std::string \u0026gt; classToModule   std::unordered_map\u0026lt; size_t, std::string \u0026gt; classToName   std::unordered_map\u0026lt; std::pair\u0026lt; size_t, size_t \u0026gt;, std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; \u0026gt; classCasting   std::string lastError   std::string nextError   PrintFn printFn   LoadFileFn loadFileFn    Public Functions Documentation #  function addClassType #  inline void addClassType( const std::string \u0026amp; module, const std::string \u0026amp; name, const size_t hash ) function getClassType #  inline void getClassType( std::string \u0026amp; module, std::string \u0026amp; name, const size_t hash ) function isClassRegistered #  inline bool isClassRegistered( const size_t hash ) const function addClassCast #  inline void addClassCast( std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; convertor, const size_t hash, const size_t other ) function getClassCast #  inline detail::ForeignPtrConvertor * getClassCast( const size_t hash, const size_t other ) function getLastError #  inline std::string getLastError() function setNextError #  inline void setNextError( std::string str ) Public Attributes Documentation #  variable vm #  std::shared_ptr\u0026lt; WrenVM \u0026gt; vm; variable config #  WrenConfiguration config; variable paths #  std::vector\u0026lt; std::string \u0026gt; paths; variable modules #  std::unordered_map\u0026lt; std::string, ForeignModule \u0026gt; modules; variable classToModule #  std::unordered_map\u0026lt; size_t, std::string \u0026gt; classToModule; variable classToName #  std::unordered_map\u0026lt; size_t, std::string \u0026gt; classToName; variable classCasting #  std::unordered_map\u0026lt; std::pair\u0026lt; size_t, size_t \u0026gt;, std::shared_ptr\u0026lt; detail::ForeignPtrConvertor \u0026gt; \u0026gt; classCasting; variable lastError #  std::string lastError; variable nextError #  std::string nextError; variable printFn #  PrintFn printFn; variable loadFileFn #  LoadFileFn loadFileFn;  Updated on 7 May 2023 at 16:44:23 UTC\n"});})();